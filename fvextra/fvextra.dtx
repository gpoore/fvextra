% \iffalse meta-comment
%
% Copyright (C) 2016-2025 by Geoffrey M. Poore <gpoore@gmail.com>
% ---------------------------------------------------------------------------
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Geoffrey M. Poore.
%
% This work consists of the files fvextra.dtx and fvextra.ins
% and the derived filebase fvextra.sty.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{fvextra.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{fvextra}
%<*package>
    [2025/05/29 v1.13.2 fvextra - extensions and patches for fancyvrb]
%</package>
%
%<*driver>
\documentclass{ltxdoc}

\makeatletter

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{microtype}

\usepackage[svgnames]{xcolor}
\usepackage{upquote}
% The typesetting for macrocode doesn't use \@noligs, which upquote modifies.
% So apply the upquote fix to \verbatim@nolig@list as well, which is in macrocode.
\begingroup
\catcode`'=\active
\catcode``=\active
\g@addto@macro\verbatim@nolig@list{%
  \let'\textquotesingle
  \let`\textasciigrave
  \ifx\encodingdefault\upquote@OTone
  \ifx\ttdefault\upquote@cmtt
    \def'{\char13 }%
    \def`{\char18 }%
  \fi\fi}
\endgroup
\usepackage{fvextra}

\usepackage{dingbat}
\usepackage{graphicx}

\usepackage{amsmath, amssymb}

\usepackage{environ}

\usepackage[many]{tcolorbox}
\tcbuselibrary{listings}
\tcbset{verbatim ignore percent}


\usepackage{hyperref}
\hypersetup{
  pdftitle=The fvextra package: extensions and patches for fancyvrb,
  pdfauthor=Geoffrey M. Poore,
  pdfsubject={fvextra LaTeX package manual},
  colorlinks=true,
  allcolors=ForestGreen,
}
\usepackage{cleveref}

% A more robust \cmd
\let\cmd\Verb

% Create a short verbatim pipe that handles quotation marks properly
\begingroup
\catcode`\|=\active
\gdef\pipe@active@verbatim{%
  \begingroup
  \let\do\@makeother\dospecials
  \catcode`\|=\active
  \catcode`\`=\active
  \catcode`\'=\active
  \catcode`\<=\active
  \catcode`\>=\active
  \catcode`\-=\active
  \catcode`\,=\active
  \catcode`\ =\active
  \pipe@active@verbatim@i}
\gdef\pipe@active@verbatim@i#1|{%
  \endgroup
  \begingroup
  \def\FV@SV@pipe@active@verbatim{%
    \FV@Gobble
    \expandafter\FV@ProcessLine\expandafter{#1}}%
  %\let\FV@BeginVBox\relax
  %\let\FV@EndVBox\relax
  %\def\FV@BProcessLine##1{\FancyVerbFormatLine{##1}}%
  \BUseVerbatim{pipe@active@verbatim}%
  \endgroup}
\AtBeginDocument{\let|\pipe@active@verbatim}
\endgroup

\renewenvironment{verbatim}%
 {\VerbatimEnvironment\begin{Verbatim}[gobble=1]}%
 {\end{Verbatim}}


\newcommand{\todo}[1]{}
%\newcommand{\todo}[1]{\textcolor{red}{TO~DO: \scantokens{#1}}}

\newcommand\pkg[1]{\textsf{#1}}

\def\MacroFont{%
  \fontencoding\encodingdefault%
  \fontfamily\ttdefault%
  \fontseries\mddefault%
  \fontshape\updefault%
  \small}

\def\PrintMacroName#1{{\strut\MacroFont\color{DarkGreen}\footnotesize\string #1\ }}

\def\PrintDescribeMacro#1{\strut\MacroFont\textcolor{DarkGreen}{\string #1\ }}
\let\PrintDescribeEnv\PrintDescribeMacro
%\let\PrintMacroName\PrintDescribeMacro
\let\PrintEnvName\PrintDescribeEnv

\def\theCodelineNo{\textcolor{DarkGreen}{\sffamily\scriptsize{\arabic{CodelineNo}}}}


\renewenvironment{macro}{\macro@custom@arg}{}
\def\macro@custom@arg{%
  \begingroup\makeatletter\macro@custom@arg@i}
\def\macro@custom@arg@i#1{%
  \makeatother
  \par\noindent
  \ifstrempty{#1}%
   {~\par}%
   {\ttfamily\color{DarkGreen}\hspace*{-0.5in}%
    \macro@custom@arg@split#1,\FV@Sentinel\par}%
  \endgroup}
\def\macro@custom@arg@spacegobble#1{#1}
\def\macro@custom@arg@split#1,#2\FV@Sentinel{%
  \expandafter\string\macro@custom@arg@spacegobble#1%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {}{\\\hspace*{-0.5in}\macro@custom@arg@split#2\FV@Sentinel}}

\renewenvironment{environment}{\env@custom@arg}{}
\def\env@custom@arg{%
  \begingroup\makeatletter\env@custom@arg@i}
\def\env@custom@arg@i#1{%
  \makeatother
  \ifstrempty{#1}%
   {~\par}%
   {\ttfamily\color{DarkGreen}\hspace*{-0.5in}%
    \env@custom@arg@split#1,\FV@Sentinel\par}%
  \endgroup}
\def\env@custom@arg@spacegobble#1{#1}
\def\env@custom@arg@split#1,#2\FV@Sentinel{%
  \env@custom@arg@spacegobble#1{\textrm{ \textit{(env.)}}}%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {}{\\\hspace*{-0.5in}\env@custom@arg@split#2\FV@Sentinel}}


\let\orig@footnote\footnote
\renewcommand{\footnote}{%
  \begingroup
  \let\do\@makeother
  \dospecials
  \catcode`\{=1
  \catcode`\}=2
  \new@footnote}
\newcommand{\new@footnote}[1]{%
  \endgroup
  \orig@footnote{\scantokens{#1}}}


\def\fvextra@optionlist@printopt#1(#2) (#3){%
  \vspace{0.1in}%
  \leavevmode%
  \marginpar{\raggedleft\texttt{\textcolor{DarkGreen}{\small #1}}\ }%
  \kern-\parindent\textsf{(#2)}\hfill(default: \texttt{#3})\\}

\newenvironment{optionlist}%
 {~\par\vspace{-14pt}%
  \def\pipechar{|}
  \let\|\pipechar
  \newcommand*\fvextra@optionlist@next{}%
  \let\item@orig\item
  \renewcommand*\item[1][]{%
    \ifdefstring{\@currenvir}{optionlist}%
     {\fvextra@optionlist@next%
      \renewcommand*\fvextra@optionlist@next{\par}%
      \fvextra@optionlist@printopt##1%
      \ignorespaces}%
     {\ifstrempty{##1}%
      {\vspace{-4pt}\item@orig}
      {\vspace{-4pt}\item@orig[##1]}}}}
 {\par}


\CustomVerbatimEnvironment{VerbatimVerbatim}{Verbatim}{}
\CustomVerbatimEnvironment{VerbatimVerbatimBuffer}{VerbatimBuffer}{}

\newenvironment{example}
 {\VerbatimEnvironment
  \begin{VerbatimVerbatimBuffer}[
    buffername=fvexample,
    gobble=1,
    afterbuffer={%
      \vspace{1ex}%
      \setlength{\parindent}{0pt}%
      \setlength{\fboxsep}{1em}%
      \fcolorbox{DarkGreen}{white}{%
        \begin{minipage}{0.5\linewidth}%
        \VerbatimInsertBuffer[buffername=fvexample]%
        \end{minipage}%
        \hspace{0.025\linewidth}%
        {\color{DarkGreen}\vrule}%
        \hspace{0.025\linewidth}%
        \begin{minipage}{0.4\linewidth}%
        \InsertBuffer[buffername=fvexample]%
        \end{minipage}}%
      \vspace{1ex}%
    }]}
  {\end{VerbatimVerbatimBuffer}}

\newenvironment{longexample}
  {\VerbatimEnvironment
   \begin{VerbatimVerbatimBuffer}[
    buffername=fvexample,
    gobble=1,
    afterbuffer={%
      \vspace{1ex}%
      \setlength{\parindent}{0pt}%
      \setlength{\fboxsep}{1em}%
      \fcolorbox{DarkGreen}{white}{%
        \begin{minipage}{0.94\linewidth}%
        \VerbatimInsertBuffer[buffername=fvexample]%
        {\color{DarkGreen}\hrulefill}%
        \setlength{\fboxsep}{3pt}%
        \InsertBuffer[buffername=fvexample]%
        \end{minipage}}%
      \vspace{1ex}%
    }]}
  {\end{VerbatimVerbatimBuffer}}

\newenvironment{tcbexample}
 {\VerbatimEnvironment
  \begin{VerbatimVerbatimBuffer}[
    gobble=1,
    buffername=tcbexample,
    afterbuffer={
      \begin{tcolorbox}[oversize=5em]
      \VerbatimInsertBuffer[buffername=tcbexample]
      \tcbline
      \InsertBuffer[buffername=tcbexample]
      \end{tcolorbox}
    }]}
 {\end{VerbatimVerbatimBuffer}}


\edef\hashchar{\string#}


%\EnableCrossrefs
%\CodelineIndex
%\RecordChanges

\makeatother
\begin{document}
  \DocInput{fvextra.dtx}
  %\PrintChanges
  %\PrintIndex
\end{document}
%</driver>
% \fi
%
%
% \DoNotIndex{\newcommand,\newenvironment}
% \DoNotIndex{\#,\$,\%,\&,\@,\\,\{,\},\^,\_,\~,\ }
% \DoNotIndex{\@ne}
% \DoNotIndex{\advance,\begingroup,\catcode,\closein}
% \DoNotIndex{\closeout,\day,\def,\edef,\else,\empty,\endgroup}
% \DoNotIndex{\begin,\end,\bgroup,\egroup}
%
% \providecommand*{\url}{\texttt}
% \newcommand{\fvextra}{\pkg{fvextra}}
% \newcommand{\fancyvrb}{\pkg{fancyvrb}}
% \GetFileInfo{fvextra.dtx}
%
% \title{\vspace{-0.5in}The \fvextra\ package}
% \author{Geoffrey M.\ Poore \\ \href{mailto://gpoore@gmail.com}{\texttt{gpoore@gmail.com}} \\ \href{https://github.com/gpoore/fvextra}{\texttt{github.com/gpoore/fvextra}}}
% \date{\fileversion~from \filedate}
%
% \maketitle
%
% \begin{abstract}
% \noindent\fvextra\ provides several extensions to \fancyvrb, including automatic line breaking and improved math mode.  \cmd{\Verb} is reimplemented so that it works (with a few limitations) inside other commands, even in movable arguments and PDF bookmarks.  The new command \cmd{\EscVerb} is similar to \cmd{\Verb} except that it works everywhere without limitations by allowing the backslash to serve as an escape character.  \fvextra\ also patches some \fancyvrb\ internals.
% \end{abstract}
%
%
% \pagebreak
% \begingroup
% \makeatletter
% ^^A https://tex.stackexchange.com/a/45165/10742
% \patchcmd{\@dottedtocline}
%   {\rightskip\@tocrmarg}
%   {\rightskip\@tocrmarg plus 4em \hyphenpenalty\@M}
%   {}{}
% \makeatother
% \tableofcontents
% \endgroup
% \pagebreak
%
%
% \section{Introduction}
%
% The \fancyvrb\ package had its first public release in January 1998.  In July of the same year, a few additional features were added.  Since then, the package has remained almost unchanged except for a few bug fixes.  \fancyvrb\ has become one of the primary \LaTeX\ packages for working with verbatim text.
%
% Additional verbatim features would be nice, but since \fancyvrb\ has remained almost unchanged for so long, a major upgrade could be problematic.  There are likely many existing documents that tweak or patch \fancyvrb\ internals in a way that relies on the existing implementation.  At the same time, creating a completely new verbatim package would require a major time investment and duplicate much of \fancyvrb\ that remains perfectly functional.  Perhaps someday there will be an amazing new verbatim package.  Until then, we have \fvextra.
%
% \fvextra\ is an add-on package that gives \fancyvrb\ several additional features, including automatic line breaking.  Because \fvextra\ patches and overwrites some of the \fancyvrb\ internals, it may not be suitable for documents that rely on the details of the original \fancyvrb\ implementation.  \fvextra\ tries to maintain the default \fancyvrb\ behavior in most cases.  All reimplementations (\cref{sec:reimplemented-cmd}), patches (\cref{sec:patch}), and modifications to \fancyvrb\ defaults (\cref{sec:modifications}) are documented.  In most cases, there are options to switch back to original implementations or original default behavior.
%
% Some features of \fvextra\ were originally created as part of the \pkg{pythontex} and \pkg{minted} packages.  \fancyvrb-related patches and extensions that currently exist in those packages will gradually be migrated into \fvextra.
%
%
%
%
% \section{Usage}
%
% \fvextra\ may be used as a drop-in replacement for \fancyvrb.  It will load \fancyvrb\ if it has not yet been loaded, and then proceeds to patch \fancyvrb\ and define additional features.
%
% The \pkg{upquote} package is loaded to give correct backticks (\texttt{\textasciigrave}) and typewriter single quotation marks (\texttt{\textquotesingle}).  When this is not desirable within a given environment, use the option |curlyquotes|.  \fvextra\ modifies the behavior of these and other symbols in typeset math within verbatim, so that they will behave as expected (\cref{sec:patch:math}).  \fvextra\ uses the \pkg{lineno} package for working with automatic line breaks.  \pkg{lineno} gives a warning when the \pkg{csquotes} package is loaded before it, so \fvextra\ should be loaded before \pkg{csquotes}.  The \pkg{etoolbox} package is required.  \pkg{color} or \pkg{xcolor} should be loaded manually to use color-dependent features.
%
% While \fvextra\ attempts to minimize changes to the \fancyvrb\ internals, in some cases it completely overwrites \fancyvrb\ macros with new definitions.  New definitions typically follow the original definitions as much as possible, but code that depends on the details of the original \fancyvrb\ implementation may be incompatible with \fvextra.
%
%
% \subsection{Pandoc compatibility}
%
% \pkg{fvextra} supports line breaking in \href{https://pandoc.org/}{Pandoc} \LaTeX\ output that includes highlighted source code.  Enabling basic line breaking at spaces is as simple as adding |\usepackage{fvextra}| and |\fvset{breaklines}| to the Pandoc Markdown |header-includes|.
%
% By default, more advanced line breaking features such as |breakanywhere|, |breakbefore|, and |breakafter| will not work with Pandoc highlighted output, due to the presence of the syntax highlighting macros.  This can be fixed by using |breaknonspaceingroup|, which enables all line breaking features within macros.  For example, the following YAML metadata in a Markdown document would redefine the Pandoc |Highlighting| environment to enable line breaking anywhere.
%
%\vspace{2ex}
%\hrule
%\vspace{2ex}
%\noindent\begin{minipage}{\linewidth}
%\begin{verbatim}
%---
%header-includes:
% -  |
%    ```{=latex}
%    \usepackage{fvextra}
%    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{
%      commandchars=\\\{\},
%      breaklines, breaknonspaceingroup, breakanywhere}
%    ```
%---
%\end{verbatim}
%\end{minipage}
%\vspace{2ex}
%\hrule
%\vspace{2ex}
%
%
%
%
% \section{General options}
% \label{sec:general-options}
%
% \fvextra\ adds several general options to \fancyvrb.  All options related to automatic line breaking are described separately in \cref{sec:breaklines}.  All options related to syntax highlighting using Pygments are described in \cref{sec:pygments}.
%
% \begin{optionlist}
%
% \item[backgroundcolor (string) (none)]
% Background color behind commands and environments.  This is only a basic, lightweight implementation of background colors using |\colorbox|.  For more control of background colors, consider \href{https://ctan.org/pkg/tcolorbox}{\pkg{tcolorbox}} or a similar package, or a custom background color implementation.
%
% Background colors are implemented with |\colorbox|, which prevents line breaking for |\Verb|, |\UseVerb|, and |\EscVerb|.  Background colors are only compatible with \fvextra's reimplemented |\Verb| and |\UseVerb| (|extra=true|).
%
% When there is a background color in environments such as |Verbatim| that typeset blocks of text, some PDF readers and browsers can introduce rendering artifacts.  These appear in between lines of text as extremely thin horizontal rules that are the color of the page behind the background.  They tend to be more noticeable for dark background colors on a light page.  \fvextra\ attempts to prevent rendering artifacts by slightly oversizing the |\colorbox| behind each line and then slightly overlapping these boxes.  This overlap can be fine-tuned if necessary with |backgroundcolorboxoverlap|.  If rendering artifacts are an issue with your software in spite of a small overlap, consider \href{https://ctan.org/pkg/tcolorbox}{\pkg{tcolorbox}} or a similar package, or a custom background color implementation.
%
% See |backgroundcolorvphantom| to customize the height of the background for each line of text, especially for |\Verb|, |\EscVerb|, and |BVerbatim|.
%
% When |backgroundcolor| is used with |Verbatim| with a |frame|, it may be necessary to adjust |framesep| and |fillcolor| depending on the desired result.  |backgroundcolorpadding| provides a shortcut for this.
%
%
% \item[backgroundcolorboxoverlap (length) (0.25pt)]
% The amount by which |\colorbox|es that are used to provide |backgroundcolor| are oversized and then overlapped, to prevent rendering artifacts.
%
% When there is a background color in environments such as |Verbatim| that typeset blocks of text, some PDF readers and browsers can introduce rendering artifacts.  These appear in between lines of text as extremely thin horizontal rules that are the color of the page behind the background.  They tend to be more noticeable for dark background colors on a light page.  \fvextra\ attempts to prevent rendering artifacts by slightly oversizing the |\colorbox| behind each line by |backgroundcolorboxoverlap|, and then slightly overlapping these boxes by the same amount.
%
% Chrome and Adobe Acrobat Reader generally work correctly even with no overlap (|backgroundcolorboxoverlap=0pt|).  Many PDF previews in \TeX\ editing software and PDF readers need an overlap in the |0.1pt| to |0.15pt| range.  Whether Firefox needs overlap, and if so the amount needed, seems to depend on resolution and possibly operating system.  Safari and macOS Preview may show artifacts, particularly when zoomed out, even with overlaps of |0.25pt| or greater.
%
%
% \item[backgroundcolorpadding (length) (none)]
% Padding when |backgroundcolor| is set.  For |\Verb|, |\UseVerb|, |\EscVerb|, and |BVerbatim|, this sets |\fboxsep| for the |\colorbox| that is used to create the background color.  For |Verbatim|, \fancyvrb's frame options are used instead, particularly |framesep| and |fillcolor|.
%
% For |Verbatim|, this amounts to a shortcut for a combination of frame-related settings that provide padding when there is a background color.  This is only intended for cases with |frame=none| or |frame=single|.  In other cases, it may be better to modify the \fancyvrb\ frame settings directly, and it may be necessary to modify the \fancyvrb\ internals to obtain padding on all sides.
%
% For |Verbatim|, if |frame=single|, then this is equivalent to the following settings:
% \begin{itemize}
% \item |framesep=|\meta{\texttt{backgroundcolorpadding}}
% \item |fillcolor=\FancyVerbBackgroundColor|
% \end{itemize}
%
% For |Verbatim|, if |frame| has any value other than |single|, then this is equivalent to the following settings:
% \begin{itemize}
% \item |frame=single|
% \item |framerule=0pt|
% \item |rulecolor=\FancyVerbBackgroundColor|
% \item |framesep=|\meta{\texttt{backgroundcolorpadding}}
% \item |fillcolor=\FancyVerbBackgroundColor|
% \end{itemize}
%
%
% \item[backgroundcolorvphantom (macro) (\Verb{\vphantom{\"Apgjy}})]
% |\vphantom| or similar macro such as |\strut| that is inserted at the beginning of each line of text using |backgroundcolor|.  This allows the height of the background for each line of text to be customized, especially for |\Verb|, |\EscVerb|, and |BVerbatim|.   |backgroundcolorvphantom| will typically have no effect on |Verbatim|-based environments unless it is set to a size larger than |\strut|.
%
% \item[bgcolor (string) (none)]
% Alias for |backgroundcolor|.
%
% \item[bgcolorboxoverlap (length) (0.25pt)]
% Alias for |backgroundcolorboxoverlap|.
%
% \item[bgcolorpadding (length) (none)]
% Alias for |backgroundcolorpadding|.
%
% \item[bgcolorvphantom (macro) (\Verb{\vphantom{\"Apgjy}})]
% Alias for |backgroundcolorvphantom|.
%
%
% \item[beameroverlays (boolean) (false)]
% Give the |<| and |>| characters their normal text meanings, so that \pkg{beamer} overlays of the form |\only<1>{...}| will work.  Note that something like |commandchars=\\\{\}| is required separately to enable macros.  This is not incorporated in the |beameroverlays| option because essentially arbitrary command characters could be used; only the |<| and |>| characters are hard-coded for overlays.
%
% With some font encodings and language settings, |beameroverlays| prevents literal (non-overlay) |<| and |>| characters from appearing correctly, so they must be inserted using commands.
%
%
% \item[curlyquotes (boolean) (false)]
% Unlike \fancyvrb, \pkg{fvextra} requires the \pkg{upquote} package, so the backtick (\texttt{\textasciigrave}) and typewriter single quotation mark (\texttt{\textquotesingle}) always appear literally by default, instead of becoming the left and right curly single quotation marks (\texttt{`'}).  This option allows these characters to be replaced by the curly quotation marks when that is desirable.
%
%\begin{example}
%\begin{Verbatim}
%`quoted text'
%\end{Verbatim}
%\end{example}
%
%\begin{example}
%\begin{Verbatim}[curlyquotes]
%`quoted text'
%\end{Verbatim}
%\end{example}
%
%
% \item[extra (boolean) (true)]
% Use \fvextra\ reimplementations of \fancyvrb\ commands and environments when available.  For example, use \fvextra's reimplemented \cmd{\Verb} that works (with a few limitations) inside other commands, rather than the original \fancyvrb\ implementation that essentially functions as \cmd{\texttt} inside other commands.
%
%
% \item[fontencoding (string) (\meta{document font encoding})]
% Set the font encoding inside \pkg{fancyvrb} commands and environments.  Setting |fontencoding=none| resets to the default document font encoding.
%
%
% \item[highlightcolor (string) (LightCyan)]
% Set the color used for |highlightlines|, using a predefined color name from \pkg{color} or \pkg{xcolor}, or a color defined via |\definecolor|.
%
%
% \item[highlightlines (string) (\meta{none})]
% This highlights a single line or a range of lines based on line numbers.  The line numbers refer to the line numbers that \fancyvrb\ would show if |numbers=left|, etc.  They do not refer to original or actual line numbers before adjustment by |firstnumber|.
%
% The highlighting color can be customized with |highlightcolor|.
%
% \begingroup
% \fvset{xleftmargin=2em}
%\begin{longexample}
%\begin{Verbatim}[numbers=left, highlightlines={1, 3-4}]
%First line
%Second line
%Third line
%Fourth line
%Fifth line
%\end{Verbatim}
%\end{longexample}
% \endgroup
%
% The actual highlighting is performed by a set of commands.  These may be customized for additional fine-tuning of highlighting.  See the default definition of |\FancyVerbHighlightLineFirst| as a starting point.
%
% \vspace{0.1in}
% $\bullet$ |\FancyVerbHighlightLineFirst|:  First line in a range. \\
% \indent $\bullet$ |\FancyVerbHighlightLineMiddle|:  Inner lines in a range. \\
% \indent $\bullet$ |\FancyVerbHighlightLineLast|:  Last line in a range. \\
% \indent $\bullet$ |\FancyVerbHighlightLineSingle|:  Single highlighted lines. \\
% \indent $\bullet$ |\FancyVerbHighlightLineNormal|:  Normal lines without highlighting. \\
%
% \vspace{-0.1in}
% \noindent If these are customized in such a way that indentation or inter-line spacing is changed, then |\FancyVerbHighlightLineNormal| may be modified as well to make all lines uniform.  When working with the |First|, |Last|, and |Single| commands, keep in mind that \fvextra\ merges all numbers ranges, so that |{1, 2-3, 3-5}| is treated the same as |{1-5}|.
%
% Highlighting is applied after |\FancyVerbFormatText|, so any text formatting defined via that command will work with highlighting.  Highlighting is applied before |\FancyVerbFormatLine|, so if |\FancyVerbFormatLine| puts a line in a box, the box will be behind whatever is created by highlighting.  This prevents highlighting from vanishing due to user-defined customization.
%
%
% \item[linenos (boolean) (false)]
% \fancyvrb\ allows line numbers via the options |numbers=|\meta{position}.  This is essentially an alias for |numbers=left|.  It primarily exists for better compatibility with the \pkg{minted} package.
%
%
% \item[mathescape (boolean) (false)]
% This causes everything between dollar signs |$...$| to be typeset as math.  The ampersand |&|, caret |^|, and underscore |_| have their normal math meanings.
%
% This is equivalent to
% \begin{Verbatim}[gobble=2]
% codes={\catcode`\$=3\catcode`\&=4\catcode`\^=7\catcode`\_=8}
% \end{Verbatim}
% |mathescape| is always applied \emph{before} |codes|, so that |codes| can be used to override some of these definitions.
%
% Note that \fvextra\ provides several patches that make math mode within verbatim as close to normal math mode as possible (\cref{sec:patch:math}).
%
%
% \item[numberfirstline (boolean) (false)]
% When line numbering is used with |stepnumber| $\ne 1$, the first line may not always be numbered, depending on the line number of the first line.  This causes the first line always to be numbered.
%
% \begingroup
% \fvset{xleftmargin=2em}
%\begin{longexample}
%\begin{Verbatim}[numbers=left, stepnumber=2,
%                 numberfirstline]
%First line
%Second line
%Third line
%Fourth line
%\end{Verbatim}
%\end{longexample}
% \endgroup
%
%
% \item[numbers (none \| left \| right \| both) (none)]
% \fvextra\ adds the |both| option for line numbering.
%
% \begingroup
% \fvset{xleftmargin=1.5em, xrightmargin=1.5em}
%\begin{example}
%\begin{Verbatim}[numbers=both]
%First line
%Second line
%Third line
%Fourth line
%\end{Verbatim}
%\end{example}
% \endgroup
%
%
% \item[retokenize (boolean) (false)]
% By default, \cmd{\UseVerb} inserts saved verbatim material with the catcodes (|commandchars|, |codes|, etc.\@) under which it was originally saved with \cmd{\SaveVerb}.  When |retokenize| is used, the saved verbatim material is retokenized under the settings in place at \cmd{\UseVerb}.
%
% This only applies to the reimplemented \cmd{\UseVerb}, when paired with the reimplemented \cmd{\SaveVerb}.  It may be extended to environments (\cmd{\UseVerbatim}, etc.\@) in the future, if the relevant commands and environments are reimplemented.
%
%
% \item[space (macro) ({\ttfamily\FancyVerbSpace})]
% Redefine the visible space character.  Note that this is only used if |showspaces=true|.  The color of the character may be set with |spacecolor|.
%
%
% \item[spacebreak (macro) (\Verb{\discretionary{}{}{}})]
% This determines the break that is inserted around spaces when |breaklines=true| and one or more of the following conditions applies: |breakcollapsespaces=false|, |showspaces=true|, or the space is affected by |breakbefore| or |breakafter|.  If it is redefined, it should typically be similar to |\FancyVerbBreakAnywhereBreak|, |\FancyVerbBreakBeforeBreak|, and |\FancyVerbBreakAfterBreak| to obtain consistent breaks.
%
%
% \item[spacecolor (string) (none)]
% Set the color of visible spaces.  By default (|none|), they take the color of their surroundings.
%
%\begin{longexample}
%\color{gray}
%\begin{Verbatim}[showspaces, spacecolor=red]
%One  two  three
%\end{Verbatim}
%\end{longexample}
%
%
% \item[stepnumberfromfirst (boolean) (false)]
% By default, when line numbering is used with |stepnumber| $\ne 1$, only line numbers that are a multiple of |stepnumber| are included.  This offsets the line numbering from the first line, so that the first line, and all lines separated from it by a multiple of |stepnumber|, are numbered.
%
% \begingroup
% \fvset{xleftmargin=2em}
%\begin{longexample}
%\begin{Verbatim}[numbers=left, stepnumber=2,
%                 stepnumberfromfirst]
%First line
%Second line
%Third line
%Fourth line
%\end{Verbatim}
%\end{longexample}
% \endgroup
%
%
% \item[stepnumberoffsetvalues (boolean) (false)]
% By default, when line numbering is used with |stepnumber| $\ne 1$, only line numbers that are a multiple of |stepnumber| are included.  Using |firstnumber| to offset the numbering will change which lines are numbered and which line gets which number, but will not change which \emph{numbers} appear.  This option causes |firstnumber| to be ignored in determining which line numbers are a multiple of |stepnumber|.  |firstnumber| is still used in calculating the actual numbers that appear.  As a result, the line numbers that appear will be a multiple of |stepnumber|, plus |firstnumber| minus 1.
%
% This option gives the original behavior of \fancyvrb\ when |firstnumber| is used with |stepnumber| $\ne 1$ (\cref{sec:modifications:line-numbering}).
%
% \begingroup
% \fvset{xleftmargin=2em}
%\begin{longexample}
%\begin{Verbatim}[numbers=left, stepnumber=2,
%                 firstnumber=4, stepnumberoffsetvalues]
%First line
%Second line
%Third line
%Fourth line
%\end{Verbatim}
%\end{longexample}
% \endgroup
%
%
% \item[tab (macro) ({\rmfamily\fancyvrb's} \string\FancyVerbTab, \FancyVerbTab)]
% Redefine the visible tab character.  Note that this is only used if |showtabs=true|.  The color of the character may be set with |tabcolor|.
%
% When redefining the tab, you should include the font family, font shape, and text color in the definition.  Otherwise these may be inherited from the surrounding text.  This is particularly important when using the tab with syntax highlighting, such as with the \pkg{minted} or \pkg{pythontex} packages.
%
% \fvextra\ patches \fancyvrb\ tab expansion so that variable-width symbols such as |\rightarrowfill| may be used as tabs.  For example,
%
% \begingroup
% \fvset{frame=single, rulecolor=DarkGreen, gobble=4}
% \begin{VerbatimVerbatim}[breaklines, obeytabs, showtabs]
%   \begin{Verbatim}[obeytabs, showtabs, breaklines,
%                    tab=\rightarrowfill, tabcolor=orange]
%   	First	Second	Third	And more text that goes on for a while until wrapping is needed
%   	First	Second	Third	Forth
%   \end{Verbatim}
% \end{VerbatimVerbatim}
%   \begin{Verbatim}[obeytabs, showtabs, breaklines,
%                    tab=\rightarrowfill, tabcolor=orange]
%   	First	Second	Third	And more text that goes on for a while until wrapping is needed
%   	First	Second	Third	Forth
%   \end{Verbatim}
% \endgroup
%
%
% \item[tabcolor (string) (none)]
% Set the color of visible tabs.  By default (|none|), they take the color of their surroundings.
%
%
% \item[vargsingleline (boolean) (false)]
% This determines whether \fvextra's |\Verb| and |\SaveVerb| take multi-line (but not multi-paragraph) verbatim arguments, or if they instead require arguments to be on a single line like the original \fancyvrb\ commands.
%
%
% \end{optionlist}
%
%
%
%
% \section{General commands}
%
% \subsection{Inline-only settings with \cmd{\fvinlineset}}
% \DescribeMacro{\fvinlineset\marg{options}}
%
% This is like \cmd{\fvset}, except that options only apply to commands that typeset inline verbatim, like \cmd{\Verb} and \cmd{\EscVerb}.  Settings from \cmd{\fvinlineset} override those from \cmd{\fvset}.
%
% Note that \cmd{\fvinlineset} only works with commands that are reimplemented, patched, or defined by \fvextra; it is not compatible with the original \fancyvrb\ definitions.
%
%
% \subsection{Custom formatting for inline commands like \cmd{\Verb} with \cmd{\FancyVerbFormatInline}}
%
% \DescribeMacro{\FancyVerbFormatInline}
%
% This can be used to apply custom formatting to inline verbatim text created with commands like \cmd{\Verb}.  It only works with commands that are reimplemented, patched, or defined by \fvextra; it is not compatible with the original \fancyvrb\ definitions.  The default definition does nothing; it is equivalent to |\newcommand{\FancyVerbFormatInline}[1]{#1}|.
%
% This is the inline equivalent of \cmd{\FancyVerbFormatLine} and \cmd{\FancyVerbFormatText}.  In the inline context, there is no need to distinguish between entire line formatting and only text formatting, so only \cmd{\FancyVerbFormatInline} exists.
%
%
% \subsection{Custom formatting for environments like \cmd{Verbatim} with \cmd{\FancyVerbFormatLine} and \cmd{\FancyVerbFormatText}}
%
% \DescribeMacro{\FancyVerbFormatLine}
% \DescribeMacro{\FancyVerbFormatText}
%
% \fancyvrb\ defines |\FancyVerbFormatLine|, which can be used to apply custom formatting to each individual line of text in environments like \cmd{Verbatim}.  By default, it takes a line as an argument and inserts it with no modification.  This is equivalent to |\newcommand{\FancyVerbFormatLine}[1]{#1}|.\footnote{The actual definition in \fancyvrb\ is |\def\FancyVerbFormatLine#1{\FV@ObeyTabs{#1}}|.  This is problematic because redefining the macro could easily eliminate |\FV@ObeyTabs|, which governs tab expansion.  \fvextra\ redefines the macro to |\def\FancyVerbFormatLine#1{#1}| and patches all parts of \fancyvrb\ that use |\FancyVerbFormatLine| so that |\FV@ObeyTabs| is explicitly inserted at the appropriate points.}
%
% \fvextra\ introduces line breaking, which complicates line formatting.  We might want to apply formatting to the entire line, including line breaks, line continuation symbols, and all indentation, including any extra indentation provided by line breaking.  Or we might want to apply formatting only to the actual text of the line.  \fvextra\ leaves |\FancyVerbFormatLine| as applying to the entire line, and introduces a new command |\FancyVerbFormatText| that only applies to the text part of the line.\footnote{When |breaklines=true|, each line is wrapped in a |\parbox|.  |\FancyVerbFormatLine| is outside the |\parbox|, and |\FancyVerbFormatText| is inside.}   By default, |\FancyVerbFormatText| inserts the text unmodified.  When it is customized, it should not use boxes that do not allow line breaks to avoid conflicts with line breaking code.
%
% \begingroup
% \fvset{xrightmargin=2em}
%\begin{longexample}
%\renewcommand{\FancyVerbFormatLine}[1]{%
%  \fcolorbox{DarkBlue}{LightGray}{#1}}
%\renewcommand{\FancyVerbFormatText}[1]{\textcolor{Green}{#1}}
%
%\begin{Verbatim}[breaklines]
%Some text that proceeds for a while and finally wraps onto another line
%Some more text
%\end{Verbatim}
%\end{longexample}
% \endgroup
%
%
%
%
% \section{Reimplemented commands}
% \label{sec:reimplemented-cmd}
%
% \fvextra\ reimplements parts of \fancyvrb.  These new implementations stay close to the original definitions while allowing for new features that otherwise would not be possible.  Reimplemented versions are used by default.  The original implementations may be used via |\fvset{extra=false}| or by using |extra=false| in the optional arguments to a command or environment.
%
% Reimplemented commands restrict the scope of catcode-related options compared to the original \fancyvrb\ versions.  This prevents catcode-related options from interfering with new features such as |\FancyVerbFormatInline|.  With \fvextra, the |codes| option should only be used for catcode modifications.  Including non-catcode commands in |codes| will typically have no effect, unlike with \fancyvrb.  If you want to customize verbatim content using general commands, consider |formatcom|.
%
% \subsection{\cmd{\Verb}}
% \DescribeMacro{\Verb*\oarg{options}\meta{delim~char~or~\{}\meta{text}\meta{delim~char~or~\}}}
%
% The new \cmd{\Verb} works as expected (with a few limitations) inside other commands.  It even works in movable arguments (for example, in \cmd{\section}), and is compatible with \pkg{hyperref} for generating PDF strings (for example, PDF bookmarks).  The \fancyvrb\ definition did work inside some other commands, but essentially functioned as \cmd{\texttt} in that context.
%
% By default, \cmd{\Verb} takes a multi-line (but not multi-paragraph) verbatim argument.  To restore the \fancyvrb\ behavior of requiring a single-line argument, set |vargsingleline=true|.
%
% \cmd{\Verb} is compatible with |breaklines| and the relevant line-breaking options.
%
% Like the original \fancyvrb\ implementation, the new \cmd{\Verb} can be starred (|\Verb*|) and accepts optional arguments.  While \fancyvrb's starred command |\Verb*| is a shortcut for |showspaces|, \fvextra's |\Verb*| is a shortcut for both |showspaces| and |showtabs|.  This is more similar to the current behavior of \LaTeX's \Verb{\verb*}, except that \Verb{\verb*} converts tabs into visible spaces instead of displaying them as visible tabs.
%
% \begin{description}
% \item[Delimiters]  A repeated character like normal \cmd{\verb}, or a pair of curly braces |{...}|.  If curly braces are used, then \meta{text} cannot contain unpaired curly braces.  Note that curly braces should be preferred when using \cmd{\Verb} inside other commands, and curly braces are \emph{required} when \cmd{\Verb} is in a movable argument, such as in a \cmd{\section}.  Non-ASCII characters now work as delimiters under pdfTeX with \pkg{inputenc} using UTF-8.\footnote{Under pdfTeX, non-ASCII code points are processed at the byte rather than code point level, so \cmd{\Verb} must treat a sequence of multiple bytes as the delimiter.}  For example, \Verb{\Verb§verb§} now works as expected.
% \item[Limitations inside other commands]  While the new \cmd{\Verb} does work inside arbitrary other commands, there are a few limitations.
%     \begin{itemize}
%     \item |#| and |%| cannot be used.  If you need them, consider \cmd{\EscVerb} or perhaps \cmd{\SaveVerb} plus \cmd{\UseVerb}.
%     \item Curly braces are only allowed in pairs.
%     \item Multiple adjacent spaces will be collapsed into a single space.
%     \item Be careful with backslashes.  A backslash that is followed by one or more ASCII letters will cause a following space to be lost, if the space is not immediately followed by an ASCII letter.  For example, |\Verb{\r \n}| becomes \texttt{\Verb{\r \n}}, but |\Verb{\r n}| becomes \texttt{\Verb{\r n}}.  Basically, anything that looks like a \LaTeX\ command (control word) will gobble following spaces, unless the next character after the spaces is an ASCII letter.
%     \item A single |^| is fine, but avoid |^^| because it will serve as an escape sequence for an ASCII command character.
%     \end{itemize}
% \item[Using in movable arguments]  \cmd{\Verb} works automatically in movable arguments, such as in a \cmd{\section}.  \cmd{\protect} or similar measures are not needed for \cmd{\Verb} itself, or for any of its arguments, and should not be used.  \cmd{\Verb} performs operations that amount to applying \cmd{\protect} to all of these automatically.
% \item[\pkg{hyperref} PDF strings] \cmd{\Verb} is compatible with \pkg{hyperref} for generating PDF strings such as PDF bookmarks.  Note that the PDF strings are \emph{always} a literal rendering of the verbatim text, with all \fancyvrb\ options ignored.  For example, things like |showspaces| and |commandchars| have no effect.  If you need options to be applied to obtain desired PDF strings, consider a custom approach, perhaps using \cmd{\texorpdfstring}.
% \item[Line breaking]  |breaklines| allows breaks at spaces.  |breakbefore|, |breakafter|, and |breakanywhere| function as expected, as do things like |breakaftersymbolpre| and |breakaftersymbolpost|.  Break options that are only applicable to block text like a |Verbatim| environment do not have any effect.  For example, |breakindent| and |breaksymbol| do nothing.
% \end{description}
%
%
% \subsection{\cmd{\SaveVerb}}
%
% \DescribeMacro{\SaveVerb\oarg{options}\marg{name}\meta{delim~char~or~\{}\meta{text}\meta{delim~char~or~\}}}
%
% \cmd{\SaveVerb} is reimplemented so that it is equivalent to the reimplemented \cmd{\Verb}.  Like the new \cmd{\Verb}, it accepts \meta{text} delimited by a pair of curly braces |{...}|.  It supports \cmd{\fvinlineset}.  It also adds support for the new |retokenize| option for \cmd{\UseVerb}.
%
% By default, \cmd{\SaveVerb} takes a multi-line (but not multi-paragraph) verbatim argument.  To restore the \fancyvrb\ behavior of requiring a single-line argument, set |vargsingleline=true|.
%
%
% \subsection{\cmd{\UseVerb}}
%
% \DescribeMacro{\UseVerb*\oarg{options}\marg{name}}
%
% \cmd{\UseVerb} is reimplemented so that it is equivalent to the reimplemented \cmd{\Verb}.  It supports \cmd{\fvinlineset} and |breaklines|.
%
% Like \cmd{\Verb}, \cmd{\UseVerb} is compatible with \pkg{hyperref} for generating PDF strings such as PDF bookmarks.  Note that the PDF strings are \emph{always} a literal rendering of the verbatim text, with all \fancyvrb\ options ignored.  For example, things like |showspaces| and |commandchars| have no effect.  The new option |retokenize| also has no effect.  If you need options to be applied to obtain desired PDF strings, consider a custom approach, perhaps using \cmd{\texorpdfstring}
%
% There is a new option |retokenize| for \cmd{\UseVerb}.  By default, \cmd{\UseVerb} inserts saved verbatim material with the catcodes (|commandchars|, |codes|, etc.\@) under which it was originally saved with \cmd{\SaveVerb}.  When |retokenize| is used, the saved verbatim material is retokenized under the settings in place at \cmd{\UseVerb}.
%
% For example, consider |\SaveVerb{save}{\textcolor{red}{#%}}|:
% \SaveVerb{save}{\textcolor{red}{#%}}
% \begin{itemize}
% \item |\UseVerb{save}| $\Rightarrow$ \UseVerb{save}
% \item |\UseVerb[commandchars=\\\{\}]{save}| $\Rightarrow$ \UseVerb[commandchars=\\\{\}]{save}
% \item |\UseVerb[retokenize, commandchars=\\\{\}]{save}| $\Rightarrow$ \UseVerb[retokenize, commandchars=\\\{\}]{save}
% \end{itemize}
%
%
%
%
%
% \section{New commands and environments}
% \label{sec:new-cmd-env}
%
% \subsection{\cmd{\EscVerb}}
% \DescribeMacro{\EscVerb*\oarg{options}\marg{backslash-escaped~text}}
%
% This is like \cmd{\Verb} but with backslash escapes to allow for characters such as |#| and |%|.  For example, |\EscVerb{\\Verb{\#\%}}| gives \EscVerb{\\Verb{\#\%}}.  It behaves exactly the same regardless of whether it is used inside another command.  Like the reimplemented \cmd{\Verb}, it works in movable arguments (for example, in \cmd{\section}), and is compatible with \pkg{hyperref} for generating PDF strings (for example, PDF bookmarks).
%
% \begin{description}
% \item[Delimiters] Text must \emph{always} be delimited with a pair of curly braces |{...}|.  This ensures that \cmd{\EscVerb} is always used in the same manner regardless of whether it is inside another command.
% \item[Escaping rules]\hfill
%     \begin{itemize}
%     \item Only printable, non-alphanumeric ASCII characters (symbols, punctuation) can be escaped with backslashes.\footnote{Allowing backslash escapes of letters would lead to ambiguity regarding spaces; see \cmd{\Verb}.}
%     \item Always escape these characters:  |\|, |%|, |#|.
%     \item Escape spaces when there are more than one in a row.
%     \item Escape |^| if there are more than one in a row.
%     \item Escape unpaired curly braces.
%     \item Additional symbols or punctuation characters may require escaping if they are made \cmd{\active}, depending on their definitions.
%     \end{itemize}
% \item[Using in movable arguments]  \cmd{\EscVerb} works automatically in movable arguments, such as in a \cmd{\section}.  \cmd{\protect} or similar measures are not needed for \cmd{\EscVerb} itself, or for any of its arguments, and should not be used.  \cmd{\EscVerb} performs operations that amount to applying \cmd{\protect} to all of these automatically.
% \item[\pkg{hyperref} PDF strings] \cmd{\EscVerb} is compatible with \pkg{hyperref} for generating PDF strings such as PDF bookmarks.  Note that the PDF strings are \emph{always} a literal rendering of the verbatim text after backslash escapes have been applied, with all \fancyvrb\ options ignored.  For example, things like |showspaces| and |commandchars| have no effect.  If you need options to be applied to obtain desired PDF strings, consider a custom approach, perhaps using \cmd{\texorpdfstring}.
% \end{description}
%
%
% \subsection{\cmd{VerbEnv}}
% \DescribeMacro{\begin\{VerbEnv\}\oarg{options}\\$\langle$\textit{single line}$\rangle$\\\cmd{\end{VerbEnv}}}
%
% This is an environment variant of \cmd{\Verb}.  The environment must contain only a single line of text, and the closing \cmd{\end{VerbEnv}} must be on a line by itself.  The $\langle$\textit{options}$\rangle$ and $\langle$\textit{single line}$\rangle$ are read and then passed on to \cmd{\Verb} internally for actual typesetting.
%
% While \cmd{VerbEnv} can be used by document authors, it is primarily intended for package creators.  For example, it is used in \pkg{minted} to implement \cmd{\mintinline}.  In that case, highlighted code is always generated within a \cmd{Verbatim} environment.  It is possible to process this as inline rather than block verbatim by \cmd{\let}ting \cmd{\Verbatim} to \cmd{\VerbEnv}.
%
%\begin{example}
%BEFORE\begin{VerbEnv}
%_inline_
%\end{VerbEnv}
%AFTER
%\end{example}
%
% \cmd{VerbEnv} is not implemented using the typical \fancyvrb\ environment implementation style, so it is not compatible with |\RecustomVerbatimEnvironment|.
%
%
% \subsection{\cmd{VerbatimWrite}}
% \DescribeMacro{\begin\{VerbatimWrite\}\oarg{opt}\\$\langle$\textit{lines}$\rangle$\\\cmd{\end{VerbatimWrite}}}
%
% This writes environment contents verbatim to an external file.  It is similar to \fancyvrb's |VerbatimOut|, except that (1) it allows writing to a file multiple times (multiple environments can write to the same file) and (2) by default it uses |\detokenize| to guarantee truly verbatim output.
%
% By default, all \fancyvrb\ options except for |VerbatimWrite|-specific options are ignored.  This can be customized on a per-environment basis via environment optional arguments.
%
% ~
%
% \noindent Options defined specifically for \cmd{VerbatimWrite}:
%
% \begin{optionlist}
% \item[writefilehandle (file handle) (\meta{none})]
% File handle for writing.  For example,
% \begin{Verbatim}[gobble=2]
% \newwrite\myfile
% \immediate\openout\myfile=myfile.txt\relax
%
% \begin{VerbatimWrite}[writefilehandle=\myfile]
% ...
% \end{VerbatimWrite}
%
% \immediate\closeout\myfile
% \end{Verbatim}
%
% \item[writer (macro) (\cmd{\FancyVerbDefaultWriter})]
% This is the macro that processes each line of text in the environment and then writes it to file.  This is the default implementation:
% \begin{Verbatim}[gobble=2]
% \def\FancyVerbDefaultWriter#1{%
%   \immediate\write\FancyVerbWriteFileHandle{\detokenize{#1}}}
% \end{Verbatim}
% \end{optionlist}
%
%
%
% \subsection{Buffers}
%
% \subsubsection{\cmd{VerbatimBuffer}}
% \DescribeMacro{\begin\{VerbatimBuffer\}\oarg{opt}\\$\langle$\textit{lines}$\rangle$\\\cmd{\end{VerbatimBuffer}}}
%
% This environment stores its contents verbatim in a ``buffer,'' a sequence of numbered macros each of which contains one line of the environment.  The ``buffered'' lines can then be iterated  over for further processing or later use.  This is similar to  \fancyvrb's |SaveVerbatim|, which saves an environment for later use.  |VerbatimBuffer| offers additional flexibility by capturing truly verbatim environment contents using |\detokenize| and saving environment contents in a format designed for further processing.
%
% By default, all \fancyvrb\ options except for |VerbatimBuffer|-specific options are ignored.  This can be customized on a per-environment basis via environment optional arguments.
%
% Below is an extended example that demonstrates what is possible with |VerbatimBuffer| combined with various buffer commands.  This uses |\ifstrequal| from the \pkg{etoolbox} package.
% \begin{itemize}
% \item |\setformatter| defines an empty |\formatter| macro.  Then it defines a |\lineprocessor| macro that takes a buffer line as an argument.  If this line contains only the text ``red'', then |\lineprocessor| redefines |\formatter| to |\color{red}| and invokes |\IterateBufferBreak| to stop iteration over the buffer.  Finally, |\IterateBuffer| is used to apply |\lineprocessor| to each line in the buffer, until the final line is reached or |\IterateBufferBreak| is invoked.
% \item |afterbuffer| involves two steps:  (1) |\setformatter| loops through the buffer and defines |\formatter| based on the buffer contents, and (2) |\VerbatimInsertBuffer| typesets the buffer, using |formatcom=\formatter| to format the text based on whether any line contains only the text ``red''.
% \end{itemize}
%
%\begin{tcbexample}
%\def\setformatter{%
%  \def\formatter{}%
%  \def\lineprocessor##1{%
%    \ifstrequal{##1}{red}{\def\formatter{\color{red}}\IterateBufferBreak}{}}%
%  \IterateBuffer{\lineprocessor}}
%
%\begin{VerbatimBuffer}[
%  afterbuffer={\setformatter\VerbatimInsertBuffer[formatcom=\formatter]}
%]
%first
%second
%red
%\end{VerbatimBuffer}
%\end{tcbexample}
%
% Here is the same example, but rewritten to use a global buffer with custom buffer name instead.
%
%\begin{tcbexample}
%\begin{VerbatimBuffer}[globalbuffer, buffername=exbuff]
%first
%second
%red
%\end{VerbatimBuffer}
%
%\def\formatter{}
%\def\lineprocessor#1{%
%  \ifstrequal{#1}{red}{\def\formatter{\color{red}}\IterateBufferBreak}{}}
%\IterateBuffer[buffername=exbuff]{\lineprocessor}
%
%\VerbatimInsertBuffer[buffername=exbuff, formatcom=\formatter]
%\end{tcbexample}
%
% ~
%
% \noindent Options defined specifically for \cmd{VerbatimBuffer}:
%
% \begin{optionlist}
% \item[afterbuffer (macro) (\meta{none})]
% Macro or macros invoked at the end of the environment, after all lines of the environment have been buffered.  This is outside the |\begingroup...\endgroup| that wraps verbatim processing, so \fancyvrb\ settings are no longer active.  However, the buffer line macros and the buffer length macro are still accessible even when |globalbuffer=false|.
%
% When |afterbuffer| is used to typeset the buffer, the typeset buffer may contain |VerbatimBuffer| or environments based on it.  Typically, nested buffering should be avoided for a given buffer; a different buffer should be used at each level of nesting.  Otherwise, for nested |VerbatimBuffer| environments, the buffer will contain the contents of the outermost |VerbatimBuffer| environment concatenated with the contents of nested environments.
%
% The current buffer depth is available in |\FancyVerbBufferDepth|.  This has a value of |0| outside of any |VerbatimBuffer| environments, a value of |1| within the outermost |VerbatimBuffer| environment, and so forth.  This can be used to automatically generate a unique |buffername| at a given nesting depth.
%
% \item[bufferer (macro) (\Verb{\FancyVerbDefaultBufferer})]
% This is the macro that adds lines to the buffer.  The default is designed to create a truly verbatim buffer via |\detokenize|.  This can be customized if you wish to use \fancyvrb\ options related to catcodes to create a buffer that is only partially verbatim (that contains macros).
% \begin{Verbatim}[gobble=2, fontsize=\small]
% \def\FancyVerbDefaultBufferer#1{%
%   \expandafter\xdef\csname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname{%
%     \detokenize{#1}}}
% \end{Verbatim}
% A custom |bufferer| must take a single argument |#1| (a line of the environment text) and ultimately store the processed line in a macro called
% \begin{Verbatim}[gobble=2]
% \csname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname
% \end{Verbatim}
% This macro must be defined globally, so |\xdef| or |\gdef| is necessary (this does not interfere with scoping from |globalbuffer|).  Otherwise, there are no restrictions.  The |\xdef| and |\detokenize| in the default definition guarantee that the buffer consists only of the literal text from the environment, but this is not required for a custom |bufferer|.
%
% \item[bufferlengthname (string) (FancyVerbBufferLength)]
% Name of the macro storing the length of the buffer.  This is the number of lines stored.
%
% Macros that operate within a |VerbatimBuffer| environment can access the current value of |bufferlengthname| via |\FancyVerbBufferLengthName|.
%
% \item[bufferlinename (string) (FancyVerbBufferLine)]
% The base name of the buffer line macros.  The default is |FancyVerbBufferLine|, which will result in buffer macros |\FancyVerbBufferLine<n>| with integer |n| greater than or equal to one and less than or equal to the number of lines (one-based indexing).  Since buffer macro names contain a number, they must be accessed differently than typical macros:
% \begin{Verbatim}[gobble=2]
% \csname FancyVerbBufferLine<n>\endcsname
% \@nameuse{FancyVerbBufferLine<n>}
% \end{Verbatim}
% If the buffer macros are looped over with a counter that is incremented, then |<n>| should be the counter value |\arabic{<counter>}|.
%
% Macros that operate within a |VerbatimBuffer| environment can access the current value of |bufferlinename| via |\FancyVerbBufferLineName|.
%
% \item[buffername (string) (\meta{none})]
% Shortcut for setting |bufferlengthname| and |bufferlinename| simultaneously, using the same root name.  This sets |bufferlengthname| to |<buffername>length| and |bufferlinename| to |<buffername>line|.
%
% \item[globalbuffer (bool) (false)]
% This determines whether buffer line macros are defined globally, that is, whether they are accessible after the end of the |VerbatimBuffer| environment.  If the line macros are defined globally, then the buffer length macro is also increased appropriately outside the environment.  |globalbuffer| does not affect any |afterbuffer| macro, since that is invoked inside the environment.
%
% When buffered lines are used immediately, consider using |afterbuffer| instead of |globalbuffer|.  When buffered lines must be used later in a document, consider using |globalbuffer| with custom (and perhaps unique) |bufferlinename| and |bufferlengthname|.
%
% When |globalbuffer=true|, |VerbatimBuffer| environments with the same buffer name will append to a single buffer, so that it ultimately contains the concatenated contents of all environments.  A |VerbatimBuffer| environment with |globalbuffer=false| will append to the buffer created by any previous |VerbatimBuffer| that had |globalbuffer=true| and shared the same buffer name.  Any |afterbuffer| macro will have access to a buffer containing the concatenated data.  At the very end of the environment with |globalbuffer=false|, after any |afterbuffer|, this appended content will be removed.  All buffer line macros (from |bufferlinename|) that were created by that environment are ``deleted'' (|\let| to an undefined macro), and the buffer length macro (from |bufferlengthname|) is reduced proportionally.
% \end{optionlist}
%
%
% \subsubsection{\cmd{\VerbatimInsertBuffer}}
% \DescribeMacro{\VerbatimInsertBuffer\oarg{options}}
%
% This inserts an existing buffer created by |VerbatimBuffer| as a verbatim environment.  The |Verbatim| environment is used by default, but this can be customized by setting |insertenvname|.  |\VerbatimInsertBuffer| modifies |Verbatim| and |BVerbatim| internals to function with a buffer in a command context.  See the |VerbatimBuffer| documentation for an example of usage.
%
% Options related to catcodes cause the buffer to be retokenized during typesetting.  That is, the \fancyvrb\ options used for |\VerbatimInsertBuffer| are not restricted by those that were in effect when |VerbatimBuffer| originally created the buffer, so long as the buffer contains a complete representation of the original |VerbatimBuffer| environment contents.
%
% |\VerbatimInsertBuffer| is not implemented using the typical \fancyvrb\ command and environment implementation styles, so it is not compatible with |\RecustomVerbatimCommand| or |\RecustomVerbatimEnvironment|.
%
% ~\par
% \noindent Options defined specifically for \cmd{\VerbatimInsertBuffer}:
%
% \begin{optionlist}
% \item[insertenvname (string) (Verbatim)]
% This is the name of the verbatim environment used for inserting the buffer.  |insertenvname| can be any |Verbatim|- or |BVerbatim|-based environment.  Environments defined with |\CustomVerbatimEnvironment| and |\RecustomVerbatimEnvironment| are supported.  User-implemented environments that serve as wrappers around |Verbatim| or |BVerbatim| should typically be compatible so long as they accept \pkg{fancyvrb}/\pkg{fvextra} optional arguments in the same way as |Verbatim| and |BVerbatim|.
% \end{optionlist}
%
%
% \subsubsection{\cmd{\VerbatimClearBuffer}}
% \DescribeMacro{\VerbatimClearBuffer\oarg{options}}
%
% Clear an existing buffer created with \cmd{VerbatimBuffer}.  |\global\let| all buffer line macros to an undefined macro and set the buffer length macro to zero.
%
%
% \subsubsection{\cmd{\InsertBuffer}}
% \DescribeMacro{\InsertBuffer\oarg{options}}
% This inserts an existing buffer created with |VerbatimBuffer| so that it is interpreted as \LaTeX.  The result is essentially the same as if the buffered text had been included literally at the insertion point.  The buffer is processed with |\scantokens|.
%
% For typesetting verbatim text, |\InsertBuffer| with the |wrapperenv| option set to a verbatim environment can be used as an alternative to |\VerbatimInsertBuffer|.  Both typically have similar performance.
%
% \begin{optionlist}
% \item[wrapperenvname (string) (\meta{none})]
% Name of environment used to wrap the buffer.  This is inserted within the |\scantokens| that is used to process the buffer, so if |wrapperenvname| is set to a verbatim environment, then it will cause the buffer to be typeset verbatim.  This is useful for non-\pkg{fancyvrb} verbatim environments that are not supported by |\VerbatimInsertBuffer|.
%
% \item[wrapperenvopt (string) (\meta{none})]
% Optional argument |[|\meta{opt}|]| passed to wrapper environment |wrapperenvname|.
%
% \item[wrapperenvarg (string) (\meta{none})]
% Mandatory argument |{|\meta{arg}|}| passed to wrapper environment |wrapperenvname|.
% \end{optionlist}
%
%\begin{tcblisting}{oversize=5em}
%\begin{VerbatimBuffer}[buffername=ins, globalbuffer]
%Text.  Math $f(x)$.  Verb \Verb|~#\{}|.
%\begin{Verbatim}
%Verbatim.  ~#\{}.
%\end{Verbatim}
%More text.
%\end{VerbatimBuffer}
%
%\textbf{BEFORE}\InsertBuffer[buffername=ins]\textbf{AFTER}
%\end{tcblisting}
%
%
% \subsubsection{\cmd{\ClearBuffer}}
% \DescribeMacro{\ClearBuffer\oarg{options}}
% Alias for \cmd{\VerbatimClearBuffer}.
%
%
% \subsubsection{\cmd{\BufferMdfivesum}}
% \DescribeMacro{\BufferMdfivesum}
% Calculate the MD5 sum of the current buffer, using |\pdf@mdfivesum| from \pkg{pdftexcmds}.
%
% |\BufferMdfivesum| operates on the current buffer.  Because it is fully expandable, it cannot take an optional argument to switch buffers.  To switch buffers, use something like |\fvset{buffername=...}| before |\BufferMdfivesum|.
%
%\begin{tcblisting}{oversize=5em}
%\begin{VerbatimBuffer}[afterbuffer=\xdef\bufferhash{\BufferMdfivesum}]
%Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
%eiusmod tempor incididunt ut labore et dolore magna aliqua.
%\end{VerbatimBuffer}
%
%\texttt{\bufferhash}
%\end{tcblisting}
%
%
% \subsubsection{\cmd{\IterateBuffer}}
% \DescribeMacro{\IterateBuffer\oarg{options}\marg{macro}}
%
% \noindent Iterate over buffer from beginning to end, invoking \meta{macro} on each line.  \meta{macro} must be a macro or sequence of macros that consumes a single brace-delimited argument, which is the current line in the buffer.  |\IterateBufferBreak| is available to break iteration immediately after the current \meta{macro} invocation completes.  During iteration, |\FancyVerbBufferLengthName|, |\FancyVerbBufferLineName|, and |\FancyVerbBufferIndex| can be used to access the name of the current buffer and index within it.
%
%
% \subsubsection{\cmd{\WriteBuffer}}
% \DescribeMacro{\WriteBuffer\oarg{options}}
% This writes the current buffer to an external file, using the |writefilehandle| and |writer| options from |VerbatimWrite|.  It is the buffer equivalent of |VerbatimWrite|.
%
%
%
%
% \section{Line breaking}
% \label{sec:breaklines}
%
% Automatic line breaking may be turned on with |breaklines=true|.  By default, breaks only occur at spaces.  Breaks may be allowed anywhere with |breakanywhere|, or only before or after specified characters with |breakbefore| and |breakafter|.  Many options are provided for customizing breaks.  A good place to start is the description of |breaklines|.
%
% When a line is broken, the result must fit on a single page.  There is no support for breaking a line across multiple pages.
%
%
% \subsection{Line breaking options}
%
% Options are provided for customizing typical line breaking features.  See \cref{sec:breaklines:advanced} for details about low-level customization of break behavior.
%
% \begin{optionlist}
%
% \item[breakafter (string) (\meta{none})]
% Break lines after specified characters, not just at spaces, when |breaklines=true|.  For example, |breakafter=-/| would allow breaks after any hyphens or slashes.  Special characters given to |breakafter| should be backslash-escaped (usually |#|, |{|, |}|, |%|, |[|, |]|, and the comma |,|; the backslash |\| may be obtained via |\\| and the space via |\space|).\footnote{|breakafter| expands each token it is given once, so when it is given a macro like |\%|, the macro should expand to a literal character that will appear in the text to be typeset.  \fvextra\ defines special character escapes that are activated for |breakafter| so that this will work with common escapes.  The only exception to token expansion is non-ASCII characters under pdfTeX; these should appear literally.  |breakafter| is not catcode-sensitive.}
%
% For an alternative, see |breakbefore|.  When |breakbefore| and |breakafter| are used for the same character, |breakbeforeinrun| and |breakafterinrun| must both have the same setting.
%
% Note that when |commandchars| or |codes| are used to include macros within verbatim content, breaks will not occur within mandatory macro arguments by default.  Depending on settings, macros that take optional arguments may not work unless the entire macro including arguments is wrapped in a group (curly braces |{}|, or other characters specified with |commandchars|).  See \cref{sec:breaklines:advanced} for details, and consider |breaknonspaceingroup| as a solution in simple cases.
%
%\begin{longexample}
%\begin{Verbatim}[breaklines, breakafter=d]
%some_string = 'SomeTextThatGoesOnAndOnForSoLongThatItCouldNeverFitOnOneLine'
%\end{Verbatim}
%\end{longexample}
%
%
% \item[breakafterinrun (boolean) (false)]
% When |breakafter| is used, insert breaks within runs of identical characters.  If |false|, treat sequences of identical characters as a unit that cannot contain breaks.  When |breakbefore| and |breakafter| are used for the same character, |breakbeforeinrun| and |breakafterinrun| must both have the same setting.
%
%
% \item[breakaftersymbolpre (string) (\string\,\string\footnotesize\string\ensuremath\{\_\string\rfloor\}, \,\footnotesize\ensuremath{_\rfloor})]
% The symbol inserted pre-break for breaks inserted by |breakafter|.  This does not apply to breaks inserted next to spaces; see |spacebreak|.
%
%
% \item[breakaftersymbolpost (string) (\meta{none})]
% The symbol inserted post-break for breaks inserted by |breakafter|.  This does not apply to breaks inserted next to spaces; see |spacebreak|.
%
%
% \item[breakanywhere (boolean) (false)]
% Break lines anywhere, not just at spaces, when |breaklines=true|.
%
% Note that when |commandchars| or |codes| are used to include macros within verbatim content, breaks will not occur within mandatory macro arguments by default.  Depending on settings, macros that take optional arguments may not work unless the entire macro including arguments is wrapped in a group (curly braces |{}|, or other characters specified with |commandchars|).  See \cref{sec:breaklines:advanced} for details, and consider |breaknonspaceingroup| as a solution in simple cases.
%
%\begin{longexample}
%\begin{Verbatim}[breaklines, breakanywhere]
%some_string = 'SomeTextThatGoesOnAndOnForSoLongThatItCouldNeverFitOnOneLine'
%\end{Verbatim}
%\end{longexample}
%
%
% \item[breakanywheresymbolpre (string) (\string\,\string\footnotesize\string\ensuremath\{\_\string\rfloor\}, \,\footnotesize\ensuremath{_\rfloor})]
% The symbol inserted pre-break for breaks inserted by |breakanywhere|.  This does not apply to breaks inserted next to spaces; see |spacebreak|.
%
%
% \item[breakanywhereinlinestretch (length) (\meta{none})]
% Stretch glue to insert at potential |breakanywhere| break locations in inline contexts, to give better line widths and avoid overfull |\hbox|.  This allows the spacing between adjacent non-space characters to stretch, so it should not be used when column alignment is important.  For typical line lengths, values between |0.01em| and |0.02em| should be sufficient to provide a cumulative stretch per line that is equal to or greater than the width of one character.
%
% This is typically not needed in cases where an overfull |\hbox| only overflows by tiny amount, perhaps a fraction of a pt.  In those cases, the overfull |\hbox| could be ignored, |\hfuzz| could be set to 1pt or 2pt to suppress tiny overfull |\hbox| warnings, or |breakanywheresymbolpre| might be redefined to adjust spacing.
%
% Implementation:  Before each |breakanywhere| break location, this inserts the following sequence of macros:
%\begin{verbatim}
%\nobreak\hspace{0pt plus \FV@breaknonspaceinlinestretch}
%\end{verbatim}
%
%
% \item[breakanywheresymbolpost (string) (\meta{none})]
% The symbol inserted post-break for breaks inserted by |breakanywhere|.  This does not apply to breaks inserted next to spaces; see |spacebreak|.
%
%
% \item[breakautoindent (boolean) (true)]
% When a line is broken, automatically indent the continuation lines to the indentation level of the first line.  When |breakautoindent| and |breakindent| are used together, the indentations add.  This  indentation is combined with |breaksymbolindentleft| to give the total actual left indentation.
%
%
% \item[breakbefore (string) (\meta{none})]
% Break lines before specified characters, not just at spaces, when |breaklines=true|.  For example, |breakbefore=A| would allow breaks before capital A's.  Special characters given to |breakbefore| should be backslash-escaped (usually |#|, |{|, |}|, |%|, |[|, |]|, and the comma |,|; the backslash |\| may be obtained via |\\| and the space via |\space|).\footnote{|breakbefore| expands each token it is given once, so when it is given a macro like |\%|, the macro should expand to a literal character that will appear in the text to be typeset.  \fvextra\ defines special character escapes that are activated for |breakbefore| so that this will work with common escapes.  The only exception to token expansion is non-ASCII characters under pdfTeX; these should appear literally.  |breakbefore| is not catcode-sensitive.}
%
% For an alternative, see |breakafter|.  When |breakbefore| and |breakafter| are used for the same character, |breakbeforeinrun| and |breakafterinrun| must both have the same setting.
%
% Note that when |commandchars| or |codes| are used to include macros within verbatim content, breaks will not occur within mandatory macro arguments by default.  Depending on settings, macros that take optional arguments may not work unless the entire macro including arguments is wrapped in a group (curly braces |{}|, or other characters specified with |commandchars|).  See \cref{sec:breaklines:advanced} for details, and consider |breaknonspaceingroup| as a solution in simple cases.
%
%\begin{longexample}
%\begin{Verbatim}[breaklines, breakbefore=A]
%some_string = 'SomeTextThatGoesOnAndOnForSoLongThatItCouldNeverFitOnOneLine'
%\end{Verbatim}
%\end{longexample}
%
%
% \item[breakbeforeinrun (boolean) (false)]
% When |breakbefore| is used, insert breaks within runs of identical characters.  If |false|, treat sequences of identical characters as a unit that cannot contain breaks.  When |breakbefore| and |breakafter| are used for the same character, |breakbeforeinrun| and |breakafterinrun| must both have the same setting.
%
%
% \item[breakbeforesymbolpre (string) (\string\,\string\footnotesize\string\ensuremath\{\_\string\rfloor\}, \,\footnotesize\ensuremath{_\rfloor})]
% The symbol inserted pre-break for breaks inserted by |breakbefore|.  This does not apply to breaks inserted next to spaces; see |spacebreak|.
%
%
% \item[breakbeforesymbolpost (string) (\meta{none})]
% The symbol inserted post-break for breaks inserted by |breakbefore|.  This does not apply to breaks inserted next to spaces; see |spacebreak|.
%
%
% \item[breakcollapsespaces (bool) (true)]
% When \Verb{true} (default), a line break within a run of regular spaces (\Verb{showspaces=false}) replaces all spaces with a single break, and the wrapped line after the break starts with a non-space character.  When \Verb{false}, a line break within a run of regular spaces preserves all spaces, and the wrapped line after the break may start with one or more spaces.  This causes regular spaces to behave exactly like the visible spaces produced with \Verb{showspaces}; both give identical line breaks, with the only difference being the appearance of spaces.
%
%
% \item[breakindent (dimension) (\meta{breakindentnchars})]
% When a line is broken, indent the continuation lines by this amount.  When |breakautoindent| and |breakindent| are used together, the indentations add.  This  indentation is combined with |breaksymbolindentleft| to give the total actual left indentation.
%
% \item[breakindentnchars (integer) (0)]
% This allows |breakindent| to be specified as an integer number of characters rather than as a dimension (assumes a fixed-width font).
%
%
% \item[breaklines (boolean) (false)]
% Automatically break long lines.
%
% \textbf{Limitations for verbatim environments/block text}, such as |Verbatim|:  When a line is broken, the result must fit on a single page.  There is no support for breaking a line across multiple pages.\footnote{Following the implementation in \pkg{fancyvrb}, each line is typeset within an |\hbox|, so page breaks are not possible.}
%
% \textbf{Limitations for verbatim commands/inline text}, such as |\Verb|:  When a line break is inserted, the text may still overflow into the margin or cause an overfull |\hbox|, depending on hyphenation settings and various penalties related to line breaks.  It may be possible to avoid this by allowing additional break locations with |breakbefore|, |breakafter|, or |breakanywhere|.  Small overfull |\hbox| warnings can be suppressed by setting |\hfuzz| to a larger value, for example setting it to |2pt| instead of the default |0.1pt|.  It is also possible to combine |breakanywhere| with |breakanywhereinlinestretch| to allow flexible spacing between adjacent non-space characters.  In cases where it is better to break before the margin rather than overflowing into the margin, consider setting |\emergencystretch|.
%
% By default, automatic breaks occur at spaces (even when |showspaces=true|).  Use |breakanywhere| to enable breaking anywhere; use |breakbefore| and |breakafter| for more fine-tuned breaking.
%
%\begin{example}
%...text.
%\begin{Verbatim}[breaklines]
%def f(x):
%    return 'Some text ' + str(x)
%\end{Verbatim}
%\end{example}
%
% To customize the indentation of broken lines, see |breakindent| and |breakautoindent|.  To customize the line continuation symbols, use |breaksymbolleft| and |breaksymbolright|.  To customize the separation between the continuation symbols and the text, use |breaksymbolsepleft| and |breaksymbolsepright|.  To customize the extra indentation that is supplied to make room for the break symbols, use |breaksymbolindentleft| and |breaksymbolindentright|.  Since only the left-hand symbol is used by default, it may also be modified using the alias options |breaksymbol|, |breaksymbolsep|, and |breaksymbolindent|.
%
% An example using these options to customize the |Verbatim| environment is shown below.  This uses the |\carriagereturn| symbol from the \pkg{dingbat} package.
%
% \begingroup
% \fvset{breaklines, xleftmargin=1em, xrightmargin=1em}
%\begin{longexample}
%\begin{Verbatim}[breaklines,
%                 breakautoindent=false,
%                 breaksymbolleft=\raisebox{0.8ex}{
%                   \small\reflectbox{\carriagereturn}},
%                 breaksymbolindentleft=0pt,
%                 breaksymbolsepleft=0pt,
%                 breaksymbolright=\small\carriagereturn,
%                 breaksymbolindentright=0pt,
%                 breaksymbolsepright=0pt]
%def f(x):
%    return 'Some text ' + str(x) + ' some more text ' + str(x) + ' even more text that goes on for a while'
%\end{Verbatim}
%\end{longexample}
% \endgroup
%
% Beginning in version 1.6, automatic line breaks work with |showspaces=true| by default.  Defining |breakbefore| or |breakafter| for |\space| is no longer necessary.  For example,
%
%\begin{longexample}
%\begin{Verbatim}[breaklines, showspaces]
%some_string = 'Some Text That Goes On And On For So Long That It Could Never Fit'
%\end{Verbatim}
%\end{longexample}
%
%
% \item[breaknonspaceingroup (boolean) (false)]
% By using |commandchars|, it is possible to include \LaTeX\ commands within otherwise verbatim text.  In these cases, there can be groups (typically |{...}| but depends on |commandchars|) within verbatim.  Spaces within groups are treated as potential line break locations when |breaklines=true|, but by default no other break locations are inserted (|breakbefore|, |breakafter|, |breakanywhere|).  This is because inserting non-space break locations can interfere with command functionality.  For example, in |\textcolor{red}{text}|, breaks shouldn't be inserted within |red|.
%
% |breaknonspaceingroup| allows non-space breaks to be inserted within groups.  This option should only be used when |commandchars| is including \LaTeX\ commands that do not take optional arguments and only take mandatory arguments that are typeset.  Something like |\textit{text}| is fine, but |\textcolor{red}{text}| is not because one of the mandatory arguments is not typeset but rather provides a setting.  For more complex commands, it is typically better to redefine them to insert breaks in appropriate locations using |\FancyVerbBreakStart...\FancyVerbBreakStop|.
%
%
% \item[breakpreferspaces (boolean) (true)]
% This determines whether line breaks are preferentially inserted at normal spaces (|breakcollapsespaces=true|, |showspaces=false|) rather than at other locations allowed by |breakbefore|, |breakafter|, or |breakanywhere|.
%
% Using |breakpreferspaces=false| with |breakanywhere=true| will typically result in all broken segments of a line going all the way to the right margin.
%
%
% \item[breaksymbol (string) (breaksymbolleft)]
% Alias for |breaksymbolleft|.
%
%
% \item[breaksymbolleft (string) (\string\tiny\string\ensuremath\{\string\hookrightarrow\}, {\tiny\ensuremath{\hookrightarrow}})]
% The symbol used at the beginning (left) of continuation lines when |breaklines=true|.  To have no symbol, simply set |breaksymbolleft| to an empty string (``|=,|'' or ``|={}|'').  The symbol is wrapped within curly braces |{}| when used, so there is no danger of formatting commands such as |\tiny| ``escaping.''
%
% The |\hookrightarrow| and |\hookleftarrow| may be further customized by the use of the |\rotatebox| command provided by \pkg{graphicx}.  Additional arrow-type symbols that may be useful are available in the \pkg{dingbat} (|\carriagereturn|) and \pkg{mnsymbol} (hook and curve arrows) packages, among others.
%
%
% \item[breaksymbolright (string) (\meta{none})]
% The symbol used at breaks (right) when |breaklines=true|. Does not appear at the end of the very last segment of a broken line.
%
%
% \item[breaksymbolindent (dimension) (\meta{breaksymbolindentleftnchars})]
% Alias for |breaksymbolindentleft|.
%
% \item[breaksymbolindentnchars (integer) (\meta{breaksymbolindentleftnchars})]
% Alias for |breaksymbolindentleftnchars|.
%
%
% \item[breaksymbolindentleft (dimension) (\meta{breaksymbolindentleftnchars})]
% The extra left indentation that is provided to make room for |breaksymbolleft|.  This indentation is only applied when there is a |breaksymbolleft|.
%
% \item[breaksymbolindentleftnchars (integer) (4)]
% This allows |breaksymbolindentleft| to be specified as an integer number of characters rather than as a dimension (assumes a fixed-width font).
%
% \item[breaksymbolindentright (dimension) (\meta{breaksymbolindentrightnchars})]
% The extra right indentation that is provided to make room for |breaksymbolright|.  This indentation is only applied when there is a |breaksymbolright|.
%
% \item[breaksymbolindentrightnchars (integer) (4)]
% This allows |breaksymbolindentright| to be specified as an integer number of characters rather than as a dimension (assumes a fixed-width font).
%
%
% \item[breaksymbolsep (dimension) (\meta{breaksymbolsepleftnchars})]
% Alias for |breaksymbolsepleft|.
%
% \item[breaksymbolsepnchars (integer) (\meta{breaksymbolsepleftnchars})]
% Alias for |breaksymbolsepleftnchars|.
%
%
% \item[breaksymbolsepleft (dimension) (\meta{breaksymbolsepleftnchars})]
% The separation between the |breaksymbolleft| and the adjacent text.
%
% \item[breaksymbolsepleftnchars (integer) (2)]
% Allows |breaksymbolsepleft| to be specified as an integer number of characters rather than as a dimension (assumes a fixed-width font).
%
% \item[breaksymbolsepright (dimension) (\meta{breaksymbolseprightnchars})]
% The \emph{minimum} separation between the |breaksymbolright| and the adjacent text.  This is the separation between |breaksymbolright| and the furthest extent to which adjacent text could reach.  In practice, |\linewidth| will typically not be an exact integer multiple of the character width (assuming a fixed-width font), so the actual separation between the |breaksymbolright| and adjacent text will generally be larger than |breaksymbolsepright|.  This ensures that break symbols have the same spacing from the margins on both left and right.  If the same spacing from text is desired instead, |breaksymbolsepright| may be adjusted.  (See the definition of |\FV@makeLineNumber| for implementation details.)
%
% \item[breaksymbolseprightnchars (integer) (2)]
% Allows |breaksymbolsepright| to be specified as an integer number of characters rather than as a dimension (assumes a fixed-width font).
%
%
% \item[spacebreak (macro) (\Verb{\discretionary{}{}{}})]
% This determines the break that is inserted around spaces when |breaklines=true| and one or more of the following conditions applies: |breakcollapsespaces=false|, |showspaces=true|, or the space is affected by |breakbefore| or |breakafter|.  If it is redefined, it should typically be similar to |\FancyVerbBreakAnywhereBreak|, |\FancyVerbBreakBeforeBreak|, and |\FancyVerbBreakAfterBreak| to obtain consistent breaks.
%
%
% \end{optionlist}
%
%
%
% \subsection{Line breaking and tab expansion}
%
% \fancyvrb\ provides an |obeytabs| option that expands tabs based on tab stops rather than replacing them with a fixed number of spaces (see \fancyvrb's |tabsize|).  The \fancyvrb\ implementation of tab expansion is not directly compatible with \fvextra's line-breaking algorithm, but \fvextra\ builds on the \fancyvrb\ approach to obtain identical results.
%
% Tab expansion in the context of line breaking does bring some additional considerations that should be kept in mind.  In each line, all tabs are expanded exactly as they would have been had the line not been broken.  This means that after a line break, any tabs will not align with tab stops unless the total left indentation of continuation lines is a multiple of the tab stop width.  The total indentation of continuation lines is the sum of |breakindent|, |breakautoindent|, and |breaksymbolindentleft| (alias |breaksymbolindent|).
%
% A sample |Verbatim| environment that uses |obeytabs| with |breaklines| is shown below, with numbers beneath the environment indicating tab stops (|tabsize=8| by default).  The tab stops in the wrapped and unwrapped lines are identical.  However, the continuation line does not match up with the tab stops because by default the width of |breaksymbolindentleft| is equal to four monospace characters.  (By default, |breakautoindent=true|, so the continuation line gets a tab plus |breaksymbolindentleft|.) \par~\par
%
% \def\tabnums{\texttt{\textcolor{LightGray}{1234567}\textcolor{Tomato}{8}}}
%
% \noindent\begin{minipage}{\textwidth}
% ~\par
% \hrule
% \begin{VerbatimVerbatim}[gobble=4, showtabs, breaklines, obeytabs]
%   \begin{Verbatim}[obeytabs, showtabs, breaklines]
%   	First	Second	Third	And more text that goes on for a while until wrapping is needed
%   	First	Second	Third	Forth
%   \end{Verbatim}
% \end{VerbatimVerbatim}
% \vspace{-0.1in}
% \noindent\tabnums\tabnums\tabnums\tabnums\tabnums\tabnums\tabnums\tabnums\par~\par
% \hrule~\\
% \end{minipage}
%
% We can set the symbol indentation to eight characters by creating a dimen,
%\begin{verbatim}
%\newdimen\temporarydimen
%\end{verbatim}
%setting its width to eight characters,
%\begin{verbatim}
%\settowidth{\temporarydimen}{\ttfamily AaAaAaAa}
%\end{verbatim}
% and finally adding the option |breaksymbolindentleft=\temporarydimen| to the |Verbatim| environment to obtain the following:\par~\par
%
% \newdimen\temporarydimen
% \settowidth{\temporarydimen}{\ttfamily AaAaAaAa}
% \noindent\begin{minipage}{\textwidth}
% ~\par
% \hrule
%   \begin{Verbatim}[obeytabs, showtabs, breaklines, breaksymbolindentleft=\temporarydimen, gobble=4]
%   	First	Second	Third	And more text that goes on for a while until wrapping is needed
%   	First	Second	Third	Forth
%   \end{Verbatim}
% \vspace{-0.1in}
% \noindent\tabnums\tabnums\tabnums\tabnums\tabnums\tabnums\tabnums\tabnums\par~\par
% \hrule~\\
% \end{minipage}
%
%
%
% \subsection{Advanced line breaking}
% \label{sec:breaklines:advanced}
%
% \subsubsection{A few notes on algorithms}
%
% |breakanywhere|, |breakbefore|, and |breakafter| work by scanning through the tokens in each line and inserting line breaking commands wherever a break should be allowed.  By default, they skip over all groups (|{...}|) and all math (|$...$|).  Note that this refers to curly braces and dollar signs with their normal \LaTeX\ meaning (catcodes), not verbatim curly braces and dollar signs; such non-verbatim content may be enabled with |commandchars| or |codes|.  This means that math and macros that only take mandatory arguments (|{...}|) will function normally within otherwise verbatim text.  However, macros that take optional arguments may not work because |[...]| is not treated specially, and thus break commands may be inserted within |[...]| depending on settings.  Wrapping an entire macro, including its arguments, in a group will protect the optional argument:  |{\|\meta{macro}|[|\meta{oarg}|]{|\meta{marg}|}}|.
%
% |breakbefore| and |breakafter| insert line breaking commands around specified characters.  This process is catcode-independent; tokens are |\detokenize|d before they are checked against characters specified via |breakbefore| and |breakafter|.
%
%
% \subsubsection{Breaks within macro arguments}
%
% \DescribeMacro{\FancyVerbBreakStart}
%
% \DescribeMacro{\FancyVerbBreakStop}
%
% When |commandchars| or |codes| are used to include macros within verbatim content, the options |breakanywhere|, |breakbefore|, and |breakafter| will not generate breaks within mandatory macro arguments.  Macros with optional arguments may not work, depending on settings, unless they are wrapped in a group (curly braces |{}|, or other characters specified via |commandchars|).
%
% If you want to allow breaks within macro arguments (optional or mandatory), then you should (re)define your macros so that the relevant arguments are wrapped in the commands
%\begin{verbatim}
%\FancyVerbBreakStart ... \FancyVerbBreakStop
%\end{verbatim}
% For example, suppose you have the macro
%\begin{verbatim}
%\newcommand{\mycmd}[1]{\_before:#1:after\_}
%\end{verbatim}
% Then you would discover that line breaking does not occur:
%
% \newcommand{\mycmd}[1]{\_before:#1:after\_}
%\begin{longexample}
%\begin{Verbatim}[commandchars=\\\{\}, breaklines, breakafter=a]
%\mycmd{1}\mycmd{2}\mycmd{3}\mycmd{4}\mycmd{5}
%\end{Verbatim}
%\end{longexample}
%
% Now redefine the macro:
%\begin{verbatim}
%\renewcommand{\mycmd}[1]{\FancyVerbBreakStart\_before:#1:after\_\FancyVerbBreakStop}
%\end{verbatim}
%
% This is the result:
%
% \renewcommand{\mycmd}[1]{\FancyVerbBreakStart\_before:#1:after\_\FancyVerbBreakStop}
%\begin{longexample}
%\begin{Verbatim}[commandchars=\\\{\}, breaklines, breakafter=a]
%\mycmd{1}\mycmd{2}\mycmd{3}\mycmd{4}\mycmd{5}
%\end{Verbatim}
%\end{longexample}
%
% Instead of completely redefining macros, it may be more convenient to use |\let|.  For example,
%\begin{verbatim}
%\let\originalmycmd\mycmd
%\renewcommand{\mycmd}[1]{%
%  \expandafter\FancyVerbBreakStart\originalmycmd{#1}\FancyVerbBreakStop}
%\end{verbatim}
% Notice that in this case |\expandafter| is required, because |\FancyVerbBreakStart| does not perform any expansion and thus will skip over |\originalmycmd{#1}| unless it is already expanded.  The \pkg{etoolbox} package provides commands that may be useful for patching macros to insert line breaks.
%
% When working with |\FancyVerbBreakStart ... \FancyVerbBreakStop|, keep in mind that any groups |{...}| or math |$...$| between the two commands will be skipped as far as line breaks are concerned, and breaks may be inserted within any optional arguments |[...]| depending on settings.  Inserting breaks within groups requires another level of |\FancyVerbBreakStart| and |\FancyVerbBreakStop|, and protecting optional arguments requires wrapping the entire macro in a group |{...}|.  Also, keep in mind that |\FancyVerbBreakStart| cannot introduce line breaks in a context in which they are never allowed, such as in an |\hbox|.
%
%
% \subsubsection{Customizing break behavior}
%
% \DescribeMacro{\FancyVerbBreakAnywhereBreak}
% \DescribeMacro{\FancyVerbBreakBeforeBreak}
% \DescribeMacro{\FancyVerbBreakAfterBreak}
%
% These macros govern the behavior of breaks introduced by |breakanywhere|, |breakbefore|, and |breakafter|.  These do not apply to breaks inserted next to spaces; see |spacebreak|.
%
% By default, these macros use |\discretionary|.  |\discretionary| takes three arguments:  commands to insert before the break, commands to insert after the break, and commands to insert if there is no break.  For example, the default definition of |\FancyVerbBreakAnywhereBreak|:
%
%\begin{verbatim}
%\newcommand{\FancyVerbBreakAnywhereBreak}{%
%  \discretionary{\FancyVerbBreakAnywhereSymbolPre}%
%   {\FancyVerbBreakAnywhereSymbolPost}{}}
%\end{verbatim}
% The other macros are equivalent, except that ``|Anywhere|'' is swapped for ``|Before|'' or ``|After|''.
%
% |\discretionary| will generally only insert breaks when breaking at spaces simply cannot make lines short enough (this may be tweaked to some extent with hyphenation settings).  This can produce a somewhat ragged appearance in some cases.  If you want breaks exactly at the margin (or as close as possible) regardless of whether a break at a space is an option, you may want to use |\allowbreak| instead.  Another option is |\linebreak[|\meta{n}|]|, where \meta{n} is between 0 to 4, with 0 allowing a break and 4 forcing a break.
%
%
%
%
% \section{Pygments support}
% \label{sec:pygments}
%
%
% \subsection{Options for users}
% \label{sec:pygments:users}
%
% \fvextra\ defines additional options for working code that has been highlighted with \href{pygments.org}{Pygments}.  These options work with the \pkg{minted} and \pkg{pythontex} packages, and may be enabled for other packages that work with Pygments output (\cref{sec:pygments:package-authors}).
%
%
% \begin{optionlist}
% \item[breakbytoken (boolean) (false)]
% When |breaklines=true|, do not allow breaks within \href{http://pygments.org/docs/tokens/}{Pygments tokens}.  This would prevent, for example, line breaking within strings.
%
% \item[breakbytokenanywhere (boolean) (false)]
% When |breaklines=true|, do not allow breaks within Pygments tokens, but always allow breaks between tokens even when they are immediately adjacent (not separated by spaces).  \textbf{This option should be used with care.}  Due to the details of how each Pygments lexer works, and due to the tokens defined in each lexer, this may result in breaks in locations that might not be anticipated.  Also keep in mind that this will not allow breaks between tokens if those tokens are actually ``subtokens'' within another token.
% \end{optionlist}
%
% \DescribeMacro{\FancyVerbBreakByTokenAnywhereBreak}
%
% This defines the break inserted when |breakbytokenanywhere=true|.  By default, it is |\allowbreak|.
%
%
% \subsection{For package authors}
% \label{sec:pygments:package-authors}
%
% By default, line breaking will only partially work with Pygments output; |breakbefore| and |breakafter| will not work with any characters that do not appear literally in Pygments output but rather are replaced with a character macro.  Also, |breakbytoken| and |breakbytokenanywhere| will not function at all.
%
% \DescribeMacro{\VerbatimPygments\marg{literal\_macro}\marg{actual\_macro}}
%
% To enable full Pygments support, use this macro before \verb|\begin{Verbatim}|, etc.  This macro must be used within |\begingroup...\endgroup| to prevent settings from escaping into the rest of the document.  It may be used safely at the beginning of a |\newenvironment| definition.  When used with |\newcommand|, though, the |\begingroup...\endgroup| will need to be inserted explicitly.
%
% \meta{literal\_macro} is the Pygments macro that literally appears in Pygments output; it corresponds to the Pygments |commandprefix|.  For \pkg{minted} and \pkg{pythontex}, this is |\PYG|.  \meta{actual\_macro} is the Pygments macro that should actually be used.  For \pkg{minted} this is |\PYG|; for \pkg{pythontex} this is |\PYG|\meta{style}.  In the \pkg{minted} and \pkg{pythontex} approach, code is only highlighted once (|\PYG|), and then the style is changed by redefining the macro that literally appears to use the appropriate style macro.
%
% |\VerbatimPygments| takes the two Pygments macros and redefines \meta{literal\_macro} so that it will invoke \meta{actual\_macro} while fully supporting line breaks, |breakbytoken|, and |breakbytokenanywhere|.  No further modification of either \meta{literal\_macro} or \meta{actual\_macro} is possible after |\VerbatimPygments| is used.
%
% In packages that do not make a distinction between \meta{literal\_macro} and \meta{actual\_macro}, simply use |\VerbatimPygments| with two identical arguments; |\VerbatimPygments| is defined to handle this case.
%
% |\VerbatimPygments| also improves other features of Pygments token macros, including improving support for Pygments options |escapeinside| and |texcomments|.  See the implementation for details.
%
%
%
%
% \section{Patches}
% \label{sec:patch}
%
% \fvextra\ modifies some \fancyvrb\ behavior that is the result of bugs or omissions.
%
% \subsection{Visible spaces}
% \label{sec:patch:visible-space}
%
% The command |\FancyVerbSpace| defines the visible space when |showspaces=true|.  The default \fancyvrb\ definition allows a font command to escape under some circumstances, so that all following text is forced to be teletype font.  The command is redefined following \url{https://tex.stackexchange.com/a/120231/10742}.
%
%
% \subsection{\texttt{obeytabs} with visible tabs and with tabs inside macro arguments}
%
% The original \fancyvrb\ treatment of visible tabs when |showtabs=true| and |obeytabs=true| did not allow variable-width tab symbols such as |\rightarrowfill| to function correctly.  This is fixed through a redefinition of |\FV@TrueTab|.
%
% Various macros associated with |obeytabs=true| are also redefined so that tabs may be expanded regardless of whether they are within a group (within |{...}| with the normal \LaTeX\ meaning due to |commandchars|, etc.).  In the \fancyvrb\ implementation, using |obeytabs=true| when a tab is inside a group typically causes the entire line to vanish.  \fvextra\ patches this so that the tab is expanded and will be visible if |showtabs=true|.  Note, though, that the tab expansion in these cases is only guaranteed to be correct for leading whitespace that is inside a group.  The start of each run of whitespace that is inside a group is treated as a tab stop, whether or not it actually is, due to limitations of the tab expansion algorithm.  A more detailed discussion is provided in the implementation.
%
% The example below shows correct tab expansion of leading whitespace within a macro argument.  With \fancyvrb, the line of text would simply vanish in this case.
%
% \begingroup
% \fvset{frame=single, rulecolor=DarkGreen, gobble=4}
% \begin{VerbatimVerbatim}[showtabs]
%   \begin{Verbatim}[obeytabs, showtabs, showspaces, tabsize=4,
%      commandchars=\\\{\}, tab=\textcolor{orange}{\rightarrowfill}]
%   \textcolor{blue}{ 		Text after 1 space + 2 tabs}
%   \end{Verbatim}
% \end{VerbatimVerbatim}
%
%   \begin{Verbatim}[obeytabs, showtabs, showspaces, tabsize=4,
%      commandchars=\\\{\}, tab=\textcolor{orange}{\rightarrowfill}]
%   \textcolor{blue}{ 		Text after 1 space + 2 tabs}
%   \end{Verbatim}
% \endgroup
%
% The next example shows that tab expansion inside macros in the midst of text typically does not match up with the correct tab stops, since in such circumstances the beginning of the run of whitespace must be treated as a tab stop.
%
% \begingroup
% \fvset{frame=single, rulecolor=DarkGreen, gobble=4, obeytabs}
% \begin{VerbatimVerbatim}[showtabs]
%   \begin{Verbatim}[obeytabs, showtabs, commandchars=\\\{\},
%                    tab=\textcolor{orange}{\rightarrowfill}]
%   \textcolor{blue}{		2 leading tabs}
%   \textcolor{blue}{Text		then 2 tabs}
%   \end{Verbatim}
% \end{VerbatimVerbatim}
%
%   \begin{Verbatim}[obeytabs, showtabs, commandchars=\\\{\},
%                    tab=\textcolor{orange}{\rightarrowfill}]
%   \textcolor{blue}{		2 leading tabs}
%   \textcolor{blue}{Text		then 2 tabs}
%   \end{Verbatim}
% \endgroup
%
%
% \subsection{Math mode}
% \label{sec:patch:math}
%
% \subsubsection{Spaces}
%
% When typeset math is included within verbatim material, \fancyvrb\ makes spaces within the math appear literally.
%
% \begingroup
% \makeatletter
% \let\FV@SetupMathActive\relax
% \let\FV@ApplyMathActive\relax
% \def\FV@SpaceCatTen{\ }
% \makeatother
%\begin{longexample}
%\begin{Verbatim}[commandchars=\\\{\}, mathescape]
%Verbatim $\displaystyle\frac{1}{  x^2    +    y^2  }$ verbatim
%\end{Verbatim}
%\end{longexample}
% \endgroup
%
% \fvextra\ patches this by redefining \fancyvrb's space character within math mode so that it behaves as expected:
%
%   \begin{Verbatim}[commandchars=\\\{\},
%                    codes={\catcode`$=3\catcode`^=7}, gobble=4]
%   Verbatim $\displaystyle\frac{1}{  x^2    +    y^2  }$ verbatim
%   \end{Verbatim}
%
%
% \subsubsection{Symbols and fonts}
%
% With \fancyvrb, ASCII symbols may give errors within math or may not appear as expected.  \fvextra\ redefines all ASCII symbols so that they will behave as literal characters or (if |\active| outside the verbatim context) as macros within math.  This behavior is overridden for specific characters by the |codes|, |commandchars|, and |mathescape| options.
%
% With \fancyvrb, using a single quotation mark (\texttt{\textquotesingle}) in typeset math within verbatim material results in an error rather than a prime symbol ($'$).\footnote{The single quotation mark is made active within verbatim material to prevent ligatures, via |\@noligs|.  The default definition is incompatible with math mode.}  \fvextra\ redefines the behavior of the single quotation mark within math mode to fix this, so that it will become a proper prime.
%
% The \pkg{amsmath} package provides a |\text| command for including normal text within math.  With \fancyvrb, |\text| does not behave normally when used in typeset math within verbatim material.  \fvextra\ redefines the backtick (\texttt{\textasciigrave}) and the single quotation mark so that they function normally within |\text|, becoming left and right quotation marks.  It redefines the greater-than sign, less-than sign, comma, and hyphen so that they function normally as well.  \fvextra\ also switches back to the default document font within |\text|, rather than using the verbatim font, which is typically a monospace or typewriter font.
%
% The result of these modifications is a math mode that very closely mimics the behavior of normal math mode outside of verbatim material.
%
%\begin{longexample}
%\begin{Verbatim}[commandchars=\\\{\}, mathescape]
%Verbatim $\displaystyle f'''(x) = \text{``Some quoted text---''}$
%\end{Verbatim}
%\end{longexample}
%
%
%
% \subsection{Orphaned labels}
%
% When |frame=lines| is used with a |label|, \fancyvrb\ does not prevent the label from being orphaned under some circumstances.  |\FV@BeginListFrame@Lines| is patched to prevent this.
%
%
%
% \subsection{\texttt{rulecolor} and \texttt{fillcolor}}
%
% The |rulecolor| and |fillcolor| options are redefined so that they accept color names directly, rather than requiring |\color{|\meta{color\_name}|}|.  The definitions still allow the old usage.
%
%
%
% \subsection{Command lookahead tokenization}
%
% \cmd{\FV@Command} is used internally by commands like \cmd{\Verb} to read stars (|*|) and optional arguments (|[...]|) before invoking the core of the command.  This is redefined so that lookahead tokenizes under a verbatim catcode regime.  The original definition could prevent commands like \cmd{\Verb} from using characters like |%| as delimiters, because the lookahead for a star and optional argument could read the |%| and give it its normal meaning of comment character.  The new definition fixes this, so that commands like \cmd{\Verb} behave as closely to \cmd{\verb} as possible.
%
%
%
%
% \section{Additional modifications to \fancyvrb}
% \label{sec:modifications}
%
% \fvextra\ modifies some \fancyvrb\ behavior with the intention of improving logical consistency or providing better defaults.
%
%
% \subsection{Backtick and single quotation mark}
%
% With \fancyvrb, the backtick \texttt{\textasciigrave} and typewriter single quotation mark \texttt{\textquotesingle} are typeset as the left and right curly single quotation marks \texttt{`'}.  \pkg{fvextra} loads the \pkg{upquote} package so that these characters will appear literally by default.  The original \fancyvrb\ behavior can be restored with the \fvextra\ option |curlyquotes| (\cref{sec:general-options}).
%
%
% \subsection{Line numbering}
% \label{sec:modifications:line-numbering}
%
% With \fancyvrb, using |firstnumber| to offset line numbering in conjunction with |stepnumber| changes which line numbers appear.  Lines are numbered if their original line numbers, without the |firstnumber| offset, are a multiple of |stepnumber|.  But the actual numbers that appear are the offset values that include |firstnumber|.  Thus, using |firstnumber=2| with |stepnumber=5| would cause the original lines $5, 10, 15, ...$ to be numbered, but with the values $6, 11, 16, ...$.
%
% \fvextra\ changes line numbering so that when |stepnumber| is used, the actual line numbers that appear are always multiples of |stepnumber| by default, regardless of any |firstnumber| offset.  The original \fancyvrb\ behavior may be turned on by setting |stepnumberoffsetvalues=true| (\cref{sec:general-options}).
%
%
%
% \section{Undocumented features of \fancyvrb}
%
% \fancyvrb\ defines some potentially useful but undocumented features.
%
% \subsection{Undocumented option}
%
% \begin{optionlist}
%
% \item[listparameters  (macro) (\meta{empty})]
% Set list-related lengths to modify spacing around lines of code.  For example, |listparameters=\setlength{\topsep}{0pt}| will remove space before and after a |Verbatim| environment.
%
% \end{optionlist}
%
%
% \subsection{Undocumented macros}
%
% \DescribeMacro{\FancyVerbTab}
%
% This defines the visible tab character (\FancyVerbTab) that is used when |showtabs=true|.  The default definition is
%\begin{verbatim}
%\def\FancyVerbTab{%
%  \valign{%
%    \vfil##\vfil\cr
%    \hbox{$\scriptscriptstyle-$}\cr
%    \hbox to 0pt{\hss$\scriptscriptstyle\rangle\mskip -.8mu$}\cr
%    \hbox{$\scriptstyle\mskip -3mu\mid\mskip -1.4mu$}\cr}}
%\end{verbatim}
% While this may be redefined directly, \fvextra\ also defines a new option |tab|
%
%
% \DescribeMacro{\FancyVerbSpace}
%
% This defines the visible space character (\texttt{\FancyVerbSpace}) that is used when |showspaces=true|.  The default definition (as patched by \fvextra, \cref{sec:patch:visible-space}) follows \url{https://tex.stackexchange.com/a/120231/10742}.  While this may be redefined directly, \fvextra\ also defines a new option |space|.
%
%
%
% \StopEventually{\PrintIndex}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
%
%
%
% \subsection{Required packages}
% The \pkg{upquote} package performs some font checks when it is loaded to determine whether \pkg{textcomp} is needed, but errors can result if the font is changed later in the preamble, so duplicate the package's font check at the end of the preamble.  Also check for a package order issue with \pkg{lineno} and \pkg{csquotes}.
%    \begin{macrocode}
\RequirePackage{etoolbox}
\RequirePackage{fancyvrb}
\RequirePackage{pdftexcmds}
\RequirePackage{upquote}
\AtEndPreamble{%
  \ifx\encodingdefault\upquote@OTone
    \ifx\ttdefault\upquote@cmtt\else\RequirePackage{textcomp}\fi
  \else
    \RequirePackage{textcomp}
  \fi}
\RequirePackage{lineno}
\@ifpackageloaded{csquotes}%
 {\PackageWarning{fvextra}{csquotes should be loaded after fvextra, %
  to avoid a warning from the lineno package}}{}
%    \end{macrocode}
%
%
%
%
% \subsection{Utility macros}
%
% \subsubsection{\fancyvrb\ space and tab tokens}
%
% \begin{macro}{\FV@ActiveSpaceToken}
% Active space for |\ifx| token comparisons.
%    \begin{macrocode}
\begingroup
\catcode`\ =\active%
\gdef\FV@ActiveSpaceToken{ }%
\endgroup%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@SpaceCatTen}
% Space with catcode 10.  Used instead of \Verb[showspaces]{\ } and |\space| in some contexts to avoid issues in the event that these are redefined.
%    \begin{macrocode}
\edef\FV@SpaceCatTen{{\detokenize{ }}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@FVSpaceToken}
% Macro with the same definition as \fancyvrb's active space.  Useful for |\ifx| comparisons, such as |\@ifnextchar| lookaheads.
%    \begin{macrocode}
\def\FV@FVSpaceToken{\FV@Space}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@FVTabToken}
% Macro with the same definition as \fancyvrb's active tab.  Useful for |\ifx| comparisons, such as |\@ifnextchar| lookaheads.
%    \begin{macrocode}
\def\FV@FVTabToken{\FV@Tab}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{ASCII processing}
%
% \begin{macro}{\FVExtraDoSpecials}
% Apply \cmd{\do} to all printable, non-alphanumeric ASCII characters (codepoints |0x20| through |0x7E| except for alphanumeric characters).
%
% These punctuation marks and symbols are the most likely characters to be made \cmd{\active}, so it is convenient to be able to change the catcodes for all of them, not just for those in the \cmd{\dospecials} defined in |latex.ltx|:
% \begin{quote}
%\begin{verbatim}
%\def\dospecials{\do\ \do\\\do\{\do\}\do\$\do\&%
%  \do\#\do\^\do\_\do\%\do\~}
%\end{verbatim}
% \end{quote}
% If a command takes an argument delimited by a given symbol, but that symbol has been made \cmd{\active} and defined as \cmd{\outer} (perhaps it is being used as a short \cmd{\verb}), then changing the symbol's catcode is the only way to use it as a delimiter.
%    \begin{macrocode}
\def\FVExtraDoSpecials{%
  \do\ \do\!\do\"\do\#\do\$\do\%\do\&\do\'\do\(\do\)\do\*\do\+\do\,\do\-%
  \do\.\do\/\do\:\do\;\do\<\do\=\do\>\do\?\do\@\do\[\do\\\do\]\do\^\do\_%
  \do\`\do\{\do\|\do\}\do\~}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Char@Special:<char>}
% Create macros for all printable, non-alphanumeric ASCII characters.  This is used in creating backslash escapes that can only be applied to ASCII symbols and punctuation; these macros serve as \cmd{\ifcsname} lookups for valid escapes.
%    \begin{macrocode}
\begingroup
\def\do#1{%
  \expandafter\global\expandafter
  \let\csname FV@Char@Special:\number`#1\endcsname\relax}
\FVExtraDoSpecials
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Char@CatTwelve:<char>, \FV@Char@CatDetok:<char>, \FV@Char@CatActive:<char>}
% Macros for accessing printable, non-alphanumeric ASCII characters with various catcodes.
%    \begin{macrocode}
\begingroup
\catcode`\!=0
\catcode`\<=1
\catcode`\>=2
\catcode`\&=14!relax&
!edef!FVCharNum<!number`!\>&
!catcode`!\=12!relax&
!expandafter!gdef!csname!detokenize<FV@Char@CatTwelve:>!FVCharNum!endcsname<\>&
!expandafter!xdef!csname!detokenize<FV@Char@CatDetok:>!FVCharNum!endcsname<!detokenize<\>>&
!catcode`!\=!active&
!expandafter!gdef!csname!detokenize<FV@Char@CatActive:>!FVCharNum!endcsname<\>&
!edef!FVCharNum<!number`!{>&
!catcode`!{=12!relax&
!expandafter!gdef!csname!detokenize<FV@Char@CatTwelve:>!FVCharNum!endcsname<{>&
!expandafter!xdef!csname!detokenize<FV@Char@CatDetok:>!FVCharNum!endcsname<!detokenize<{>>&
!catcode`!{=!active&
!expandafter!gdef!csname!detokenize<FV@Char@CatActive:>!FVCharNum!endcsname<{>&
!edef!FVCharNum<!number`!}>&
!catcode`!}=12!relax&
!expandafter!gdef!csname!detokenize<FV@Char@CatTwelve:>!FVCharNum!endcsname<}>&
!expandafter!xdef!csname!detokenize<FV@Char@CatDetok:>!FVCharNum!endcsname<!detokenize<}>>&
!catcode`!}=!active&
!expandafter!gdef!csname!detokenize<FV@Char@CatActive:>!FVCharNum!endcsname<}>&
!edef!FVCharNum<!number`! >&
!catcode`! =12!relax&
!expandafter!gdef!csname!detokenize<FV@Char@CatTwelve:>!FVCharNum!endcsname< >&
!expandafter!xdef!csname!detokenize<FV@Char@CatDetok:>!FVCharNum!endcsname<!detokenize< >>&
!catcode`! =!active&
!expandafter!gdef!csname!detokenize<FV@Char@CatActive:>!FVCharNum!endcsname< >&
!edef!FVCharNum<!number`!%>&
!catcode`!%=12!relax&
!expandafter!gdef!csname!detokenize<FV@Char@CatTwelve:>!FVCharNum!endcsname<%>&
!expandafter!xdef!csname!detokenize<FV@Char@CatDetok:>!FVCharNum!endcsname<!detokenize<%>>&
!catcode`!%=!active&
!expandafter!gdef!csname!detokenize<FV@Char@CatActive:>!FVCharNum!endcsname<%>&
!endgroup
\begingroup
\edef\FVCharNum{\number`\!}
\catcode`\!=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{!}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{!}}
\catcode`\!=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{!}
\endgroup
\begingroup
\edef\FVCharNum{\number`\"}
\catcode`\"=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{"}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{"}}
\catcode`\"=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{"}
\endgroup
\begingroup
\edef\FVCharNum{\number`\#}
\catcode`\#=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{#}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{#}}
\catcode`\#=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{#}
\endgroup
\begingroup
\edef\FVCharNum{\number`\$}
\catcode`\$=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{$}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{$}}
\catcode`\$=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{$}
\endgroup
\begingroup
\edef\FVCharNum{\number`\&}
\catcode`\&=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{&}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{&}}
\catcode`\&=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{&}
\endgroup
\begingroup
\edef\FVCharNum{\number`\'}
\catcode`\'=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{'}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{'}}
\catcode`\'=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{'}
\endgroup
\begingroup
\edef\FVCharNum{\number`\(}
\catcode`\(=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{(}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{(}}
\catcode`\(=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{(}
\endgroup
\begingroup
\edef\FVCharNum{\number`\)}
\catcode`\)=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{)}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{)}}
\catcode`\)=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{)}
\endgroup
\begingroup
\edef\FVCharNum{\number`\*}
\catcode`\*=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{*}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{*}}
\catcode`\*=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{*}
\endgroup
\begingroup
\edef\FVCharNum{\number`\+}
\catcode`\+=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{+}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{+}}
\catcode`\+=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{+}
\endgroup
\begingroup
\edef\FVCharNum{\number`\,}
\catcode`\,=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{,}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{,}}
\catcode`\,=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{,}
\endgroup
\begingroup
\edef\FVCharNum{\number`\-}
\catcode`\-=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{-}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{-}}
\catcode`\-=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{-}
\endgroup
\begingroup
\edef\FVCharNum{\number`\.}
\catcode`\.=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{.}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{.}}
\catcode`\.=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{.}
\endgroup
\begingroup
\edef\FVCharNum{\number`\/}
\catcode`\/=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{/}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{/}}
\catcode`\/=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{/}
\endgroup
\begingroup
\edef\FVCharNum{\number`\:}
\catcode`\:=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{:}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{:}}
\catcode`\:=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{:}
\endgroup
\begingroup
\edef\FVCharNum{\number`\;}
\catcode`\;=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{;}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{;}}
\catcode`\;=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{;}
\endgroup
\begingroup
\edef\FVCharNum{\number`\<}
\catcode`\<=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{<}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{<}}
\catcode`\<=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{<}
\endgroup
\begingroup
\edef\FVCharNum{\number`\=}
\catcode`\==12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{=}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{=}}
\catcode`\==\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{=}
\endgroup
\begingroup
\edef\FVCharNum{\number`\>}
\catcode`\>=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{>}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{>}}
\catcode`\>=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{>}
\endgroup
\begingroup
\edef\FVCharNum{\number`\?}
\catcode`\?=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{?}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{?}}
\catcode`\?=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{?}
\endgroup
\begingroup
\edef\FVCharNum{\number`\@}
\catcode`\@=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{@}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{@}}
\catcode`\@=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{@}
\endgroup
\begingroup
\edef\FVCharNum{\number`\[}
\catcode`\[=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{[}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{[}}
\catcode`\[=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{[}
\endgroup
\begingroup
\edef\FVCharNum{\number`\]}
\catcode`\]=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{]}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{]}}
\catcode`\]=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{]}
\endgroup
\begingroup
\edef\FVCharNum{\number`\^}
\catcode`\^=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{^}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{^}}
\catcode`\^=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{^}
\endgroup
\begingroup
\edef\FVCharNum{\number`\_}
\catcode`\_=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{_}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{_}}
\catcode`\_=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{_}
\endgroup
\begingroup
\edef\FVCharNum{\number`\`}
\catcode`\`=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{`}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{`}}
\catcode`\`=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{`}
\endgroup
\begingroup
\edef\FVCharNum{\number`\|}
\catcode`\|=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{|}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{|}}
\catcode`\|=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{|}
\endgroup
\begingroup
\edef\FVCharNum{\number`\~}
\catcode`\~=12
\expandafter\gdef\csname\detokenize{FV@Char@CatTwelve:}\FVCharNum\endcsname{~}
\expandafter\xdef\csname\detokenize{FV@Char@CatDetok:}\FVCharNum\endcsname{\detokenize{~}}
\catcode`\~=\active
\expandafter\gdef\csname\detokenize{FV@Char@CatActive:}\FVCharNum\endcsname{~}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraSaveCodes,\FVExtraUseCodes,\FancyVerbRestoreCodes}
% Save catcodes of all characters in |\FVExtraDoSpecials|, and then restore them.  The |\FVExtra*| commands take arguments of the form \oarg{pkg}\marg{name}.  |\FancyVerbRestoreCodes| is a shortcut for |\FVExtraUseCodes[fancyvrb]{BeforeVerbatim}|.
%    \begin{macrocode}
\newcommand{\FVExtraSaveCodes}[2][]{%
  \ifcsname do\endcsname
    \let\FV@dotmp\do
  \fi
  \if\relax\detokenize{#1}\relax
    \def\do##1{%
      \expandafter
      \chardef\csname FV@SVCode:\number`##1@#2\endcsname=%
        \catcode`##1\relax}%
    \expandafter\let\csname FV@SVCodes@#2\endcsname\relax
  \else
    \def\do##1{%
      \expandafter
      \chardef\csname FV@PkgSVCode:\number`##1@#1:#2\endcsname=%
        \catcode`##1\relax}%
    \expandafter\let\csname FV@PkgSVCodes@#1:#2\endcsname\relax
  \fi
  \FVExtraDoSpecials
  \ifcsname FV@dotmp\endcsname
    \let\do\FV@dotmp
    \let\FV@dotmp\FV@Undefined
  \else
    \let\do\FV@Undefined
  \fi}
\newcommand{\FVExtraUseCodes}[2][]{%
  \if\relax\detokenize{#1}\relax
    \expandafter\FVExtraUseCodes@NoPkg
  \else
    \expandafter\FVExtraUseCodes@Pkg
  \fi
  {#1}{#2}}
\def\FVExtraUseCodes@NoPkg#1#2{%
  \ifcsname FV@SVCodes@#2\endcsname
    \expandafter\FVExtraUseCodes@NoPkg@i
  \else
    \PackageError{fvextra}%
     {Unknown name "#2" for saved catcodes}%
     {Check name of saved catcodes}%
    \expandafter\@gobble
  \fi
  {#2}}
\def\FVExtraUseCodes@NoPkg@i#1{%
  \FVExtraUseCodes@end{FV@SVCode}{#1}}
\def\FVExtraUseCodes@Pkg#1#2{%
  \ifcsname FV@PkgSVCodes@#1:#2\endcsname
    \expandafter\FVExtraUseCodes@Pkg@i
  \else
    \PackageError{fvextra}%
     {Unknown name "#2" for saved catcodes for package "#1"}%
     {Check name of saved catcodes}%
    \expandafter\@gobble
  \fi
  {#1:#2}}
\def\FVExtraUseCodes@Pkg@i#1{%
  \FVExtraUseCodes@end{FV@PkgSVCode}{#1}}
\def\FVExtraUseCodes@end#1#2{%
  \ifcsname do\endcsname
    \let\FV@dotmp\do
  \fi
  \def\do##1{%
    \catcode`##1=%
      \csname #1:\number`##1@#2\endcsname\relax}%
  \FVExtraDoSpecials
  \ifcsname FV@dotmp\endcsname
    \let\do\FV@dotmp
    \let\FV@dotmp\FV@Undefined
  \else
    \let\do\FV@Undefined
  \fi}
\AtEndOfPackage{%  
  \FV@AddToHook{\FV@UseKeyValues@Hook}{\FVExtraSaveCodes[fancyvrb]{BeforeVerbatim}}}
\def\FancyVerbRestoreCodes{\FVExtraUseCodes[fancyvrb]{BeforeVerbatim}}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Sentinels}
%
% Sentinel macros are needed for scanning tokens.
%
% There are two contexts in which sentinels may be needed.  In delimited macro arguments, such as |\def\macro#1\sentinel{...}|, a sentinel is needed as the delimiter.  Because the delimiting macro need not be defined, special delimiting macros need not be created for this case.  The important thing is to ensure that the macro name is sufficiently unique to avoid collisions.  Typically, using \cmd{\makeatletter} to allow something like \cmd{\@sentinel} will be sufficient.  For added security, additional characters can be given catcode 11, to allow things like \cmd{\@sent!nel}.
%
% The other context for sentinels is in scanning through a sequence of tokens that is delimited by a sentinel, and using \cmd{\ifx} comparisons to identify the sentinel and stop scanning.  In this case, using an undefined macro is risky.  Under normal conditions, the sequence of tokens could contain an undefined macro due to mistyping.  In some \fvextra\ applications, the tokens will have been incorrectly tokenized under a normal catcode regime, and need to be retokenized as verbatim, in which case undefined macros must be expected.  Thus, a sentinel macro whose expansion is resistant to collisions is needed.
%
% \begin{macro}{\FV@<Sentinel>}
% This is the standard default \fvextra\ delimited-macro sentinel.  It is used with \cmd{\makeatletter} by changing |<| and |>| to catcode 11.  The |<| and |>| add an extra level of collision resistance.  Because it is undefined, it is \emph{only} appropriate for use in delimited macro arguments.
% \end{macro}
%
% \begin{macro}{\FV@Sentinel}
% This is the standard \fvextra\ \cmd{\ifx} comparison sentinel.  It expands to the control word \cmd{\FV@<Sentinel>}, which is very unlikely to be in any other macro since it requires that |@|, |<|, and |>| all have catcode 11 and appear in the correct sequence.  Because its definition is itself undefined, this sentinel will result in an error if it escapes.
%    \begin{macrocode}
\begingroup
\catcode`\<=11
\catcode`\>=11
\gdef\FV@Sentinel{\FV@<Sentinel>}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Active character definitions}
%
% \begin{macro}{\FV@OuterDefEOLEmpty}
% Macro for defining the active end-of-line character |^^M| (|\r|), which \fancyvrb\ uses to prevent runaway command arguments.  \fancyvrb\ uses macro definitions of the form
%\begin{verbatim}
%\begingroup
%\catcode`\^^M=\active%
%\gdef\macro{%
%  ...
%  \outer\def^^M{}%
%  ...
%}%
%\endgroup
%\end{verbatim}
% While this works, it is nice to avoid the |\begingroup...\endgroup| and especially the requirement that all lines now end with |%| to discard the |^^M| that would otherwise be inserted.
%    \begin{macrocode}
\begingroup
\catcode`\^^M=\active%
\gdef\FV@OuterDefEOLEmpty{\outer\def^^M{}}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@DefEOLEmpty}
% The same thing, without the \cmd{\outer}.  This is used to ensure that |^^M| is not \cmd{\outer} when it should be read.
%    \begin{macrocode}
\begingroup
\catcode`\^^M=\active%
\gdef\FV@DefEOLEmpty{\def^^M{}}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@OuterDefSTXEmpty}
% Define start-of-text (STX) |^^B| so that it cannot be used inside other macros.  This makes it possible to guarantee that |^^B| is not part of a verbatim argument, so that it can be used later as a sentinel in retokenizing the argument.
%    \begin{macrocode}
\begingroup
\catcode`\^^B=\active
\gdef\FV@OuterDefSTXEmpty{\outer\def^^B{}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@OuterDefETXEmpty}
% Define end-of-text (ETX) |^^C| so that it cannot be used inside other macros.  This makes it possible to guarantee that |^^C| is not part of a verbatim argument, so that it can be used later as a sentinel in retokenizing the argument.
%    \begin{macrocode}
\begingroup
\catcode`\^^C=\active
\gdef\FV@OuterDefETXEmpty{\outer\def^^C{}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{pdfTeX with \pkg{inputenc} using UTF-8}
%
% Working with verbatim text often involves handling individual code points.  While these are treated as single entities under LuaTeX and XeTeX, under pdfTeX code points must be handled at the byte level instead.  This means that reading a single code point encoded in UTF-8 may involve a macro that reads up to four arguments.
%
% Macros are defined for working with non-ASCII code points under pdfTeX.  These are only for use with the \pkg{inputenc} package set to |utf8| encoding.
%
% \begin{macro}{\ifFV@pdfTeXinputenc}
% All of the |UTF| macros are only needed with pdfTeX when \pkg{inputenc} is loaded, so they are created conditionally, inspired by the approach of the \pkg{iftex} package.  The tests deal with the possibility that a previous test using |\ifx| rather than the cleaner |\ifcsname| has already been performed.  These assume that \pkg{inputenc} will be loaded before \fvextra.  The \cmd{\inputencodingname} tests should be redundant after the \cmd{\@ifpackageloaded} test, but do provide some additional safety if another package is faking \pkg{inputenc} being loaded but not providing an equivalent encoding interface.
%
% Note that an encoding test of the form
% \begin{quote}
%\begin{verbatim}
%\ifdefstring{\inputencodingname}{utf8}{<true>}{<false>}
%\end{verbatim}
% \end{quote}
% is still required before switching to the |UTF| variants in any given situation.  A document using \pkg{inputenc} can switch encodings (for example, around an \cmd{\input}), so simply checking encoding when \fvextra\ is loaded is \emph{not} sufficient.
%    \begin{macrocode}
\newif\ifFV@pdfTeXinputenc
\FV@pdfTeXinputencfalse
\ifcsname pdfmatch\endcsname
\ifx\pdfmatch\relax
\else
  \@ifpackageloaded{inputenc}%
   {\ifcsname inputencodingname\endcsname
    \ifx\inputencodingname\relax
    \else
      \FV@pdfTeXinputenctrue
    \fi\fi}
   {}%
\fi\fi
%    \end{macrocode}
% \end{macro}
%
% Define |UTF| macros conditionally:
%    \begin{macrocode}
\ifFV@pdfTeXinputenc
%    \end{macrocode}
%
%
% \begin{macro}{\FV@U8:<byte>}
% Define macros of the form |\FV@U8:<byte>| for each active byte.  These are used for determining whether a token is the first byte in a multi-byte sequence, and if so, invoking the necessary macro to capture the remaining bytes.  The code is adapted from the beginning of |utf8.def|.  Completely capitalized macro names are used to avoid having to worry about |\uppercase|.
%    \begin{macrocode}
\begingroup
\catcode`\~=13
\catcode`\"=12
\def\FV@UTFviii@loop{%
  \uccode`\~\count@
  \uppercase\expandafter{\FV@UTFviii@Tmp}%
  \advance\count@\@ne
  \ifnum\count@<\@tempcnta
  \expandafter\FV@UTFviii@loop
  \fi}
%    \end{macrocode}
% Setting up 2-byte UTF-8:
%    \begin{macrocode}
\count@"C2
\@tempcnta"E0
\def\FV@UTFviii@Tmp{\expandafter\gdef\csname FV@U8:\string~\endcsname{%
  \FV@UTF@two@octets}}
\FV@UTFviii@loop
%    \end{macrocode}
% Setting up 3-byte UTF-8:
%    \begin{macrocode}
\count@"E0
\@tempcnta"F0
\def\FV@UTFviii@Tmp{\expandafter\gdef\csname FV@U8:\string~\endcsname{%
  \FV@UTF@three@octets}}
\FV@UTFviii@loop
%    \end{macrocode}
% Setting up 4-byte UTF-8:
%    \begin{macrocode}
\count@"F0
\@tempcnta"F4
\def\FV@UTFviii@Tmp{\expandafter\gdef\csname FV@U8:\string~\endcsname{%
  \FV@UTF@four@octets}}
\FV@UTFviii@loop
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@UTF@two@octets}%
% \begin{macro}{\FV@UTF@three@octets}%
% \begin{macro}{\FV@UTF@four@octets}
% These are variants of the |utf8.def| macros that capture all bytes of a multi-byte code point and then pass them on to \cmd{\FV@UTF@octets@after} as a single argument for further processing.  The invoking macro should \cmd{\let} or \cmd{\def}'ed \cmd{\FV@UTF@octets@after} to an appropriate macro that performs further processing.
%
% Typical use will involve the following steps:
% \begin{enumerate}
% \item Read a token, say |#1|.
% \item Use |\ifcsname FV@U8:\detokenize{#1}\endcsname| to determine that the token is the first byte of a multi-byte code point.
% \item Ensure that |\FV@UTF@octets@after| has an appropriate value, if this has not already been done.
% \item Use |\csname FV@U8:\detokenize{#1}\endcsname#1| at the end of the original reading macro to read the full multi-byte code point and then pass it on as a single argument to |\FV@UTF@octets@after|.
% \end{enumerate}
%
% All code points are checked for validity here so as to raise errors as early as possible.  Otherwise an invalid terminal byte sequence might gobble a sentinel macro in a scanning context, potentially making debugging much more difficult.  It would be possible to use |\UTFviii@defined{|\meta{bytes}|}| to trigger an error directly, but the current approach is to attempt to typeset invalid code points, which should trigger errors without relying on the details of the |utf8.def| implementation.
%    \begin{macrocode}
\def\FV@UTF@two@octets#1#2{%
  \ifcsname u8:\detokenize{#1#2}\endcsname
  \else
    #1#2%
  \fi
  \FV@UTF@octets@after{#1#2}}
\def\FV@UTF@three@octets#1#2#3{%
  \ifcsname u8:\detokenize{#1#2#3}\endcsname
  \else
    #1#2#3%
  \fi
  \FV@UTF@octets@after{#1#2#3}}
\def\FV@UTF@four@octets#1#2#3#4{%
  \ifcsname u8:\detokenize{#1#2#3#4}\endcsname
  \else
    #1#2#3#4%
  \fi
  \FV@UTF@octets@after{#1#2#3#4}}
%    \end{macrocode}
% \end{macro}\end{macro}\end{macro}
%
%
% End conditional creation of |UTF| macros:
%    \begin{macrocode}
\fi
%    \end{macrocode}
%
%
%
%
% \subsection{Reading and processing command arguments}
%
% \fvextra\ provides macros for reading and processing verbatim arguments.  These are primarily intended for creating commands that take verbatim arguments but can still be used within other commands (with some limitations).  These macros are used in reimplementing \fancyvrb\ commands like \cmd{\Verb}.  They may also be used in other packages; \pkg{minted} and \pkg{pythontex} use them for handling inline code.
%
% All macros meant for internal use have names of the form \cmd{\FV@<Name>}, while all macros meant for use in other packages have names of the form \cmd{\FVExtra<Name>}.  Only the latter are intended to have a stable interface.
%
%
% \subsubsection{Tokenization and lookahead}
%
%
% \begin{macro}{\FVExtra@ifnextcharAny}
% A version of |\@ifnextchar| that can detect any character, including catcode 10 spaces.  This is an exact copy of the definition from |latex.ltx|, modified with the ``|\let\reserved@d= #1%|'' (note space!) trick from \pkg{amsgen}.
%    \begin{macrocode}
\long\def\FVExtra@ifnextcharAny#1#2#3{%
  \let\reserved@d= #1%
  \def\reserved@a{#2}%
  \def\reserved@b{#3}%
  \futurelet\@let@token\FVExtra@ifnchAny}
\def\FVExtra@ifnchAny{%
  \ifx\@let@token\reserved@d
    \expandafter\reserved@a
  \else
    \expandafter\reserved@b
  \fi}
%    \end{macrocode}
% \end{macro}

%
% \begin{macro}{\FVExtra@ifnextcharVArg}
% This is a wrapper for \cmd{\@ifnextchar} from |latex.ltx| (|ltdefns.dtx|) that tokenizes lookaheads under a mostly verbatim catcode regime rather than the current catcode regime.  This is important when looking ahead for stars |*| and optional argument delimiters~|[|, because if these are not present when looking ahead for a verbatim argument, then the first thing tokenized will be the verbatim argument's delimiting character.  Ideally, the delimiter should be tokenized under a verbatim catcode regime.  This is necessary for instance if the delimiter is \cmd{\active} and \cmd{\outer}.
%
% The catcode of the space is preserved (in the unlikely event it is \cmd{\active}) and curly braces are given their normal catcodes for the lookahead.  This simplifies space handling in an untokenized context, and allows paired curly braces to be used as verbatim delimiters.
%    \begin{macrocode}
\long\def\FVExtra@ifnextcharVArg#1#2#3{%
  \begingroup
  \edef\FV@TmpSpaceCat{\the\catcode` }%
  \let\do\@makeother\FVExtraDoSpecials
  \catcode`\ =\FV@TmpSpaceCat\relax
  \catcode`\{=1
  \catcode`\}=2
  \@ifnextchar#1{\endgroup#2}{\endgroup#3}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtra@ifstarVArg}
% A starred command behaves differently depending on whether it is followed by an optional star or asterisk |*|.  \cmd{\@ifstar} from |latex.ltx| is typically used to check for the |*|.  In the process, it discards following spaces (catcode 10) and tokenizes the next non-space character under the current catcode regime.  While this is fine for normal commands, it is undesirable if the next character turns out to be not a |*| but rather a verbatim argument's delimiter.  This reimplementation prevents such issues for all printable ASCII symbols via \cmd{\FVExtra@ifnextcharVArg}.
%    \begin{macrocode}
\begingroup
\catcode`\*=12
\gdef\FVExtra@ifstarVArg#1{\FVExtra@ifnextcharVArg*{\@firstoftwo{#1}}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Reading arguments}
%
% \begin{macro}{\FV@ReadOArgContinue}
% Read a macro followed by an optional argument, then pass the optional argument to the macro for processing and to continue.
%    \begin{macrocode}
\def\FV@ReadOArgContinue#1[#2]{#1{#2}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraReadOArgBeforeVArg}
% Read an optional argument that comes before a verbatim argument.  The lookahead for the optional argument tokenizes with a verbatim catcode regime in case it encounters the delimiter for the verbatim argument rather than |[|.  If the lookahead doesn't find |[|, the optional argument for \cmd{\FVExtraReadOArgBeforeVArg} can be used to supply a default optional argument other than \meta{empty}.
%    \begin{macrocode}
\newcommand{\FVExtraReadOArgBeforeVArg}[2][]{%
  \FVExtra@ifnextcharVArg[%
   {\FV@ReadOArgContinue{#2}}%
   {\FV@ReadOArgContinue{#2}[#1]}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraReadOArgBeforeVEnv}
% Read an optional argument at the start of a verbatim environment, after the |\begin{|\meta{environment}|}| but before the start of the next line where the verbatim content begins.  Check for extraneous content after the optional argument and discard the following newline.  Note that this is not needed when an environment takes a mandatory argument that follows the optional argument.
%
% The case with only an optional argument is tricky because the default behavior of \cmd{\@ifnextchar} is to read into the next line looking for the optional argument.  Setting |^^M| as \cmd{\active} prevents this.  That does mean, though, that the end-of-line token will have to be read and removed later as an \cmd{\active} |^^M|.
%
% \cmd{\@ifnextchar} is used instead of \cmd{\FVExtra@ifnextcharVArg} because the latter is not needed since there is an explicit, required delimiter (|^^M|) before the actual start of verbatim content.  Lookahead can never tokenize verbatim content under an incorrect catcode regime.
%    \begin{macrocode}
\newcommand{\FVExtraReadOArgBeforeVEnv}[2][]{%
  \begingroup
  \catcode`\^^M=\active
  \@ifnextchar[%
   {\endgroup\FVExtraReadOArgBeforeVEnv@i{#2}}%
   {\endgroup\FVExtraReadOArgBeforeVEnv@i{#2}[#1]}}
\def\FVExtraReadOArgBeforeVEnv@i#1[#2]{%
  \begingroup
  \catcode`\^^M=\active
  \FVExtraReadOArgBeforeVEnv@ii{#1}{#2}}
\begingroup
\catcode`\^^M=\active%
\gdef\FVExtraReadOArgBeforeVEnv@ii#1#2#3^^M{%
  \endgroup%
  \FVExtraReadOArgBeforeVEnv@iii{#1}{#2}{#3}}%
\endgroup%
\def\FVExtraReadOArgBeforeVEnv@iii#1#2#3{%
  \if\relax\detokenize{#3}\relax
  \else
    \PackageError{fvextra}%
     {Discarded invalid text while checking for optional argument of verbatim environment}%
     {Discarded invalid text while checking for optional argument of verbatim environment}%
  \fi
  #1{#2}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraReadVArg,\FVExtraReadVArgSingleLine}
% Read a verbatim argument that is bounded by two identical characters or by paired curly braces.  There are two variants:  one reads a multi-line (but not multi-paragraph) argument, while the other restricts the argument to a single line via the \cmd{\outer} |^^M| trick from \fancyvrb.  An \cmd{\outer} |^^C| is used to prevent |^^C| from being part of arguments, so that it can be used later as a sentinel if retokenization is needed.  |^^B| is handled in the same manner for symmetry with later usage, though technically it is not used as a sentinel so this is not strictly necessary.  Alternate |UTF| macros, defined later, are invoked when under pdfTeX with \pkg{inputenc} using UTF-8.
%
% The lookahead for the type of delimiting character is done under a verbatim catcode regime, except that the space catcode is preserved and curly braces are given their normal catcodes.  This provides consistency with any \cmd{\FVExtra@ifnextcharVArg} or \cmd{\FVExtra@ifstarVArg} that may have been used previously, allows characters like |#| and |%| to be used as delimiters when the verbatim argument is read outside any other commands (untokenized), and allows paired curly braces to serve as delimiters.  Any additional command-specific catcode modifications should only be applied to the argument after it has been read, since they do not apply to the delimiters.
%
% Once the delimiter lookahead is complete, catcodes revert to full verbatim, and are then modified appropriately given the type of delimiter.  The space and tab must be \cmd{\active} to be preserved correctly when the verbatim argument is not inside any other commands (otherwise, they collapse into single spaces).
%
% Note that |\FVExtraReadVArg| will interpret a line break as a catcode 10 space, not as an |\active| space.  Depending on usage, the argument may need to be processed with |\FVExtraDetokenizeVArg| and |\FVExtraRetokenizeVArg| to fix this.
%    \begin{macrocode}
\def\FVExtraReadVArg#1{%
  \begingroup
  \ifFV@pdfTeXinputenc
    \ifdefstring{\inputencodingname}{utf8}%
     {\let\FV@ReadVArg@Char\FV@ReadVArg@Char@UTF}%
     {}%
  \fi
  \edef\FV@TmpSpaceCat{\the\catcode` }%
  \let\do\@makeother\FVExtraDoSpecials
  \catcode`\^^B=\active
  \FV@OuterDefSTXEmpty
  \catcode`\^^C=\active
  \FV@OuterDefETXEmpty
  \begingroup
  \catcode`\ =\FV@TmpSpaceCat\relax
  \catcode`\{=1
  \catcode`\}=2
  \@ifnextchar\bgroup
   {\endgroup
    \catcode`\{=1
    \catcode`\}=2
    \catcode`\ =\active
    \catcode`\^^I=\active
    \FV@ReadVArg@Group{#1}}%
   {\endgroup
    \catcode`\ =\active
    \catcode`\^^I=\active
    \FV@ReadVArg@Char{#1}}}
\def\FVExtraReadVArgSingleLine#1{%
  \begingroup
  \ifFV@pdfTeXinputenc
    \ifdefstring{\inputencodingname}{utf8}%
     {\let\FV@ReadVArg@Char\FV@ReadVArg@Char@UTF}%
     {}%
  \fi
  \edef\FV@TmpSpaceCat{\the\catcode` }%
  \let\do\@makeother\FVExtraDoSpecials
  \catcode`\^^B=\active
  \FV@OuterDefSTXEmpty
  \catcode`\^^C=\active
  \FV@OuterDefETXEmpty
  \catcode`\^^M=\active
  \FV@OuterDefEOLEmpty
  \begingroup
  \catcode`\ =\FV@TmpSpaceCat\relax
  \catcode`\{=1
  \catcode`\}=2
  \@ifnextchar\bgroup
   {\endgroup
    \catcode`\{=1
    \catcode`\}=2
    \catcode`\ =\active
    \catcode`\^^I=\active
    \FV@ReadVArg@Group{#1}}%
   {\endgroup
    \catcode`\ =\active
    \catcode`\^^I=\active
    \FV@ReadVArg@Char{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@ReadVArg@Group}
% The argument is read under the verbatim catcode regime already in place from \cmd{\FVExtraReadVArg}.  The \cmd{\endgroup} returns to prior catcodes.  Any command-specific catcodes can be applied later via \cmd{\scantokens}.  Using them here in reading the argument would have no effect as far as later processing with \cmd{\scantokens} is concerned, unless the argument were read outside any other commands and additional characters were given catcodes 1 or 2 (like the curly braces).  That scenario is not allowed because it makes reading the argument overly dependent on the argument content.  (Technically, reading the argument is already dependent on the argument content in the sense that the argument cannot contain unescaped unpaired curly braces, given that it is delimited by curly braces.)
%    \begin{macrocode}
\def\FV@ReadVArg@Group#1#2{%
  \endgroup
  #1{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@ReadVArg@Char}
% The delimiting character is read under the verbatim catcode regime in place from \cmd{\FVExtraReadVArg}.  If the command is not inside a normal command, then this means the delimiting character will typically have catcode 12 and that characters like |#| and |%| can be used as delimiters; otherwise, the delimiter may have any catcode that is possible for a single character captured by a macro.  If the argument is read inside another command (already tokenized), then it is possible for the delimiter to be a control sequence rather than a singler character.  An error is raised in this case.  The \cmd{\endgroup} in \cmd{\FV@ReadVArg@Char@i} returns to prior catcodes after the argument is captured.
%
% It would be possible to read the argument using any command-specific catcode settings, but that would result in different behavior depending on whether the argument is already tokenized, and would make reading the argument overly dependent on the argument content.
%    \begin{macrocode}
\def\FV@ReadVArg@Char#1#2{%
  \expandafter\expandafter\expandafter
  \if\expandafter\expandafter\expandafter\relax\expandafter\@gobble\detokenize{#2}\relax
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\PackageError{fvextra}%
    {Verbatim delimiters must be single characters, not commands}%
    {Try a different delimiter}}%
  \def\FV@ReadVArg@Char@i##1##2#2{%
    \endgroup
    ##1{##2}}%
  \FV@ReadVArg@Char@i{#1}}%
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Alternate implementation for pdfTeX with \pkg{inputenc} using UTF-8}\hfill\\
%
% Start conditional creation of macros:
%    \begin{macrocode}
\ifFV@pdfTeXinputenc
%    \end{macrocode}
%
% \begin{macro}{\FV@ReadVArg@Char@UTF}
% This is a variant of \cmd{\FV@ReadVArg@Char} that allows non-ASCII codepoints as delimiters under the pdfTeX engine with \pkg{inputenc} using UTF-8.  Under pdfTeX, non-ASCII codepoints must be handled as a sequence of bytes rather than as a single entity.  \cmd{\FV@ReadVArg@Char} is automatically \cmd{\let} to this version when appropriate.  This uses the \cmd{\FV@U8:<byte>} macros for working with \pkg{inputenc}'s UTF-8.
%    \begin{macrocode}
\def\FV@ReadVArg@Char@UTF#1#2{%
  \expandafter\expandafter\expandafter
  \if\expandafter\expandafter\expandafter\relax\expandafter\@gobble\detokenize{#2}\relax
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\PackageError{fvextra}%
    {Verbatim delimiters must be single characters, not commands}%
    {Try a different delimiter}}%
  \ifcsname FV@U8:\detokenize{#2}\endcsname
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\def\FV@UTF@octets@after##1{\FV@ReadVArg@Char@UTF@i{#1}{##1}}%
   \csname FV@U8:\detokenize{#2}\endcsname#2}%
  {\FV@ReadVArg@Char@UTF@i{#1}{#2}}}
%    \end{macrocode}
%
% \begin{macro}{\FV@ReadVArg@Char@UTF@i}
%    \begin{macrocode}
\def\FV@ReadVArg@Char@UTF@i#1#2{%
  \def\FV@ReadVArg@Char@i##1##2#2{%
    \endgroup
    ##1{##2}}%
  \FV@ReadVArg@Char@i{#1}}%
%    \end{macrocode}
% \end{macro}
%
% End conditional creation of |UTF| macros:
%   \begin{macrocode}
\fi
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{vargsingleline}
% This determines whether |\Verb| and |\SaveVerb| use |\FVExtraReadVArg| or |\FVExtraReadVArgSingleLine| to read their arguments.  It has no effect on |\EscVerb|, since that does not use special tokenization.
%    \begin{macrocode}
\newbool{FV@vargsingleline}
\define@booleankey{FV}{vargsingleline}%
 {\booltrue{FV@vargsingleline}}
 {\boolfalse{FV@vargsingleline}}
\fvset{vargsingleline=false}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Reading and protecting arguments in expansion-only contexts}
%
% The objective here is to make possible commands that can function correctly after being in expansion-only contexts like \cmd{\edef}.  The general strategy is to allow commands to be defined like this:
%\begin{verbatim}
%\def\cmd{\FVExtraRobustCommand\robustcmd\reader}
%\end{verbatim}
% |\robustcmd| is the actual command, including argument reading and processing, and is \cmd{\protected}.  |\reader| is an expandable macro that reads all of |\robustcmd|'s arguments, then wraps them in \cmd{\FVExtraAlwaysUnexpanded}.  When |\FVExtraAlwaysUnexpanded{|\meta{args}|}| is expanded, the result is always |\FVExtraAlwaysUnexpanded{|\meta{args}|}|.  |\FVExtraRobustCommand| is \cmd{\protected} and manages everything in a context-sensitive manner.
% \begin{itemize}
% \item In a normal context, \cmd{\FVExtraRobustCommand} reads two arguments, which will be |\robustcmd| and |\reader|.  It detects that |\reader| has not expanded to |\FVExtraAlwaysUnexpanded{|\meta{args}|}|, so it discards |\reader| and reinserts |\robustcmd| so that it can operate normally.
% \item In an expansion-only context, neither \cmd{\FVExtraRobustCommand} nor |\robustcmd| will expand, because both are \cmd{\protected}.  |\reader| will read |\robustcmd|'s arguments and protect them with \cmd{\FVExtraAlwaysUnexpanded}.  When this is used later in a normal context, \cmd{\FVExtraRobustCommand} reads two arguments, which will be |\robustcmd| and \cmd{\FVExtraAlwaysUnexpanded}.  It detects that |\reader| did expand, so it discards \cmd{\FVExtraAlwaysUnexpanded} and reads its argument to discard the wrapping braces.  Then it reinserts |\robustcmd|\meta{args} so that everything can proceed as if expansion had not occurred.
% \end{itemize}
%
% \begin{macro}{\FVExtrapdfstringdef}
% \begin{macro}{\FVExtrapdfstringdefDisableCommands}
% Conditionally allow alternate definitions for PDF bookmarks when \pkg{hyperref} is in use.  This is helpful for working with \cmd{\protected} or otherwise unexpandable commands.
%    \begin{macrocode}
\def\FVExtrapdfstringdef#1#2{%
  \AfterPreamble{%
    \ifcsname pdfstringdef\endcsname
    \ifx\pdfstringdef\relax
    \else
    \pdfstringdef#1{#2}%
    \fi\fi}}
\def\FVExtrapdfstringdefDisableCommands#1{%
  \AfterPreamble{%
    \ifcsname pdfstringdefDisableCommands\endcsname
    \ifx\pdfstringdefDisableCommands\relax
    \else
    \pdfstringdefDisableCommands{#1}%
    \fi\fi}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\FVExtraAlwaysUnexpanded}
% Always expands to itself, thanks to \cmd{\unexpanded}.
%    \begin{macrocode}
\long\def\FVExtraAlwaysUnexpanded#1{%
  \unexpanded{\FVExtraAlwaysUnexpanded{#1}}}
\FVExtrapdfstringdefDisableCommands{%
  \long\def\FVExtraAlwaysUnexpanded#1{#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{FVExtraRobustCommandExpanded}
% Boolean to track whether expansion occurred.  Set in \cmd{\FVExtraRobustCommand}.  Useful in creating commands that behave differently depending on whether expansion occurred.
%    \begin{macrocode}
\newbool{FVExtraRobustCommandExpanded}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVExtraRobustCommand}
%    \begin{macrocode}
\protected\def\FVExtraRobustCommand#1#2{%
  \ifx#2\FVExtraAlwaysUnexpanded
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\booltrue{FVExtraRobustCommandExpanded}\FV@RobustCommand@i{#1}}%
  {\boolfalse{FVExtraRobustCommandExpanded}#1}}
\FVExtrapdfstringdefDisableCommands{%
  \def\FVExtraRobustCommand{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@RobustCommand@i}
% |#2| will be the argument of \cmd{\FVExtraAlwaysUnexpanded}.  Reading this strips the braces.  At the beginning of |#2| will be the reader macro, which must be \cmd{\@gobble}'d.
%    \begin{macrocode}
\def\FV@RobustCommand@i#1#2{\expandafter#1\@gobble#2}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVExtraUnexpandedReadStarOArgMArg}
% Read the arguments for a command that may be starred, may have an optional argument, and has a single brace-delimited mandatory argument.  Then protect them with \cmd{\FVExtraAlwaysUnexpanded}.  The reader macro is itself maintained in the protected result, so that it can be redefined to provide a simple default value for \pkg{hyperref}.
%
% Note the argument signature |#1#{|.  This reads everything up to, but not including, the next brace group.
%    \begin{macrocode}
\def\FVExtraUnexpandedReadStarOArgMArg#1#{%
  \FV@UnexpandedReadStarOArgMArg@i{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@UnexpandedReadStarOArgMArg@i}
%    \begin{macrocode}
\def\FV@UnexpandedReadStarOArgMArg@i#1#2{%
  \FVExtraAlwaysUnexpanded{\FVExtraUnexpandedReadStarOArgMArg#1{#2}}}
\FVExtrapdfstringdefDisableCommands{%
  \makeatletter
  \def\FV@UnexpandedReadStarOArgMArg@i#1#2{#2}%
  \makeatother}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraUseVerbUnexpandedReadStarOArgMArg}
% This is a variant of \cmd{\FVExtraUnexpandedReadStarOArgMArg} customized for \cmd{\UseVerb}.  It would be tempting to use \cmd{\pdfstringdef} to define a PDF string based on the final tokenization in \cmd{\UseVerb}, rather than applying \cmd{\FVExtraPDFStringVerbatimDetokenize} to the original raw (read) tokenization.  Unfortunately, \cmd{\pdfstringdef} apparently can't handle catcode 12 |\| and |%|.  Since the final tokenization could contain arbitrary catcodes, that approach might fail even if the |\| and |%| issue were resolved.  It may be worth considering more sophisticated approaches in the future.
%    \begin{macrocode}
\def\FVExtraUseVerbUnexpandedReadStarOArgMArg#1#{%
  \FV@UseVerbUnexpandedReadStarOArgMArg@i{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@UseVerbUnexpandedReadStarOArgMArg@i}
%    \begin{macrocode}
\def\FV@UseVerbUnexpandedReadStarOArgMArg@i#1#2{%
  \FVExtraAlwaysUnexpanded{\FVExtraUseVerbUnexpandedReadStarOArgMArg#1{#2}}}
\FVExtrapdfstringdefDisableCommands{%
  \makeatletter
  \def\FV@UseVerbUnexpandedReadStarOArgMArg@i#1#2{%
    \ifcsname FV@SVRaw@#2\endcsname
      \expandafter\expandafter\expandafter\FVExtraPDFStringVerbatimDetokenize
      \expandafter\expandafter\expandafter{\csname FV@SVRaw@#2\endcsname}%
    \fi}%
  \makeatother}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraUnexpandedReadStarOArgBVArg}
% Same as \cmd{\FVExtraUnexpandedReadStarOArgMArg}, except |BVArg|, brace-delimited verbatim argument.
%    \begin{macrocode}
\def\FVExtraUnexpandedReadStarOArgBVArg#1#{%
  \FV@UnexpandedReadStarOArgBVArg@i{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@UnexpandedReadStarOArgBVArg@i}
%    \begin{macrocode}
\def\FV@UnexpandedReadStarOArgBVArg@i#1#2{%
  \FVExtraAlwaysUnexpanded{\FVExtraUnexpandedReadStarOArgBVArg#1{#2}}}
\FVExtrapdfstringdefDisableCommands{%
  \makeatletter
  \def\FV@UnexpandedReadStarOArgBVArg@i#1#2{%
    \FVExtraPDFStringVerbatimDetokenize{#2}}%
  \makeatother}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraUnexpandedReadStarOArgBEscVArg}
% Same as \cmd{\FVExtraUnexpandedReadStarOArgMArg}, except |BEscVArg|, brace-delimited escaped verbatim argument.
%    \begin{macrocode}
\def\FVExtraUnexpandedReadStarOArgBEscVArg#1#{%
  \FV@UnexpandedReadStarOArgBEscVArg@i{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@UnexpandedReadStarOArgBEscVArg@i}
%    \begin{macrocode}
\def\FV@UnexpandedReadStarOArgBEscVArg@i#1#2{%
  \FVExtraAlwaysUnexpanded{\FVExtraUnexpandedReadStarOArgBEscVArg#1{#2}}}
\FVExtrapdfstringdefDisableCommands{%
  \makeatletter
  \def\FV@UnexpandedReadStarOArgBEscVArg@i#1#2{%
    \FVExtraPDFStringEscapedVerbatimDetokenize{#2}}%
  \makeatother}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraUnexpandedReadStarOArgMArgBVArg}
% Read arguments for a command that has a mandatory argument before a verbatim argument, such as \pkg{minted}'s \cmd{\mintinline}.
%    \begin{macrocode}
\def\FVExtraUnexpandedReadStarOArgMArgBVArg#1#{%
  \FV@UnexpandedReadStarOArgMArgBVArg@i{#1}}
\def\FV@UnexpandedReadStarOArgMArgBVArg@i#1#2{%
  \FV@UnexpandedReadStarOArgMArgBVArg@ii{#1}{#2}}
\def\FV@UnexpandedReadStarOArgMArgBVArg@ii#1#2#3#{%
  \FV@UnexpandedReadStarOArgMArgBVArg@iii{#1}{#2}{#3}}
\def\FV@UnexpandedReadStarOArgMArgBVArg@iii#1#2#3#4{%
  \FVExtraAlwaysUnexpanded{\FVExtraUnexpandedReadStarOArgMArgBVArg#1{#2}#3{#4}}}
\FVExtrapdfstringdefDisableCommands{%
  \makeatletter
  \def\FV@UnexpandedReadStarOArgMArgBVArg@iii#1#2#3#4{%
    \FVExtraPDFStringVerbatimDetokenize{#4}}%
  \makeatother}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Converting detokenized tokens into PDF strings}
%
% At times it will be convenient to convert detokenized tokens into PDF strings, such as bookmarks.  Define macros to escape such detokenized content so that it is in a suitable form.
%
% \begin{macro}{\FVExtraPDFStringEscapeChar}
% Note that this does not apply any special treatment to spaces.  If there are multiple adjacent spaces, then the octal escape \cmd{\040} is needed to prevent them from being merged.  In the detokenization macros where \cmd{\FVExtraPDFStringEscapeChar} is currently used, spaces are processed separately without \cmd{\FVExtraPDFStringEscapeChar}, and literal spaces or \cmd{\040} are inserted in a context-dependent manner.
%    \begin{macrocode}
\def\FVExtraPDFStringEscapeChar#1{%
  \ifcsname FV@PDFStringEscapeChar@#1\endcsname
    \csname FV@PDFStringEscapeChar@#1\endcsname
  \else
    #1%
  \fi}
\begingroup
\catcode`\&=14
\catcode`\%=12&
\catcode`\(=12&
\catcode`\)=12&
\catcode`\^^J=12&
\catcode`\^^M=12&
\catcode`\^^I=12&
\catcode`\^^H=12&
\catcode`\^^L=12&
\catcode`\!=0\relax&
!catcode`!\=12!relax&
!expandafter!gdef!csname FV@PDFStringEscapeChar@\!endcsname{\\}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@%!endcsname{\%}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@(!endcsname{\(}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@)!endcsname{\)}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@^^J!endcsname{\n}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@^^M!endcsname{\r}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@^^I!endcsname{\t}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@^^H!endcsname{\b}&
!expandafter!gdef!csname FV@PDFStringEscapeChar@^^L!endcsname{\f}&
!catcode`!\=0!relax&
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVExtraPDFStringEscapeChars}
%    \begin{macrocode}
\def\FVExtraPDFStringEscapeChars#1{%
  \FV@PDFStringEscapeChars#1\FV@Sentinel}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStringEscapeChars}
%    \begin{macrocode}
\def\FV@PDFStringEscapeChars#1{%
  \ifx#1\FV@Sentinel
  \else
    \FVExtraPDFStringEscapeChar{#1}%
    \expandafter\FV@PDFStringEscapeChars
  \fi}%
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Detokenizing verbatim arguments}
%
% Ensure correct catcodes for this subsection (note |<| and |>| for \cmd{\FV@<Sentinel>}):
%    \begin{macrocode}
\begingroup
\catcode`\ =10
\catcode`\a=11
\catcode`\<=11
\catcode`\>=11
\catcode`\^^C=\active
%    \end{macrocode}
%
%
% \paragraph{Detokenize as if the original source were tokenized verbatim}\hfill\\
%
% \begin{macro}{\FVExtraVerbatimDetokenize}
% Detokenize tokens as if their original source was tokenized verbatim, rather than under any other catcode regime that may actually have been in place.  This recovers the original source when tokenization was verbatim.  Otherwise, it recovers the closest approximation of the source that is possible given information loss during tokenization (for example, adjacent space characters may be merged into a single space token).  This is useful in constructing nearly verbatim commands that can be used inside other commands.  It functions in an expansion-only context (``fully expandable,'' works in \cmd{\edef}).
%
% This yields spaces with catcode 12, \emph{not} spaces with catcode 10 like \cmd{\detokenize}.  Spaces with catcode 10 require special handling when being read by macros, so detokenizing them to catcode 10 makes further processing difficult.  Spaces with catcode 12 may be used just like any other catcode 12 token.
%
% This requires that the \cmd{\active} end-of-text (ETX) |^^C| (U+0003) not be defined as \cmd{\outer}, since |^^C| is used as a sentinel.  Usually, it should not be defined at all, or defined to an error sequence.  When in doubt, it may be worth explicitly defining |^^C| before using \cmd{\FVExtraVerbatimDetokenize}:
% \begin{quote}
%\begin{verbatim}
%\begingroup
%\catcode`\^^C=\active
%\def^^C{}
%...
%\FVExtraVerbatimDetokenize{...}
%...
%\endgroup
%\end{verbatim}
% \end{quote}
%
% \cmd{\detokenize} inserts a space after each control word (control sequence with a name composed of catcode 11 tokens, ASCII letters |[a-zA-Z]|).  For example,
% \begin{quote}
% \Verb{\detokenize{\macroA\macroB{}\csname name\endcsname123}}
% \end{quote}
% yields
% \begin{quote}
% \expandafter\Verb\expandafter{\detokenize{\macroA\macroB{}\csname name\endcsname123}}
% \end{quote}
% That is the correct behavior when detokenizing text that will later be retokenized for normal use.  The space prevents the control word from accidentally merging with any letters that follow it immediately, and will be gobbled by the macro when retokenized.  However, the inserted spaces are unwanted in the current context, because
% \begin{quote}
% \Verb{\FVExtraVerbatimDetokenize{\macroA\macroB{}\csname name\endcsname123}}
% \end{quote}
% should yield
% \begin{quote}
% \ttfamily
% \FVExtraVerbatimDetokenize{\macroA\macroB{}\csname name\endcsname123}
% \end{quote}
% Note that the space is visible since it is catcode 12.
%
% Thus, \cmd{\FVExtraVerbatimDetokenize} is essentially a context-sensitive wrapper around \cmd{\detokenize} that removes extraneous space introduced by \cmd{\detokenize}.  It iterates through the tokens, detokenizing them individually and then removing any trailing space inserted by \cmd{\detokenize}.
%    \begin{macrocode}
\gdef\FVExtraVerbatimDetokenize#1{%
  \FV@VDetok@Scan{}#1^^C \FV@<Sentinel>}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@Scan}
% This scans through a token sequence while performing two tasks:
% \begin{enumerate}
% \item Replace all catcode 10 spaces with catcode 12 spaces.
% \item Insert macros that will process groups, after which they will insert yet other macros to process individual tokens.
% \end{enumerate}
% Usage must \emph{always} have the form
% \begin{quote}
% |\FV@VDetok@Scan{}|\meta{tokens}\Verb*|^^C \FV@<Sentinel>|
% \end{quote}
% where |^^C| is \cmd{\active}, the catcode 10 space after |^^C| is mandatory, and \cmd{\FV@<Sentinel>} is a \emph{single}, undefined control word (this is accomplished via catcodes).
% \begin{itemize}
% \item \cmd{\FV@VDetok@Scan} searches for spaces to replace.  After any spaces in \meta{tokens} have been handled, the space in \Verb*|^^C \FV@<Sentinel>| triggers space processing.  When \cmd{\FV@VDetok@Scan} detects the sentinel macro \cmd{\FV@<Sentinel>}, scanning stops.
% \item The |{}| protects the beginning of \meta{tokens}, so that if \meta{tokens} is a group, its braces won't be gobbled.  Later, the inserted |{}| must be stripped so that it does not become part the processed \meta{tokens}.
% \item |^^C| is a convenient separator between \meta{tokens} and the rest of the sentinel sequence.
%     \begin{itemize}
%     \item Since \cmd{\FV@VDetok@Scan} has delimited arguments, a leading catcode 10 space in \meta{tokens} will be preserved automatically.  Preserving a trailing catcode 10 space is much easier if it is immediately adjacent to a non-space character in the sentinel sequence; two adjacent catcode 10 spaces would be difficult to handle with macro pattern matching.  However, the sentinel sequence must contain a catcode 10 space, so the sentinel sequence must contain at least 3 tokens.
%     \item Since |^^C| is not a control word, it does not gobble following spaces.  That makes it much easier to assemble macro arguments that contain a catcode 10 space.  This is useful because the sentinel sequence \Verb*|^^C \FV@<Sentinel>| may have to be inserted into processing multiple times (for example, in recursive handling of groups).
%     \item \cmd{\FVExtraReadVArg} defines |^^C| as \cmd{\outer}, so any verbatim argument read by it is guaranteed not to contain |^^C|.  This is in contrast to \cmd{\active} ASCII symbols and to two-character sequences |<backslash><symbol>| that should be expected in arbitrary verbatim content.  It is a safe sentinel from that perspective.
%     \item A search of a complete TeX Live 2018 installation revealed no other uses of |^^C| that would clash (thanks, |ripgrep|!).  As a control character, it should not be in common use except as a sentinel or for similar special purposes.
%     \end{itemize}
% \end{itemize}
%
% If \meta{tokens} is empty or contains no spaces, then |#1| will contain |{}|\meta{tokens}|^^C| and |#2| will be empty.  Otherwise, |#1| will contain |{}|\meta{tokens\_to\_space} and |#2| will contain \meta{tokens\_after\_space}\Verb*|^^C |.
%
% This uses the |\if\relax\detokenize{|\meta{argument}|}\relax| approach to check for an empty argument.  If |#2| is empty, then the space that was just removed by \cmd{\FV@VDetok@Scan} reading its arguments was the space in the sentinel sequence, in which case scanning should end.  |#1| is passed on raw so that \cmd{\FV@VDetok@ScanEnd} can strip the |^^C| from the end, which is the only remaining token from the sentinel sequence \Verb*|^^C \FV@<Sentinel>|.  Otherwise, if |#2| is not empty, continue.  In that case, the braces in |{#1}{#2}| ensure arguments remain intact.
%
% Note that \cmd{\FV@<Sentinel>} is removed during each space search, and thus must be reinserted in \cmd{\FV@VDetok@ScanCont}.  It would be possible to use the macro signature |#1 #2| instead of |#1 #2\FV@<Sentinel>|, and then do an \cmd{\ifx} test on |#2| for \cmd{\FV@<Sentinel>}.  However, that is problematic, because |#2| may contain an arbitrary sequence of arbitrary tokens, so it cannot be used safely without \cmd{\detokenize}.
%    \begin{macrocode}
\gdef\FV@VDetok@Scan#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@VDetok@ScanEnd#1}%
  {\FV@VDetok@ScanCont{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanEnd}
% This removes the |^^C| from the sentinel sequence \Verb*|^^C \FV@<Sentinel>|, so the sentinel sequence is now completely gone.  If |#1| is empty, there is nothing to do (|#1| being empty means that |#1| consumed the |{}| that was inserted to protect anything following, because there was nothing after it).  Otherwise, \cmd{\@gobble} the inserted |{}| before starting a different scan to deal with groups.  The group scanner \cmd{\FV@VDetok@ScanGroup} has its own sentinel sequence |{\FV@<Sentinel>}|.
%    \begin{macrocode}
\gdef\FV@VDetok@ScanEnd#1^^C{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@VDetok@ScanGroup\@gobble#1{\FV@<Sentinel>}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanCont}
% Continue scanning after removing a space in \cmd{\FV@VDetok@Scan}.
%
% |#1| is everything before the space.  If |#1| is empty, there is nothing to do related to it; |#1| simply consumed an inserted |{}| that preceded nothing (that would be a leading space).  Otherwise, start a different scan on |#1| to deal with groups.  A non-empty |#1| will start with the |{}| that was inserted to protect groups, hence the \cmd{\@gobble} before group scanning.
%
% Then insert a literal catcode 12 space to account for the space removed in \cmd{\FV@VDetok@Scan}.  Note the catcode, and thus the lack of indentation and the |%| to avoid unwanted catcode 12 spaces.
%
% |#2| is everything after the space, ending with \Verb*|^^C | from the sentinel sequence \Verb*|^^C \FV@<Sentinel>|.  This needs continued scanning to deal with spaces, with |{}| inserted in front to protect a leading group and \cmd{\FV@<Sentinel>} after to complete the sentinel sequence.
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@VDetok@ScanCont#1#2{%
\if\relax\detokenize{#1}\relax%
\expandafter\@gobble%
\else%
\expandafter\@firstofone%
\fi%
{\expandafter\FV@VDetok@ScanGroup\@gobble#1{\FV@<Sentinel>}}%
 %<-catcode 12 space
\FV@VDetok@Scan{}#2\FV@<Sentinel>}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanGroup}
% The macro argument |#1#| reads up to the next group.  When this macro is invoked, the sentinel sequence |{\FV@<Sentinel>}| is inserted, so there is guaranteed to be at least one group.
%
% Everything in |#1| contains no spaces and no groups, and thus is ready for token scanning, with the sentinel \cmd{\FV@Sentinel}.  Note that \cmd{\FV@Sentinel}, which is defined as |\def\FV@Sentinel{\FV@<Sentinel>}|, is used here, \emph{not} \cmd{\FV@<Sentinel>}.  \cmd{\FV@<Sentinel>} is not defined and is thus unsuitable for \cmd{\ifx} comparisons with tokens that may have been tokenized under an incorrect catcode regime and thus are undefined.  \cmd{\FV@Sentinel} \emph{is} defined, and its definition is resistant against accidental collisions.
%    \begin{macrocode}
\gdef\FV@VDetok@ScanGroup#1#{%
  \FV@VDetok@ScanToken#1\FV@Sentinel
  \FV@VDetok@ScanGroup@i}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanGroup@i}
% The braces from the group are stripped during reading |#1|.  Proceed based on whether the group is empty.  If the group is not empty, |{}| must be inserted to protect |#1| in case it is a group, and the new sentinel sequence |\FV@<Sentinel>^^C| is added for the group contents.  \cmd{\FV@<Sentinel>} cannot be used as a sentinel for the group contents, because if this is the sentinel group |{\FV@<Sentinel>}|, then |#1| is \cmd{\FV@<Sentinel>}.
%    \begin{macrocode}
\gdef\FV@VDetok@ScanGroup@i#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@VDetok@ScanEmptyGroup}%
  {\FV@VDetok@ScanGroup@ii{}#1\FV@<Sentinel>^^C}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanEmptyGroup}
% Insert |{}| to handle the empty group, then continue group scanning.
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@VDetok@ScanEmptyGroup({}\FV@VDetok@ScanGroup)
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanGroup@ii}
% The group is not empty, so determine whether it contains \cmd{\FV@<Sentinel>} and thus is the sentinel group.  The group contents are followed by the sentinel sequence |\FV@<Sentinel>^^C| inserted in \cmd{\FV@VDetok@ScanGroup@i}.  This means that if |#2| is empty, the group did not contain \cmd{\FV@<Sentinel>} and thus is not the sentinel group.  Otherwise, |#2| will be \cmd{\FV@<Sentinel>}.
%
% If this is not the sentinel group, then the group contents must be scanned, with surrounding literal braces inserted.  |#1| already contains an inserted leading |{}| to protect groups; see \cmd{\FV@VDetok@ScanGroup@i}.  A sentinel sequence \Verb*|^^C \FV@<Sentinel>| is needed, though.  Then group scanning must continue.
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@VDetok@ScanGroup@ii#1\FV@<Sentinel>#2^^C(%
  \if\relax\detokenize(#2)\relax
    \expandafter\@firstofone
  \else
    \expandafter\@gobble
  \fi
  ({\FV@VDetok@Scan#1^^C \FV@<Sentinel>}\FV@VDetok@ScanGroup))
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanToken}
% Scan individual tokens.  At this point, all spaces and groups have been handled, so this will only ever encounter individual tokens that can be iterated with a |#1| argument.  The sentinel for token scanning is \cmd{\FV@Sentinel}.  This is the appropriate sentinel because \cmd{\ifx} comparisons are now safe (individual tokens) and \cmd{\FV@Sentinel} is defined.  Processing individual detokenized tokens requires the same sentinel sequence as handling spaces, since it can produce them.
%    \begin{macrocode}
\gdef\FV@VDetok@ScanToken#1{%
  \ifx\FV@Sentinel#1%
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@VDetok@ScanToken@i\detokenize{#1}^^C \FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanToken@i}
% If |#2| is empty, then there are no spaces in the detokenized token, so it is either an \cmd{\active} character other than the space, or a two-character sequence of the form |<backslash><symbol>| where the second character is not a space.  Thus, |#1| contains \meta{detokenized}|^^C|.  Otherwise, |#1| contains \meta{detokenized\_without\_space}, and |#2| may be discarded since it contains \Verb*|^^C \FV@<Sentinel>|.  (If the detokenized token contains a space, it is always at the end.)
%    \begin{macrocode}
\gdef\FV@VDetok@ScanToken@i#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@VDetok@ScanTokenNoSpace#1}%
  {\FV@VDetok@ScanTokenWithSpace{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanTokenNoSpace}
% Strip |^^C| sentinel in reading, then insert character(s) and continue scanning.
%    \begin{macrocode}
\gdef\FV@VDetok@ScanTokenNoSpace#1^^C{#1\FV@VDetok@ScanToken}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanTokenWithSpace}
% Handle a token that when detokenized produces a space.  If there is nothing left once the space is removed, this is the \cmd{\active} space.  Otherwise, process further.
%    \begin{macrocode}
\gdef\FV@VDetok@ScanTokenWithSpace#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@VDetok@ScanTokenActiveSpace}%
  {\FV@VDetok@ScanTokenWithSpace@i#1\FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanTokenActiveSpace}
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@VDetok@ScanTokenActiveSpace{ \FV@VDetok@ScanToken}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanTokenWithSpace@i}
% If there is only one character left once the space is removed, this is the escaped space \Verb*|\ |.  Otherwise, this is a command word that needs further processing.
%    \begin{macrocode}
\gdef\FV@VDetok@ScanTokenWithSpace@i#1#2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@VDetok@ScanTokenEscSpace{#1}}%
  {\FV@VDetok@ScanTokenCW{#1#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanTokenEscSpace}
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@VDetok@ScanTokenEscSpace#1{#1 \FV@VDetok@ScanToken}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@VDetok@ScanTokenCW}
% Process control words in a context-sensitive manner by looking ahead to the next token (|#2|).  The lookahead must be reinserted into processing, hence the |\FV@VDetok@ScanToken#2|.
%
% A control word will detokenize to a sequence of characters followed by a space.  If the following token has catcode 11, then this space represents one or more space characters that must have been present in the original source, because otherwise the catcode 11 token would have become part of the control word's name.  If the following token has another catcode, then it is impossible to determine whether a space was present, so assume that one was not.
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@VDetok@ScanTokenCW#1#2{%
\ifcat\noexpand#2a%
\expandafter\@firstoftwo%
\else%
\expandafter\@secondoftwo%
\fi%
{#1 \FV@VDetok@ScanToken#2}%
{#1\FV@VDetok@ScanToken#2}}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Detokenize as if the original source were tokenized verbatim, then convert to PDF string}\hfill\\
%
% \begin{macro}{\FVExtraPDFStringVerbatimDetokenize}
% This is identical to \cmd{\FVExtraVerbatimDetokenize}, except that the output is converted to a valid PDF string.  Some spaces are represented with the octal escape \cmd{\040} to prevent adjacent spaces from being merged.
%    \begin{macrocode}
\gdef\FVExtraPDFStringVerbatimDetokenize#1{%
  \FV@PDFStrVDetok@Scan{}#1^^C \FV@<Sentinel>}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@Scan}
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@Scan#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrVDetok@ScanEnd#1}%
  {\FV@PDFStrVDetok@ScanCont{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanEnd}
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanEnd#1^^C{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@PDFStrVDetok@ScanGroup\@gobble#1{\FV@<Sentinel>}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanCont}
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@PDFStrVDetok@ScanCont#1#2{%
\if\relax\detokenize{#1}\relax%
\expandafter\@gobble%
\else%
\expandafter\@firstofone%
\fi%
{\expandafter\FV@PDFStrVDetok@ScanGroup\@gobble#1{\FV@<Sentinel>}}%
 %<-catcode 12 space
\FV@PDFStrVDetok@Scan{}#2\FV@<Sentinel>}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanGroup}
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanGroup#1#{%
  \FV@PDFStrVDetok@ScanToken#1\FV@Sentinel
  \FV@PDFStrVDetok@ScanGroup@i}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanGroup@i}
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanGroup@i#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrVDetok@ScanEmptyGroup}%
  {\FV@PDFStrVDetok@ScanGroup@ii{}#1\FV@<Sentinel>^^C}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanEmptyGroup}
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@PDFStrVDetok@ScanEmptyGroup({}\FV@PDFStrVDetok@ScanGroup)
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanGroup@ii}
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@PDFStrVDetok@ScanGroup@ii#1\FV@<Sentinel>#2^^C(%
  \if\relax\detokenize(#2)\relax
    \expandafter\@firstofone
  \else
    \expandafter\@gobble
  \fi
  ({\FV@PDFStrVDetok@Scan#1^^C \FV@<Sentinel>}\FV@PDFStrVDetok@ScanGroup))
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanToken}
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanToken#1{%
  \ifx\FV@Sentinel#1%
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@PDFStrVDetok@ScanToken@i\detokenize{#1}^^C \FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanToken@i}
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanToken@i#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrVDetok@ScanTokenNoSpace#1}%
  {\FV@PDFStrVDetok@ScanTokenWithSpace{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanTokenNoSpace}
% This is modified to use \cmd{\FVExtraPDFStringEscapeChars}.
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanTokenNoSpace#1^^C{%
  \FVExtraPDFStringEscapeChars{#1}\FV@PDFStrVDetok@ScanToken}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanTokenWithSpace}
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanTokenWithSpace#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrVDetok@ScanTokenActiveSpace}%
  {\FV@PDFStrVDetok@ScanTokenWithSpace@i#1\FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanTokenActiveSpace}
% This is modified to use \cmd{\040} rather than a catcode 12 space.
%    \begin{macrocode}
\begingroup
\catcode`\!=0\relax
\catcode`\\=12!relax
!gdef!FV@PDFStrVDetok@ScanTokenActiveSpace{\040!FV@PDFStrVDetok@ScanToken}%
!catcode`!\=0!relax
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanTokenWithSpace@i}
% If there is only one character left once the space is removed, this is the escaped space \Verb*|\ |.  Otherwise, this is a command word that needs further processing.
%    \begin{macrocode}
\gdef\FV@PDFStrVDetok@ScanTokenWithSpace@i#1#2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrVDetok@ScanTokenEscSpace{#1}}%
  {\FV@PDFStrVDetok@ScanTokenCW{#1#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanTokenEscSpace}
% This is modified to add \cmd{\FVExtraPDFStringEscapeChar} and use |\040| for the space, since a space could follow.
%    \begin{macrocode}
\begingroup
\catcode`\!=0\relax
\catcode`\\=12!relax
!gdef!FV@PDFStrVDetok@ScanTokenEscSpace#1{%
  !FVExtraPDFStringEscapeChar{#1}\040!FV@PDFStrVDetok@ScanToken}%
!catcode`!\=0!relax
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrVDetok@ScanTokenCW}
% This is modified to add \cmd{\FVExtraPDFStringEscapeChars}.
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@PDFStrVDetok@ScanTokenCW#1#2{%
\ifcat\noexpand#2a%
\expandafter\@firstoftwo%
\else%
\expandafter\@secondoftwo%
\fi%
{\FVExtraPDFStringEscapeChars{#1} \FV@PDFStrVDetok@ScanToken#2}%
{\FVExtraPDFStringEscapeChars{#1}\FV@PDFStrVDetok@ScanToken#2}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Detokenize as if the original source were tokenized verbatim, except for backslash escapes of non-catcode 11 characters}\hfill
%
% \begin{macro}{\FVExtraEscapedVerbatimDetokenize}
% This is a variant of \cmd{\FVExtraVerbatimDetokenize} that treats character sequences of the form |\<char>| as escapes for |<char>|.  It is primarily intended for making |\<symbol>| escapes for |<symbol>|, but allowing arbitrary escapes simplifies the default behavior and implementation.  This is useful in constructing nearly verbatim commands that can be used inside other commands, because the backslash escapes allow for characters like |#| and |%|, as well as making possible multiple adjacent spaces via \Verb*|\ |.  It should be applied to arguments that are read verbatim insofar as is possible, except that the backslash |\| should have its normal meaning (catcode 0).  Most of the implementation is identical to that for \cmd{\FVExtraVerbatimDetokenize}.  Only the token processing requires modification to handle backslash escapes.
%
% It is possible to restrict escapes to ASCII symbols and punctuation.  See \cmd{\FVExtraDetokenizeREscVArg}.  The disadvantage of restricting escapes is that it prevents functioning in an expansion-only context (unless you want to use undefined macros as a means of raising errors).  The advantage is that it eliminates ambiguity introduced by allowing arbitrary escapes. Backslash escapes of characters with catcode 11 (ASCII letters, |[A-Za-z]|) are typically not necessary, and introduce ambiguity because something like |\x| will gobble following spaces since it will be tokenized originally as a control word.
%    \begin{macrocode}
\gdef\FVExtraEscapedVerbatimDetokenize#1{%
  \FV@EscVDetok@Scan{}#1^^C \FV@<Sentinel>}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@Scan}
%    \begin{macrocode}
\gdef\FV@EscVDetok@Scan#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@EscVDetok@ScanEnd#1}%
  {\FV@EscVDetok@ScanCont{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanEnd}
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanEnd#1^^C{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@EscVDetok@ScanGroup\@gobble#1{\FV@<Sentinel>}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanCont}
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@EscVDetok@ScanCont#1#2{%
\if\relax\detokenize{#1}\relax%
\expandafter\@gobble%
\else%
\expandafter\@firstofone%
\fi%
{\expandafter\FV@EscVDetok@ScanGroup\@gobble#1{\FV@<Sentinel>}}%
 %<-catcode 12 space
\FV@EscVDetok@Scan{}#2\FV@<Sentinel>}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanGroup}
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanGroup#1#{%
  \FV@EscVDetok@ScanToken#1\FV@Sentinel
  \FV@EscVDetok@ScanGroup@i}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanGroup@i}
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanGroup@i#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@EscVDetok@ScanEmptyGroup}%
  {\FV@EscVDetok@ScanGroup@ii{}#1\FV@<Sentinel>^^C}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanEmptyGroup}
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@EscVDetok@ScanEmptyGroup({}\FV@EscVDetok@ScanGroup)
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanGroup@ii}
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@EscVDetok@ScanGroup@ii#1\FV@<Sentinel>#2^^C(%
  \if\relax\detokenize(#2)\relax
    \expandafter\@firstofone
  \else
    \expandafter\@gobble
  \fi
  ({\FV@EscVDetok@Scan#1^^C \FV@<Sentinel>}\FV@EscVDetok@ScanGroup))
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanToken}
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanToken#1{%
  \ifx\FV@Sentinel#1%
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@EscVDetok@ScanToken@i\detokenize{#1}^^C \FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanToken@i}
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanToken@i#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@EscVDetok@ScanTokenNoSpace#1}%
  {\FV@EscVDetok@ScanTokenWithSpace{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \subparagraph{Parallel implementations, with a restricted option}
% Starting here, there are alternate macros for restricting escapes to ASCII punctuation and symbols.  These alternates have names of the form \cmd{\FV@REscVDetok@<name>}.  They are used in \cmd{\FVExtraDetokenizeREscVArg}.  The alternate \cmd{\FV@REscVDetok@<name>} macros replace invalid escape sequences with the undefined \cmd{\FV@<InvalidEscape>}, which is later scanned for with a delimited macro.
%
% \begin{macro}{\FV@EscVDetok@ScanTokenNoSpace}
% This was modified from \cmd{\FV@VDetok@ScanTokenNoSpace} to discard the first character of multi-character sequences (that would be the backslash |\|).
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanTokenNoSpace#1#2^^C{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {#1\FV@EscVDetok@ScanToken}%
  {#2\FV@EscVDetok@ScanToken}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@REscVDetok@ScanTokenNoSpace}
%    \begin{macrocode}
\gdef\FV@REscVDetok@ScanTokenNoSpace#1#2^^C{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {#1\FV@EscVDetok@ScanToken}%
  {\ifcsname FV@Char@Special:\number`#2\endcsname#2\else\noexpand\FV@<InvalidEscape>\fi
   \FV@EscVDetok@ScanToken}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@EscVDetok@ScanTokenWithSpace}
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanTokenWithSpace#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@EscVDetok@ScanTokenActiveSpace}%
  {\FV@EscVDetok@ScanTokenWithSpace@i#1\FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanTokenActiveSpace}
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@EscVDetok@ScanTokenActiveSpace{ \FV@EscVDetok@ScanToken}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanTokenWithSpace@i}
% If there is only one character left once the space is removed, this is the escaped space \Verb*|\ |.  Otherwise, this is a command word.  A command word is passed on so as to keep the backslash and letters separate.
%    \begin{macrocode}
\gdef\FV@EscVDetok@ScanTokenWithSpace@i#1#2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@EscVDetok@ScanTokenEscSpace{#1}}%
  {\FV@EscVDetok@ScanTokenCW{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@REscVDetok@ScanTokenWithSpace@i}
%    \begin{macrocode}
\gdef\FV@REscVDetok@ScanTokenWithSpace@i#1#2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@EscVDetok@ScanTokenEscSpace{#1}}%
  {\noexpand\FV@<InvalidEscape>\FV@EscVDetok@ScanToken}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanTokenEscSpace}
% This is modified to drop |#1|, which will be the backslash.
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@EscVDetok@ScanTokenEscSpace#1{ \FV@EscVDetok@ScanToken}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EscVDetok@ScanTokenCW}
% This is modified to accept an additional argument, since the control word is now split into backslash plus letters.
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@EscVDetok@ScanTokenCW#1#2#3{%
\ifcat\noexpand#2a%
\expandafter\@firstoftwo%
\else%
\expandafter\@secondoftwo%
\fi%
{#2 \FV@EscVDetok@ScanToken#3}%
{#2\FV@EscVDetok@ScanToken#3}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Detokenize as if the original source were tokenized verbatim, except for backslash escapes of non-catcode 11 characters, then convert to PDF string}\hfill\\
%
% \begin{macro}{\FVExtraPDFStringEscapedVerbatimDetokenize}
% This is identical to \cmd{\FVExtraEscapedVerbatimDetokenize}, except that the output is converted to a valid PDF string.  All spaces are represented with the octal escape \cmd{\040} to prevent adjacent spaces from being merged.  There is no alternate implementation for restricting escapes to ASCII symbols and punctuation.  Typically, this would be used in an expansion-only context to create something like bookmarks, while \cmd{\FVExtraEscapedVerbatimDetokenize} (potentially with escape restrictions) would be used in parallel to generate whatever is actually typeset.  Escape errors can be handled in generating what is typeset.
%    \begin{macrocode}
\gdef\FVExtraPDFStringEscapedVerbatimDetokenize#1{%
  \FV@PDFStrEscVDetok@Scan{}#1^^C \FV@<Sentinel>}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@Scan}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@Scan#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrEscVDetok@ScanEnd#1}%
  {\FV@PDFStrEscVDetok@ScanCont{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanEnd}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanEnd#1^^C{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@PDFStrEscVDetok@ScanGroup\@gobble#1{\FV@<Sentinel>}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanCont}
% This is modified to use |\040| for the space.  In the unescaped case, using a normal space here is fine, but in the escaped case, the preceding or following token could be an escaped space.
%    \begin{macrocode}
\begingroup
\catcode`\!=0\relax
\catcode`\\=12!relax
!gdef!FV@PDFStrEscVDetok@ScanCont#1#2{%
  !if!relax!detokenize{#1}!relax
    !expandafter!@gobble
  !else
    !expandafter!@firstofone
  !fi
  {!expandafter!FV@PDFStrEscVDetok@ScanGroup!@gobble#1{!FV@<Sentinel>}}%
  \040%<-space
  !FV@PDFStrEscVDetok@Scan{}#2!FV@<Sentinel>}%
!catcode`!\=0!relax
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanGroup}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanGroup#1#{%
  \FV@PDFStrEscVDetok@ScanToken#1\FV@Sentinel
  \FV@PDFStrEscVDetok@ScanGroup@i}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanGroup@i}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanGroup@i#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrEscVDetok@ScanEmptyGroup}%
  {\FV@PDFStrEscVDetok@ScanGroup@ii{}#1\FV@<Sentinel>^^C}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanEmptyGroup}
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@PDFStrEscVDetok@ScanEmptyGroup({}\FV@PDFStrEscVDetok@ScanGroup)
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanGroup@ii}
%    \begin{macrocode}
\begingroup
\catcode`\(=1
\catcode`\)=2
\catcode`\{=12
\catcode`\}=12
\gdef\FV@PDFStrEscVDetok@ScanGroup@ii#1\FV@<Sentinel>#2^^C(%
  \if\relax\detokenize(#2)\relax
    \expandafter\@firstofone
  \else
    \expandafter\@gobble
  \fi
  ({\FV@PDFStrEscVDetok@Scan#1^^C \FV@<Sentinel>}\FV@PDFStrEscVDetok@ScanGroup))
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanToken}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanToken#1{%
  \ifx\FV@Sentinel#1%
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\FV@PDFStrEscVDetok@ScanToken@i\detokenize{#1}^^C \FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanToken@i}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanToken@i#1 #2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrEscVDetok@ScanTokenNoSpace#1}%
  {\FV@PDFStrEscVDetok@ScanTokenWithSpace{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanTokenNoSpace}
% This was modified to add \cmd{\FVExtraPDFStringEscapeChar}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanTokenNoSpace#1#2^^C{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FVExtraPDFStringEscapeChar{#1}\FV@PDFStrEscVDetok@ScanToken}%
  {\FVExtraPDFStringEscapeChar{#2}\FV@PDFStrEscVDetok@ScanToken}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanTokenWithSpace}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanTokenWithSpace#1{%
  \if\relax\detokenize{#1}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrEscVDetok@ScanTokenActiveSpace}%
  {\FV@PDFStrEscVDetok@ScanTokenWithSpace@i#1\FV@<Sentinel>}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanTokenActiveSpace}
% This is modified to use |\040| for the space.
%    \begin{macrocode}
\begingroup
\catcode`\!=0\relax
\catcode`\\=12!relax
!gdef!FV@PDFStrEscVDetok@ScanTokenActiveSpace{\040!FV@PDFStrEscVDetok@ScanToken}%
!catcode`!\=0!relax
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanTokenWithSpace@i}
%    \begin{macrocode}
\gdef\FV@PDFStrEscVDetok@ScanTokenWithSpace@i#1#2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {\FV@PDFStrEscVDetok@ScanTokenEscSpace{#1}}%
  {\FV@PDFStrEscVDetok@ScanTokenCW{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanTokenEscSpace}
% This is modified to drop |#1|, which will be the backslash, and use |\040| for the space.
%    \begin{macrocode}
\begingroup
\catcode`\!=0\relax
\catcode`\\=12!relax
!gdef!FV@PDFStrEscVDetok@ScanTokenEscSpace#1{\040!FV@PDFStrEscVDetok@ScanToken}
!catcode`!\=0!relax
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@PDFStrEscVDetok@ScanTokenCW}
% This is modified to use \cmd{\FVExtraPDFStringEscapeChars}.
%    \begin{macrocode}
\begingroup
\catcode`\ =12%
\gdef\FV@PDFStrEscVDetok@ScanTokenCW#1#2#3{%
\ifcat\noexpand#2a%
\expandafter\@firstoftwo%
\else%
\expandafter\@secondoftwo%
\fi%
{\FVExtraPDFStringEscapeChars{#2} \FV@PDFStrEscVDetok@ScanToken#3}%
{\FVExtraPDFStringEscapeChars{#2}\FV@PDFStrEscVDetok@ScanToken#3}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \paragraph{Detokenization wrappers}\hfill\\
%
% \begin{macro}{\FVExtraDetokenizeVArg}
% Detokenize a verbatim argument read by \cmd{\FVExtraReadVArg}.  This is a wrapper around \cmd{\FVExtraVerbatimDetokenize} that adds some additional safety by ensuring |^^C| is \cmd{\active} with an appropriate definition, at the cost of not working in an expansion-only context.  This tradeoff isn't an issue when working with \cmd{\FVExtraReadVArg}, because it has the same expansion limitations.
%    \begin{macrocode}
\gdef\FVExtraDetokenizeVArg#1#2{%
  \begingroup
  \catcode`\^^C=\active
  \let^^C\FV@Sentinel
  \edef\FV@Tmp{\FVExtraVerbatimDetokenize{#2}}%
  \expandafter\FV@DetokenizeVArg@i\expandafter{\FV@Tmp}{#1}}
\gdef\FV@DetokenizeVArg@i#1#2{%
  \endgroup
  #2{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVExtraDetokenizeEscVArg}
% This is the same as \cmd{\FVExtraDetokenizeVArg}, except it is intended to work with \cmd{\FVExtraReadEscVArg} by using \cmd{\FVExtraEscapedVerbatimDetokenize}.
%    \begin{macrocode}
\gdef\FVExtraDetokenizeEscVArg#1#2{%
  \begingroup
  \catcode`\^^C=\active
  \let^^C\FV@Sentinel
  \edef\FV@Tmp{\FVExtraEscapedVerbatimDetokenize{#2}}%
  \expandafter\FV@DetokenizeVArg@i\expandafter{\FV@Tmp}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVExtraDetokenizeREscVArg}
%    \begin{macrocode}
\gdef\FVExtraDetokenizeREscVArg#1#2{%
  \begingroup
  \catcode`\^^C=\active
  \let^^C\FV@Sentinel
  \let\FV@EscVDetok@ScanTokenNoSpace\FV@REscVDetok@ScanTokenNoSpace
  \let\FV@EscVDetok@ScanTokenWithSpace@i\FV@REscVDetok@ScanTokenWithSpace@i
  \edef\FV@Tmp{\FVExtraEscapedVerbatimDetokenize{#2}}%
  \expandafter\FV@DetokenizeREscVArg@InvalidEscapeCheck\FV@Tmp\FV@<InvalidEscape>\FV@<Sentinel>
  \expandafter\FV@DetokenizeVArg@i\expandafter{\FV@Tmp}{#1}}
\gdef\FV@DetokenizeREscVArg@InvalidEscapeCheck#1\FV@<InvalidEscape>#2\FV@<Sentinel>{%
  \if\relax\detokenize{#2}\relax
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\PackageError{fvextra}%
   {Invalid backslash escape; only escape ASCII symbols and punctuation}%
   {Only use \@backslashchar <char> for ASCII symbols and punctuation}}}
%    \end{macrocode}
% \end{macro}
%
% End catcodes for this subsection:
%    \begin{macrocode}
\endgroup
%    \end{macrocode}
%
%
%
%
% \subsubsection{Retokenizing detokenized arguments}
%
% \begin{macro}{\FV@RetokVArg@Read}
% Read all tokens up to \cmd{\active} |^^C^^M|, then save them in a macro for further use.  This is used to read tokens inside \cmd{\scantokens} during retokenization.  The \cmd{\endgroup} disables catcode modifications that will have been put in place for the reading process, including making |^^C| and |^^M| \cmd{\active}.
%    \begin{macrocode}
\begingroup
\catcode`\^^C=\active%
\catcode`\^^M=\active%
\gdef\FV@RetokVArg@Read#1^^C^^M{%
  \endgroup%
  \def\FV@TmpRetoked{#1}}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVExtraRetokenizeVArg}
% This retokenizes the detokenized output of something like \cmd{\FVExtraVerbatimDetokenize} or \cmd{\FVExtraDetokenizeVArg}.  |#1| is a macro that receives the output, |#2| sets catcodes but includes no \cmd{\begingroup} or \cmd{\endgroup}, and |#3| is the detokenized characters.  \cmd{\FV@RetokVArg@Read} contains an \cmd{\endgroup} that returns catcodes to their prior state.
%
% This is a somewhat atypical use of \cmd{\scantokens}.  There is no |\everyeof{\noexpand}| to handle the end-of-file marker, and no |\endlinechar=-1|  to ignore the end-of-line token so that it does not become a space.  Rather, the end-of-line |^^M| is made \cmd{\active} and used as a delimiter by \cmd{\FV@RetokVArg@Read}, which reads characters under the new catcode regime, then stores them unexpanded in \cmd{\FV@TmpRetoked}.
%
% Inside \cmd{\scantokens} is |^^B#3^^C|.  This becomes |^^B#3^^C^^M| once \cmd{\scantokens} inserts the end-of-line token.  |^^B| is \cmd{\let} to \cmd{\FV@RetokVArg@Read}, rather than using \cmd{\FV@RetokVArg@Read} directly, because \cmd{\scantokens} acts as a \cmd{\write} followed by \cmd{\input}.  That means that a command word like \cmd{\FV@RetokVArg@Read} will have a space inserted after it, while an \cmd{\active} character like |^^B| will not.  Using |^^B| is a way to avoid needing to remove this space; it is simpler not to handle the scenario where \cmd{\FV@RetokVArg@Read} introduces a space and the detokenized characters also start with a space.  The |^^C| is needed because trailing spaces on a line are automatically stripped, so a non-space character must be part of the delimiting token sequence.
%    \begin{macrocode}
\begingroup
\catcode`\^^B=\active
\catcode`\^^C=\active
\gdef\FVExtraRetokenizeVArg#1#2#3{%
  \begingroup
  #2%
  \catcode`\^^B=\active
  \catcode`\^^C=\active
  \catcode`\^^M=\active
  \let^^B\FV@RetokVArg@Read
  \let^^C\@empty
  \FV@DefEOLEmpty
  \scantokens{^^B#3^^C}%
  \expandafter\FV@RetokenizeVArg@i\expandafter{\FV@TmpRetoked}{#1}}%
\gdef\FV@RetokenizeVArg@i#1#2{%
  #2{#1}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Hooks}
%
%
% \begin{macro}{\FV@UseKeyValues@Hook}
% This hook is useful for tasks that must be accomplished immediately after the beginning of a command or environment, just after |\begingroup|, before any catcode or similar changes are made.  Hooking into |\FV@CatCodes| is not a straightforward alternative, because it may be invoked multiple times in the original \fancyvrb\ code, plus additional times in \fvextra\ code during retokenization.  Hooking into |\FV@FormattingPrep| is not a reliable alternative, because it may be invoked before or after |\FV@CatCodes|.
%    \begin{macrocode}
\let\FV@UseKeyValues@Hook\@empty
\expandafter\def\expandafter\FV@UseKeyValues\expandafter{%
  \FV@UseKeyValues\FV@UseKeyValues@Hook}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@FormattingPrep@PreHook,\FV@FormattingPrep@PostHook}
% These are hooks for extending |\FV@FormattingPrep|.  |\FV@FormattingPrep| is inside a group, before the beginning of processing, so it is a good place to add extension code.  These hooks are used for such things as tweaking math mode behavior and preparing for |breakbefore| and |breakafter|.  The |PreHook| should typically be used, unless \pkg{fancyvrb}'s font settings, whitespace setup, and active character definitions are needed for extension code.
%    \begin{macrocode}
\let\FV@FormattingPrep@PreHook\@empty
\let\FV@FormattingPrep@PostHook\@empty
\expandafter\def\expandafter\FV@FormattingPrep\expandafter{%
  \expandafter\FV@FormattingPrep@PreHook\FV@FormattingPrep\FV@FormattingPrep@PostHook}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@PygmentsHook}
% This is a hook for turning on Pygments-related features for packages like \pkg{minted} and \pkg{pythontex} (\cref{sec:impl:pygments}).  It needs to be the first thing in |\FV@FormattingPrep@PreHook|, since it will potentially affect some of the later things in the hook.  It is activated by |\VerbatimPygments|.
%    \begin{macrocode}
\def\FV@PygmentsHook{}
\g@addto@macro\FV@FormattingPrep@PreHook{\FV@PygmentsHook}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Escaped characters}
% \begin{macro}{\FV@EscChars}
% Define versions of common escaped characters that reduce to raw characters.  This is useful, for example, when working with text that is almost verbatim, but was captured in such a way that some escapes were unavoidable.
%    \begin{macrocode}
\edef\FV@hashchar{\string#}
\edef\FV@dollarchar{\string$}
\edef\FV@ampchar{\string&}
\edef\FV@underscorechar{\string_}
\edef\FV@caretchar{\string^}
\edef\FV@tildechar{\string~}
\edef\FV@leftsquarebracket{\string[}
\edef\FV@rightsquarebracket{\string]}
\edef\FV@commachar{\string,}
\newcommand{\FV@EscChars}{%
  \let\#\FV@hashchar
  \let\%\@percentchar
  \let\{\@charlb
  \let\}\@charrb
  \let\$\FV@dollarchar
  \let\&\FV@ampchar
  \let\_\FV@underscorechar
  \let\^\FV@caretchar
  \let\\\@backslashchar
  \let~\FV@tildechar
  \let\~\FV@tildechar
  \let\[\FV@leftsquarebracket
  \let\]\FV@rightsquarebracket
  \let\,\FV@commachar
} %$ <- highlighting
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Inline-only options}
%
% Create \cmd{\fvinlineset} for inline-only options.  Note that this only applies to new or reimplemented inline commands that use \cmd{\FV@UseInlineKeyValues}.
% \begin{macro}{\FV@InlineKeyValues}
%    \begin{macrocode}
\def\FV@InlineKeyValues{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fvinlineset}
%    \begin{macrocode}
\def\fvinlineset#1{%
  \expandafter\def\expandafter\FV@InlineKeyValues\expandafter{%
    \FV@InlineKeyValues#1,}}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\FV@UseInlineKeyValues}
%    \begin{macrocode}
\def\FV@UseInlineKeyValues{%
  \expandafter\fvset\expandafter{\FV@InlineKeyValues}%
  \FV@ApplyBreakAnywhereInlineStretch}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Reimplementations}
% \label{sec:impl:reimplementations}
%
% \fvextra\ reimplements some \fancyvrb\ internals.  The patches in \cref{sec:impl:patches} fix bugs, handle edge cases, and extend existing functionality in logical ways, while leaving default \fancyvrb\ behavior largely unchanged.  In contrast, reimplementations add features by changing existing behavior in significant ways.  As a result, there is a boolean option |extra| that allows them to be disabled.
%
%
% \subsubsection{\texttt{extra} option}
% Boolean option that governs whether reimplemented commands and environments should be used, rather than the original definitions.
% \begin{macro}{FV@extra}
%    \begin{macrocode}
\newbool{FV@extra}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{extra}
%    \begin{macrocode}
\define@booleankey{FV}{extra}%
 {\booltrue{FV@extra}}%
 {\boolfalse{FV@extra}}
\fvset{extra=true}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\FancyVerbFormatInline}}
% This allows customization of inline verbatim material.  It is the inline equivalent of \cmd{\FancyVerbFormatLine} and \cmd{\FancyVerbFormatText}.
% \begin{macro}{\FancyVerbFormatInline}
%    \begin{macrocode}
\def\FancyVerbFormatInline#1{#1}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\texttt{\textbackslash Verb}}
%
% \cmd{\Verb} is reimplemented so that it functions as well as possible when used within other commands.
%
% \cmd{\verb} cannot be used inside other commands.  The original \fancyvrb\ implementation of \cmd{\Verb} does work inside other commands, but being inside other commands reduces its functionality since there is no attempt at retokenization.  When used inside other commands, it essentially reduces to \cmd{\texttt}.  \cmd{\Verb} also fails when the delimiting characters are active, since it assumes that the closing delimiting character will have catcode 12.
%
% \fvextra's re-implemented \cmd{\Verb} uses \cmd{\scantokens} and careful consideration of catcodes to (mostly) remedy this.  It also adds support for paired curly braces |{...}| as the delimiters for the verbatim argument, since this is often convenient when \cmd{\Verb} is used within another command.  The original \cmd{\Verb} implementation is completely incompatible with curly braces being used as delimiters, so this doesn't affect backward compatibility.
%
% The re-implemented \cmd{\Verb} is constructed with \cmd{\FVExtraRobustCommand} so that it will function correctly after being in an expansion-only context, so long as the argument is delimited with curly braces.
%
% \begin{macro}{\Verb}
%    \begin{macrocode}
\def\Verb{%
  \FVExtraRobustCommand\RobustVerb\FVExtraUnexpandedReadStarOArgBVArg}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\RobustVerb}
%    \begin{macrocode}
\protected\def\RobustVerb{\FV@Command{}{Verb}}
\FVExtrapdfstringdefDisableCommands{%
  \def\RobustVerb{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@Verb@FV}
% Save the original \fancyvrb\ definition of \cmd{\FVC@Verb}, so that the |extra| option can switch back to it.
%    \begin{macrocode}
\let\FVC@Verb@FV\FVC@Verb
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@Verb}
% Redefine \cmd{\FVC@Verb} so that it will adjust based on |extra|.
%    \begin{macrocode}
\def\FVC@Verb{%
  \begingroup
  \FV@UseInlineKeyValues\FV@UseKeyValues
  \ifFV@extra
    \expandafter\endgroup\expandafter\FVC@Verb@Extra
  \else
    \expandafter\endgroup\expandafter\FVC@Verb@FV
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@Verb@Extra}
% \fvextra\ reimplementation of \cmd{\FVC@Verb}.
%
% When used after expansion, there is a check for valid delimiters, curly braces.  If incorrect delimiters are used, and there are no following curly braces, then the reader macro \cmd{\FVExtraUnexpandedReadStarOArgBVArg} will give an error about unmatched braces.  However, if incorrect delimiters are used, and there \emph{are} following braces in a subsequent command, then this error will be triggered, preventing interference with the following command by the reader macro.
%    \begin{macrocode}
\def\FVC@Verb@Extra{%
  \ifbool{FVExtraRobustCommandExpanded}%
   {\@ifnextchar\bgroup
     {\FVC@Verb@Extra@i}%
     {\PackageError{fvextra}%
       {\string\Verb\space delimiters must be paired curly braces in this context}%
       {Use curly braces as delimiters}}}%
   {\FVC@Verb@Extra@i}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@Verb@Extra@i}
%    \begin{macrocode}
\def\FVC@Verb@Extra@i{%
  \begingroup
  \ifbool{FV@vargsingleline}%
   {\let\FV@Reader\FVExtraReadVArgSingleLine}%
   {\let\FV@Reader\FVExtraReadVArg}%
  \FV@Reader{%
    \FV@UseInlineKeyValues\FV@UseKeyValues\FV@FormattingPrep
    \FVExtraDetokenizeVArg{%
      \FVExtraRetokenizeVArg{\FVC@Verb@Extra@ii}{\FV@CatCodes}}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@Verb@Extra@ii}
% |breaklines| is only applied when there is no background color, since |\colorbox| prevents line breaks.
%    \begin{macrocode}
\def\FVC@Verb@Extra@ii#1{%
  \ifx\FancyVerbBackgroundColor\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
   {\ifbool{FV@breaklines}%
    {\FV@InsertBreaks{\FancyVerbFormatInline}{#1}}%
    {\mbox{\FancyVerbFormatInline{#1}}}}%
   {\setlength{\FV@TmpLength}{\fboxsep}%
    \ifx\FancyVerbBackgroundColorPadding\relax
      \setlength{\fboxsep}{0pt}%
    \else
      \setlength{\fboxsep}{\FancyVerbBackgroundColorPadding}%
    \fi
    \colorbox{\FancyVerbBackgroundColor}{%
      \setlength{\fboxsep}{\FV@TmpLength}%
      \FancyVerbBackgroundColorVPhantom\FancyVerbFormatInline{#1}}}%
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\SaveVerb}}
%
% This is reimplemented, following \cmd{\Verb} as a template, so that both \cmd{\Verb} and \cmd{\SaveVerb} are using the same reading and tokenization macros.  This also adds support for \cmd{\fvinlineset}.  Since the definition in \fancyvrb\ is
%\begin{verbatim}
%\def\SaveVerb{\FV@Command{}{SaveVerb}}
%\end{verbatim}
% only the internal macros need to be reimplemented.
%
% \begin{macro}{\FVC@SaveVerb@FV}
%    \begin{macrocode}
\let\FVC@SaveVerb@FV\FVC@SaveVerb
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@SaveVerb}
%    \begin{macrocode}
\def\FVC@SaveVerb{%
  \begingroup
  \FV@UseInlineKeyValues\FV@UseKeyValues
  \ifFV@extra
    \expandafter\endgroup\expandafter\FVC@SaveVerb@Extra
  \else
    \expandafter\endgroup\expandafter\FVC@SaveVerb@FV
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@SaveVerb@Extra}
% In addition to following the \cmd{\Verb} implementation, this saves a raw version of the text to allow |retokenize| with \cmd{\UseVerb}.  The raw version is also used for conversion to a PDF string if that is needed.
%    \begin{macrocode}
\def\FVC@SaveVerb@Extra#1{%
  \@namedef{FV@SV@#1}{}%
  \@namedef{FV@SVRaw@#1}{}%
  \begingroup
  \ifbool{FV@vargsingleline}%
   {\let\FV@Reader\FVExtraReadVArgSingleLine}%
   {\let\FV@Reader\FVExtraReadVArg}%
  \FV@Reader{%
    \FVC@SaveVerb@Extra@i{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@SaveVerb@Extra@i}
%    \begin{macrocode}
\def\FVC@SaveVerb@Extra@i#1#2{%
  \FV@UseInlineKeyValues\FV@UseKeyValues\FV@FormattingPrep
  \FVExtraDetokenizeVArg{%
    \FVExtraRetokenizeVArg{\FVC@SaveVerb@Extra@ii{#1}{#2}}{\FV@CatCodes}}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@SaveVerb@Extra@ii}
%    \begin{macrocode}
\def\FVC@SaveVerb@Extra@ii#1#2#3{%
  \global\let\FV@AfterSave\FancyVerbAfterSave
  \endgroup
  \@namedef{FV@SV@#1}{#3}%
  \@namedef{FV@SVRaw@#1}{#2}%
  \FV@AfterSave}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\UseVerb}}
%
% This adds support for \cmd{\fvinlineset} and line breaking.  It also adds movable argument and PDF string support.  A new option |retokenize| is defined that determines whether the typeset output is based on the |commandchars| and |codes| in place when \cmd{\SaveVerb} was used (default), or is retokenized under current |commandchars| and |codes|.
%
% \begin{macro}{FV@retokenize}
% \begin{macro}{retokenize}
% Whether \cmd{\UseVerb} uses saved verbatim with its original tokenization, or retokenizes under current |commandchars| and |codes|.
%    \begin{macrocode}
\newbool{FV@retokenize}
\define@booleankey{FV}{retokenize}%
 {\booltrue{FV@retokenize}}{\boolfalse{FV@retokenize}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\UseVerb}
%    \begin{macrocode}
\def\UseVerb{%
  \FVExtraRobustCommand\RobustUseVerb\FVExtraUseVerbUnexpandedReadStarOArgMArg}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\RobustUseVerb}
%    \begin{macrocode}
\protected\def\RobustUseVerb{\FV@Command{}{UseVerb}}
\FVExtrapdfstringdefDisableCommands{%
  \def\RobustUseVerb{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@UseVerb@FV}
%    \begin{macrocode}
\let\FVC@UseVerb@FV\FVC@UseVerb
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVC@UseVerb}
%    \begin{macrocode}
\def\FVC@UseVerb{%
  \begingroup
  \FV@UseInlineKeyValues\FV@UseKeyValues
  \ifFV@extra
    \expandafter\endgroup\expandafter\FVC@UseVerb@Extra
  \else
    \expandafter\endgroup\expandafter\FVC@UseVerb@FV
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FVC@UseVerb@Extra}
%    \begin{macrocode}
\def\FVC@UseVerb@Extra#1{%
  \@ifundefined{FV@SV@#1}%
   {\FV@Error{Short verbatim text never saved to name `#1'}\FV@eha}%
   {\begingroup
    \FV@UseInlineKeyValues\FV@UseKeyValues\FV@FormattingPrep
    \ifbool{FV@retokenize}%
     {\expandafter\let\expandafter\FV@Tmp\csname FV@SVRaw@#1\endcsname
      \expandafter\FV@UseVerb@Extra@Retok\expandafter{\FV@Tmp}}%
     {\expandafter\let\expandafter\FV@Tmp\csname FV@SV@#1\endcsname
      \expandafter\FV@UseVerb@Extra\expandafter{\FV@Tmp}}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@UseVerb@Extra@Retok}
%    \begin{macrocode}
\def\FV@UseVerb@Extra@Retok#1{%
  \FVExtraDetokenizeVArg{%
    \FVExtraRetokenizeVArg{\FV@UseVerb@Extra}{\FV@CatCodes}}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@UseVerb@Extra}
%    \begin{macrocode}
\let\FV@UseVerb@Extra\FVC@Verb@Extra@ii
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{New commands and environments}
% \label{sec:impl:new-commands-environments}
%
% \subsubsection{\cmd{\EscVerb}}
% This is a variant of \cmd{\Verb} in which backslash escapes of the form |\<char>| are used for |<char>|.  Backslash escapes are \emph{only} permitted for printable, non-alphanumeric ASCII characters.  The argument is read under a normal catcode regime, so any characters that cannot be read under normal catcodes must always be escaped, and the argument must always be delimited by curly braces.  This ensures that \cmd{\EscVerb} behaves identically whether or not it is used inside another command.
%
% \cmd{\EscVerb} is constructed with \cmd{\FVExtraRobustCommand} so that it will function correctly after being in an expansion-only context.
%
% \begin{macro}{\EscVerb}
% Note that while the typeset mandatory argument will be read under normal catcodes, the reader macro for expansion is \cmd{\FVExtraUnexpandedReadStarOArgBEscVArg}.  This reflects how the argument will be typeset.
%    \begin{macrocode}
\def\EscVerb{%
  \FVExtraRobustCommand\RobustEscVerb\FVExtraUnexpandedReadStarOArgBEscVArg}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\RobustEscVerb}
%    \begin{macrocode}
\protected\def\RobustEscVerb{\FV@Command{}{EscVerb}}
\FVExtrapdfstringdefDisableCommands{%
  \def\RobustEscVerb{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@EscVerb}
% Delimiting with curly braces is required, so that the command will always behave the same whether or not it has been through expansion.
%    \begin{macrocode}
\def\FVC@EscVerb{%
  \@ifnextchar\bgroup
   {\FVC@EscVerb@i}%
   {\PackageError{fvextra}%
    {Invalid argument; argument must be delimited by paired curly braces}%
    {Delimit argument with curly braces}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@EscVerb@i}
%    \begin{macrocode}
\def\FVC@EscVerb@i#1{%
  \begingroup
  \FV@UseInlineKeyValues\FV@UseKeyValues\FV@FormattingPrep
  \FVExtraDetokenizeREscVArg{%
    \FVExtraRetokenizeVArg{\FVC@EscVerb@ii}{\FV@CatCodes}}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FVC@EscVerb@ii}
%    \begin{macrocode}
\let\FVC@EscVerb@ii\FVC@Verb@Extra@ii
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{VerbEnv}}
% Environment variant of \cmd{\Verb}.  Depending on how this is used in the future, it may be worth improving error message and error recovery functionality, using techniques from \pkg{fancyvrb}.
% \begin{macro}{\VerbEnv}
%    \begin{macrocode}
\def\VerbEnv{%
  \ifcsname @currenvir\endcsname
    \ifx\@currenvir\@empty
      \PackageError{fvextra}{VerbEnv is an environment}{VerbEnv is an environment}%
    \else
      \ifx\@currenvir\relax
        \PackageError{fvextra}{VerbEnv is an environment}{VerbEnv is an environment}%
      \fi
    \fi
  \else
    \PackageError{fvextra}{VerbEnv is an environment}{VerbEnv is an environment}%
  \fi
  \VerbatimEnvironment
  \FVExtraReadOArgBeforeVEnv{\expandafter\VerbEnv@i\expandafter{\FV@EnvironName}}}
\def\VerbEnv@i#1#2{%
  \begingroup
  \let\do\@makeother\FVExtraDoSpecials
  \catcode`\ =\active
  \catcode`\^^I=\active
  \catcode`\^^M=\active
  \VerbEnv@ii{#1}{#2}}
\begingroup
\catcode`\!=0
\catcode`\<=1
\catcode`\>=2
!catcode`!\=12
!catcode`!{=12
!catcode`!}=12
!catcode`!^^M=!active%
!gdef!VerbEnv@ii#1#2#3^^M<%
  !endgroup%
  !def!VerbEnv@CheckLine##1\end{#1}##2!FV@Sentinel<%
    !if!relax!detokenize<##2>!relax%
    !else%
      !PackageError<fvextra><Missing environment contents><Missing environment contents>%
      !let!VerbEnv@iii!VerbEnv@iii@Error%
    !fi>%
  !VerbEnv@CheckLine#3\end{#1}!FV@Sentinel%
  !VerbEnv@iii<#1><#2><#3>>%
!endgroup%
\def\VerbEnv@iii@Error#1#2#3{}
\def\VerbEnv@iii#1#2#3{%
  \begingroup
  \let\do\@makeother\FVExtraDoSpecials
  \catcode`\ =10\relax
  \catcode`\^^M=\active
  \VerbEnv@iv{#1}{#2}{#3}}
\begingroup
\catcode`\!=0
\catcode`\<=1
\catcode`\>=2
!catcode`!\=12
!catcode`!{=12
!catcode`!}=12
!catcode`!^^M=!active%
!gdef!VerbEnv@iv#1#2#3#4^^M<%
  !endgroup%
  !def!VerbEnv@CheckEndDelim##1\end{#1}##2!FV@Sentinel<%
    !if!relax!detokenize<##2>!relax%
      !PackageError<fvextra><Missing end for environment !FV@EnvironName><Add environment end>%
      !let!VerbEnv@v!VerbEnv@v@Error%
    !else%
      !VerbEnv@CheckEndLeading##1!FV@Sentinel%
      !VerbEnv@CheckEndTrailing##2!FV@Sentinel%
    !fi>%
  !def!VerbEnv@CheckEndTrailing##1\end{#1}!FV@Sentinel<%
    !if!relax!detokenize<##1>!relax%
    !else%
      !PackageError<fvextra>%
       <Discarded text after end of environment !FV@EnvironName>%
       <Discarded text after end of environment !FV@EnvironName>%
      !let!VerbEnv@v!VerbEnv@v@Error%
    !fi>%
  !VerbEnv@CheckEndDelim#4\end{#1}!FV@Sentinel%
  !VerbEnv@v<#2><#3>>%
!endgroup
\def\VerbEnv@CheckEndLeading{%
  \FVExtra@ifnextcharAny\@sptoken%
   {\VerbEnv@CheckEndLeading@Continue}%
   {\ifx\@let@token\FV@Sentinel
      \expandafter\VerbEnv@CheckEndLeading@End
    \else
      \expandafter\VerbEnv@CheckEndLeading@EndError
    \fi}}
\def\VerbEnv@CheckEndLeading@Continue#1{%
  \VerbEnv@CheckEndLeading}
\def\VerbEnv@CheckEndLeading@End#1\FV@Sentinel{}
\def\VerbEnv@CheckEndLeading@EndError{%
  \PackageError{fvextra}%
   {Discarded text before end of environment \FV@EnvironName}%
   {Discarded text before end of environment \FV@EnvironName}%
  \let\VerbEnv@v\VerbEnv@v@Error}
\def\VerbEnv@v@Error#1#2{}
\def\VerbEnv@v#1#2{%
  \Verb[#1]{#2}%
  \expandafter\end\expandafter{\FV@EnvironName}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endVerbEnv}
%    \begin{macrocode}
\def\endVerbEnv{\global\let\FV@EnvironName\relax}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{\cmd{VerbatimWrite}}
%
% This environment writes its contents to a file verbatim.  Differences from \fancyvrb's |VerbatimOut|:
% \begin{itemize}
% \item Multiple |VerbatimWrite| environments can write to the same file.  The file is set via the |writefilehandle| option.  This does mean that the user is responsible for creating a new file handle via |\newwrite| and then ideally invoking |\closeout| at the appropriate time.
% \item By default, text is really written verbatim.  This is accomplished by a combination of setting catcodes to 12 (other) and |\detokenize|.  This can be customized using the new |writer| option, which defines a macro that performs any processing on each line before writing it to file.  By default, all \fancyvrb\ options except for |VerbatimWrite|-specific options are ignored.  This can be customized on a per-environment basis via environment optional arguments.
% \end{itemize}
%
% \begin{macro}{writefilehandle, \FancyVerbWriteFileHandle}
% Set file handle for |VerbatimWrite|.
%    \begin{macrocode}
\define@key{FV}{writefilehandle}{%
  \FV@SetWrite#1\FV@Sentinel}
\def\FV@SetWrite#1#2\FV@Sentinel{%
  \let\FancyVerbWriteFileHandle\relax
  \if\relax\detokenize{#2}\relax
    \let\FancyVerbWriteFileHandle#1\relax
  \fi
  \ifx\FancyVerbWriteFileHandle\relax
    \PackageError{fvextra}%
     {Missing or invalid file handle for write}%
     {Need file handle from \string\newwrite}%
  \fi}
\let\FancyVerbWriteFileHandle\relax
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{writer,\FV@Writer}
% Define writer macro that processes each line before writing.
%    \begin{macrocode}
\define@key{FV}{writer}{%
  \let\FV@Writer#1\relax}
\def\FancyVerbDefaultWriter#1{%
  \immediate\write\FancyVerbWriteFileHandle{\detokenize{#1}}}
\fvset{writer=\FancyVerbDefaultWriter}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{VerbatimWrite}
% The environment implementation follows standard \fancyvrb\ environment style.
%
% A special write counter is used to track line numbers while avoiding incrementing the regular counter that is used for typeset code.  Some macros do nothing with the default |writer|, but are needed to enable \fancyvrb\ options when a custom |writer| is used in conjunction with optional environment arguments.  These include |\FancyVerbDefineActive|, |\FancyVerbFormatCom|, and |\FV@DefineTabOut|.
%    \begin{macrocode}
\newcounter{FancyVerbWriteLine}
\def\VerbatimWrite{%
  \FV@Environment
   {codes=,commandchars=none,commentchar=none,defineactive,%
    gobble=0,formatcom=,firstline,lastline}%
   {VerbatimWrite}}
\def\FVB@VerbatimWrite{%
  \@bsphack
  \begingroup
  \setcounter{FancyVerbWriteLine}{0}%
  \let\c@FancyVerbLine\c@FancyVerbWriteLine
  \FV@UseKeyValues
  \FV@DefineWhiteSpace
  \def\FV@Space{\space}%
  \FV@DefineTabOut
  \let\FV@ProcessLine\FV@Writer
  \let\FV@FontScanPrep\relax
  \let\@noligs\relax
  \FancyVerbDefineActive
  \FancyVerbFormatCom
  \FV@Scan}
\def\FVE@VerbatimWrite{%
  \endgroup
  \@esphack}
\def\endVerbatimWrite{\FVE@VerbatimWrite}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{\cmd{VerbatimBuffer}}
%
% This environment stores its contents verbatim in a ``buffer,'' a sequence of numbered macros each of which contains one line of the environment.  The ``buffered'' lines can then be looped over for further processing or later use.
%
% By default, all \fancyvrb\ options except for |VerbatimBuffer|-specific options are ignored.  This can be customized on a per-environment basis via environment optional arguments.
%
% \begin{macro}{afterbuffer,\FV@afterbuffer}
% Macro that is inserted after the last line of the environment is buffered, immediately before the environment ends.
%    \begin{macrocode}
\define@key{FV}{afterbuffer}{%
  \def\FV@afterbuffer{#1}}
\fvset{afterbuffer=}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBufferIndex}
% Current index in buffer during buffering.  This is given a |FancyVerb*| macro name since it may be accessed by the user in defining custom |bufferer|.
%    \begin{macrocode}
\def\FancyVerbBufferIndex{0}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{bufferer,\FV@Bufferer,\FancyVerbDefaultBufferer}
% This is the macro that adds lines to the buffer.  The default is designed to create a truly verbatim buffer via |\detokenize|.
%    \begin{macrocode}
\define@key{FV}{bufferer}{%
  \let\FV@Bufferer=#1\relax}
\def\FancyVerbDefaultBufferer#1{%
  \expandafter\xdef\csname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname{%
    \detokenize{#1}}}
\fvset{bufferer=\FancyVerbDefaultBufferer}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{bufferlengthname, \FancyVerbBufferLengthName}
% Name of macro storing the length of the buffer.
%    \begin{macrocode}
\define@key{FV}{bufferlengthname}{%
  \ifcsname#1\endcsname
  \else
    \expandafter\xdef\csname#1\endcsname{0}%
  \fi
  \def\FancyVerbBufferLengthName{#1}%
  \expandafter\def\expandafter\FV@bufferlengthmacro\expandafter{%
    \csname#1\endcsname}}
\fvset{bufferlengthname=FancyVerbBufferLength}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{bufferlinename, \FancyVerbBufferLineName}
% Base name of buffer line macros.  This is given a |\FancyVerb*| macro name since it may be accessed by the user in defining custom |bufferer|.
%    \begin{macrocode}
\define@key{FV}{bufferlinename}{%
  \def\FancyVerbBufferLineName{#1}}
\fvset{bufferlinename=FancyVerbBufferLine}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{buffername}
% Shortcut for setting |bufferlengthname| and |bufferlinename|.
%    \begin{macrocode}
\define@key{FV}{buffername}{%
  \fvset{bufferlengthname=#1length,bufferlinename=#1line}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{globalbuffer, FV@globalbuffer}
% Whether buffer line macros and the buffer length macro are defined globally.
%    \begin{macrocode}
\newbool{FV@globalbuffer}
\define@booleankey{FV}{globalbuffer}%
 {\booltrue{FV@globalbuffer}}%
 {\boolfalse{FV@globalbuffer}}
\fvset{globalbuffer=false}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{VerbatimBuffer}
% The environment implementation follows standard \fancyvrb\ environment style.
%
% A special buffer counter is used to track line numbers while avoiding incrementing the regular counter that is used for typeset code.  Some macros do nothing with the default |bufferer|, but are needed to enable \fancyvrb\ options when a custom |bufferer| is used in conjunction with optional environment arguments.  These include |\FancyVerbDefineActive| and |\FancyVerbFormatCom|.  Since counters are global, the exact location of the |\setcounter| commands at the end of the environment relative to |\begingroup...\endgroup| is not important.
%    \begin{macrocode}
\newcounter{FancyVerbBufferLine}
\def\FancyVerbBufferDepth{0}
\def\VerbatimBuffer{%
  \FV@Environment
   {codes=,commandchars=none,commentchar=none,defineactive,%
    gobble=0,formatcom=,firstline,lastline}%
   {VerbatimBuffer}}
\def\FVB@VerbatimBuffer{%
  \@bsphack
  \xdef\FancyVerbBufferDepth{\the\numexpr\FancyVerbBufferDepth+1\relax}%
  \begingroup
  \FV@UseKeyValues
  \setcounter{FancyVerbBufferLine}{\FV@bufferlengthmacro}%
  \let\c@FancyVerbLine\c@FancyVerbBufferLine
  \xdef\FancyVerbBufferIndex{\FV@bufferlengthmacro}%
  \ifbool{FV@globalbuffer}%
   {}%
   {\expandafter\xdef\csname FV@setbufferlocalscopevars\FancyVerbBufferDepth\endcsname{%
      \unexpanded{\def\FV@oldbufferlength}%
       {\FV@bufferlengthmacro}%
      \unexpanded{\def\FV@bufferlengthmacro}%
       {\unexpanded\expandafter{\FV@bufferlengthmacro}}%
      \unexpanded{\def\FancyVerbBufferLineName}%
       {\unexpanded\expandafter{\FancyVerbBufferLineName}}}}%
  \ifx\FV@afterbuffer\@empty
  \else
    \ifx\FV@afterbuffer\relax
    \else
      \expandafter\global\expandafter
        \let\csname FV@afterbuffer\FancyVerbBufferDepth\endcsname\FV@afterbuffer
    \fi
  \fi
  \FV@DefineWhiteSpace
  \def\FV@ProcessLine{%
    \xdef\FancyVerbBufferIndex{\the\numexpr\FancyVerbBufferIndex+1\relax}%
    \FV@Bufferer}%
  \let\FV@FontScanPrep\relax
  \let\@noligs\relax
  \FancyVerbDefineActive
  \FancyVerbFormatCom
  \FV@Scan}
\def\FVE@VerbatimBuffer{%
  \expandafter\xdef\FV@bufferlengthmacro{\FancyVerbBufferIndex}%
  \gdef\FancyVerbBufferIndex{0}%
  \endgroup
  \@esphack
  \ifcsname FV@afterbuffer\FancyVerbBufferDepth\endcsname
    \begingroup
    \csname FV@afterbuffer\FancyVerbBufferDepth\endcsname
    \endgroup
    \expandafter\global\expandafter
      \let\csname FV@afterbuffer\FancyVerbBufferDepth\endcsname\FV@Undefined
  \fi
  \ifcsname FV@setbufferlocalscopevars\FancyVerbBufferDepth\endcsname
    \begingroup
    \csname FV@setbufferlocalscopevars\FancyVerbBufferDepth\endcsname
    \loop\unless\ifnum\FV@bufferlengthmacro=\FV@oldbufferlength\relax
      \expandafter\global\expandafter
        \let\csname\FancyVerbBufferLineName\FV@bufferlengthmacro\endcsname\FV@Undefined
      \expandafter\xdef\FV@bufferlengthmacro{%
        \the\numexpr\FV@bufferlengthmacro-1\relax}%
    \repeat
    \endgroup
    \expandafter\global\expandafter
      \let\csname FV@setbufferlocalscopevars\FancyVerbBufferDepth\endcsname\FV@Undefined
  \fi
  \xdef\FancyVerbBufferDepth{\the\numexpr\FancyVerbBufferDepth-1\relax}}
\def\endVerbatimBuffer{\FVE@VerbatimBuffer}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{\cmd{\VerbatimInsertBuffer}}
% \begin{macro}{\VerbatimInsertBuffer, insertenvname}
% This inserts an existing buffer created with |VerbatimBuffer| as a verbatim environment.  By default, the inserted environment is |Verbatim|; this can be modified with the option |insertenvname| to any |Verbatim|- or |BVerbatim|-based environment, or any environment with a compatible implementation.  The |Verbatim| and |BVerbatim| internals are customized to function with a buffer in a command context.
%
% Notes on the implementation of |\VerbatimInsertBuffer@i|:
% \begin{itemize}
% \item The active |^^M| allows a verbatim environment to read optional arguments in the usual way, without requiring modifications to argument-reading macros.
% \item The |\begingroup\fvset{#1}\global\let\FV@CurrentVerbatimInsertEnvName...| is used to extract any |insertenvname| setting from optional arguments.  Most optional arguments apply to the verbatim environment or to the customized verbatim internals that are invoked within it.  However, |insertenvname| is needed earlier to determine which verbatim environment is in use.  It is not possible simply to use |\fvset{#1}| before the verbatim environment to apply all settings, because that would conflict with the precedence of option processing in |\FV@Environment|.
% \end{itemize}
%    \begin{macrocode}
\define@key{FV}{insertenvname}{%
  \def\FV@VerbatimInsertEnvName{#1}}
\fvset{insertenvname=Verbatim}
\def\FV@Environment@InsertBuffer#1#2{%
  \def\FV@KeyValues{#1}%
  \FV@GetKeyValues{\@nameuse{FVB@#2}}}
\def\FV@Scan@InsertBuffer{%
  \FV@CatCodes
  \xdef\FV@EnvironName{\FV@VerbatimInsertEnvName}%
  \ifnum\FV@bufferlengthmacro=\z@\relax
    \PackageError{fvextra}%
     {Buffer length macro \expandafter\string\FV@bufferlengthmacro\space
      is invalid or zero}%
     {}%
    \let\FV@GetLine\relax
  \fi
  \FV@BeginScanning}%
\def\VerbatimInsertBuffer@def@FV@Line#1{%
  \FVExtraRetokenizeVArg{\def\FV@Line}{}{#1}}
\def\FancyVerbGetLine@VerbatimInsertBuffer{%
  \ifnum\FancyVerbBufferIndex>\FV@bufferlengthmacro\relax
    \global\let\FV@EnvironName\relax
    \let\next\relax
  \else
    \ifcsname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname
      \expandafter\let\expandafter\FV@Line@Buffer
        \csname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname
      \expandafter\VerbatimInsertBuffer@def@FV@Line\expandafter{\FV@Line@Buffer}%
      \def\next{\FV@PreProcessLine\FV@GetLine}%
      \xdef\FancyVerbBufferIndex{\the\numexpr\FancyVerbBufferIndex+1\relax}%
    \else
      \def\next{%
        \PackageError{fvextra}%
         {Buffer with line macro named
          "\FancyVerbBufferLineName\FancyVerbBufferIndex" does not exist}%
         {Check bufferlinename, bufferlengthname, and globalbuffer settings}%
      }%
    \fi
  \fi
  \next}
\newcommand{\VerbatimInsertBuffer}[1][]{%
  \begingroup
  \let\FV@Scan\FV@Scan@InsertBuffer
  \let\FV@CheckScan\relax
  \let\FV@Environment\FV@Environment@InsertBuffer
  \let\FancyVerbGetLine\FancyVerbGetLine@VerbatimInsertBuffer
  \gdef\FancyVerbBufferIndex{1}%
  \VerbatimInsertBuffer@i{#1}%
  \gdef\FancyVerbBufferIndex{0}%
  \endgroup
  \@doendpe}
\begingroup
\catcode`\^^M=\active
\gdef\VerbatimInsertBuffer@i#1{%
  \begingroup%
  \fvset{#1}%
  \global\let\FV@CurrentVerbatimInsertEnvName\FV@VerbatimInsertEnvName%
  \endgroup%
  \csname \FV@CurrentVerbatimInsertEnvName\endcsname[#1]^^M%
  \csname end\FV@CurrentVerbatimInsertEnvName\endcsname%
  \global\let\FV@CurrentVerbatimInsertEnvName\FV@Undefined}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\VerbatimClearBuffer}}
% \begin{macro}{\VerbatimClearBuffer}
% Clear an existing buffer.
%    \begin{macrocode}
\newcommand{\VerbatimClearBuffer}[1][]{%
  \begingroup
  \def\FV@KeyValues{#1}%
  \FV@UseKeyValues
  \xdef\FancyVerbBufferIndex{\FV@bufferlengthmacro}%
  \expandafter\xdef\FV@bufferlengthmacro{0}%
  \loop\unless\ifnum\FancyVerbBufferIndex<1\relax
    \expandafter\global\expandafter\let
      \csname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname
      \FV@Undefined
    \xdef\FancyVerbBufferIndex{\the\numexpr\FancyVerbBufferIndex-1\relax}%
  \repeat
  \gdef\FancyVerbBufferIndex{0}%
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\InsertBuffer}}
% \begin{macro}{\InsertBuffer, wrapperenvname, wrapperenvopt, wrapperenvarg}
% This inserts an existing buffer created with |VerbatimBuffer| so that it is interpreted as \LaTeX.  The result is essentially the same as if the buffered text had been included literally at the insertion point.
%    \begin{macrocode}
\define@key{FV}{wrapperenvname}{%
  \def\FV@WrapperEnvName{#1}%
  \ifx\FV@WrapperEnvName\@empty
    \let\FV@WrapperEnvName\relax
  \fi}
\fvset{wrapperenvname=}
\define@key{FV}{wrapperenvopt}{%
  \def\FV@WrapperEnvOpt{#1}%
  \ifx\FV@WrapperEnvOpt\@empty
    \let\FV@WrapperEnvOpt\relax
  \fi}
\fvset{wrapperenvopt=}
\define@key{FV}{wrapperenvarg}{%
  \def\FV@WrapperEnvArg{#1}%
  \ifx\FV@WrapperEnvArg\@empty
    \let\FV@WrapperEnvArg\relax
  \fi}
\fvset{wrapperenvarg=}
\newcommand{\InsertBuffer}[1][]{%
  \begingroup
  \def\FV@KeyValues{#1}%
  \FV@UseKeyValues
  \ifnum\FV@bufferlengthmacro<1
    \expandafter\endgroup\expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  \InsertBuffer@i}
\def\InsertBuffer@i{%
  \InsertBuffer@expandbuffer
  \expandafter\endgroup\expandafter\scantokens\expandafter{%
    \FV@expandedbuffer\noexpand}\relax}
\def\InsertBuffer@expandbuffer{%
  \edef\FV@expandedbuffer{%
    \ifx\FV@WrapperEnvName\relax
    \else
      \unexpanded\expandafter\expandafter\expandafter{%
        \expandafter\string\expandafter\begin\expandafter{\FV@WrapperEnvName}}%
      \ifx\FV@WrapperEnvOpt\relax
      \else
        \unexpanded\expandafter{\expandafter[\FV@WrapperEnvOpt]}%
      \fi
      \ifx\FV@WrapperEnvArg\relax
      \else
        \unexpanded\expandafter{\expandafter{\FV@WrapperEnvArg}}%
      \fi
      \unexpanded{^^J}%
    \fi
    \InsertBuffer@expandbufferlines{1}%
    \ifx\FV@WrapperEnvName\relax
      \unskip
    \else
      \unexpanded\expandafter\expandafter\expandafter{%
        \expandafter\string\expandafter\end\expandafter{\FV@WrapperEnvName}^^J}%
    \fi}}
\def\InsertBuffer@expandbufferlines#1{%
  \unexpanded\expandafter\expandafter\expandafter{%
    \csname\FancyVerbBufferLineName#1\endcsname^^J}%
  \ifnum\FV@bufferlengthmacro=#1
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\InsertBuffer@expandbufferlines\expandafter{\the\numexpr#1+1\relax}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\ClearBuffer}}
% \begin{macro}{\ClearBuffer}
% Clear an existing buffer.  Alias for |\VerbatimClearBuffer|.
%    \begin{macrocode}
\let\ClearBuffer\VerbatimClearBuffer
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\BufferMdfivesum}}
% \begin{macro}{\BufferMdfivesum}
% Calculate the MD5 sum of the current buffer.
%    \begin{macrocode}
\def\BufferMdfivesum{%
  \pdf@mdfivesum{%
    \ifnum\FV@bufferlengthmacro<1
      \expandafter\@gobble
    \else
      \expandafter\@firstofone
    \fi
    {\BufferMdfivesum@i{1}}}}
\def\BufferMdfivesum@i#1{%
  \csname\FancyVerbBufferLineName#1\endcsname^^J%
  \ifnum\FV@bufferlengthmacro=#1
    \expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi
  {\expandafter\BufferMdfivesum@i\expandafter{\the\numexpr#1+1\relax}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\IterateBuffer}, \cmd{\IterateBufferBreak}}
% \begin{macro}{\IterateBuffer, \IterateBufferBreak}
% Loop over buffer, applying a macro to each line.
%    \begin{macrocode}
\newcommand{\IterateBuffer}[2][]{%
  \if\relax\detokenize{#1}\relax
  \else
    \let\FancyVerbBufferLengthName@beforeiter\FancyVerbBufferLengthName
    \let\FV@bufferlengthmacro@beforeiter\FV@bufferlengthmacro
    \let\FancyVerbBufferLineName@beforeiter\FancyVerbBufferLineName
    \begingroup
    \def\FV@KeyValues{#1}%
    \FV@UseKeyValues
    \global\let\FancyVerbBufferLengthName@iter\FancyVerbBufferLengthName
    \global\let\FV@bufferlengthmacro@iter\FV@bufferlengthmacro
    \global\let\FancyVerbBufferLineName@iter\FancyVerbBufferLineName
    \endgroup
    \let\FancyVerbBufferLengthName\FancyVerbBufferLengthName@iter
    \let\FV@bufferlengthmacro\FV@bufferlengthmacro@iter
    \let\FancyVerbBufferLineName\FancyVerbBufferLineName@iter
    \global\let\FancyVerbBufferLengthName@iter\FV@Undefined
    \global\let\FV@bufferlengthmacro@iter\FV@Undefined
    \global\let\FancyVerbBufferLineName@iter\FV@Undefined
  \fi
  \gdef\FancyVerbBufferIndex{1}%
  \def\FV@IterateBuffer@cmd{#2}%
  \def\IterateBufferBreak{\xdef\FancyVerbBufferIndex{\FV@bufferlengthmacro}}%
  \loop\unless\ifnum\FancyVerbBufferIndex>\FV@bufferlengthmacro\relax
    \expandafter\let\expandafter\FV@IterateBuffer@line
      \csname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname
    \expandafter\FV@IterateBuffer@cmd\expandafter{\FV@IterateBuffer@line}%
    \xdef\FancyVerbBufferIndex{\the\numexpr\FancyVerbBufferIndex+1\relax}%
  \repeat
  \gdef\FancyVerbBufferIndex{0}%
  \let\FV@IterateBuffer@cmd\FV@Undefined
  \let\IterateBufferBreak\FV@Undefined
  \let\FV@IterateBuffer@line\FV@Undefined
  \if\relax\detokenize{#1}\relax
  \else
    \let\FancyVerbBufferLengthName\FancyVerbBufferLengthName@beforeiter
    \let\FV@bufferlengthmacro\FV@bufferlengthmacro@beforeiter
    \let\FancyVerbBufferLineName\FancyVerbBufferLineName@beforeiter
    \let\FancyVerbBufferLengthName@beforeiter\FV@Undefined
    \let\FV@bufferlengthmacro@beforeiter\FV@Undefined
    \let\FancyVerbBufferLineName@beforeiter\FV@Undefined
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\WriteBuffer}
% Buffer equivalent of |VerbatimWrite|.
%    \begin{macrocode}
\def\WriteBuffer{%
  \FV@Command{}{WriteBuffer}}
\def\FVC@WriteBuffer{%
  \@bsphack
  \begingroup
  \setcounter{FancyVerbWriteLine}{0}%
  \let\c@FancyVerbLine\c@FancyVerbWriteLine
  \FV@UseKeyValues
  \FV@DefineWhiteSpace
  \def\FV@Space{\space}%
  \FV@DefineTabOut
  \gdef\FancyVerbBufferIndex{1}%
  \loop\unless\ifnum\FancyVerbBufferIndex>\FV@bufferlengthmacro\relax
    \stepcounter{FancyVerbWriteLine}%
    \expandafter\let\expandafter\FV@WriteBuffer@line
      \csname\FancyVerbBufferLineName\FancyVerbBufferIndex\endcsname
    \expandafter\FV@Writer\expandafter{\FV@WriteBuffer@line}%
    \xdef\FancyVerbBufferIndex{\the\numexpr\FancyVerbBufferIndex+1\relax}%
  \repeat
  \gdef\FancyVerbBufferIndex{0}%
  \endgroup
  \@esphack} 
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Patches}
% \label{sec:impl:patches}
%
%
% \subsubsection{Delimiting characters for verbatim commands}
% \label{sec:impl:patches:delimiting-verbatim-commands}
%
% Unlike \cmd{\verb}, \fancyvrb's commands like \cmd{\Verb} cannot take arguments delimited by characters like |#| and |%| due to the way that starred commands and optional arguments are implemented.  The relevant macros are redefined to make this possible.
%
% \fancyvrb's \cmd{\Verb} is actually implemented in \cmd{\FVC@Verb}.  This is invoked by a helper macro \cmd{\FV@Command} which allows versions of commands with customized options:
% \begin{quote}
% \cmd{\FV@Command}\marg{customized\_options}\marg{base\_command\_name}
% \end{quote}
% \cmd{\Verb} is then defined as |\def\Verb{\FV@Command{}{Verb}}|.  The definition of \cmd{\FV@Command} (and \cmd{\FV@@Command} which it uses internally) involves looking ahead for a star |*| (\cmd{\@ifstar}) and for a left square bracket |[| that delimits an optional argument (\cmd{\@ifnextchar}).  As a result, the next character is tokenized under the current, normal catcode regime.  This prevents \cmd{\Verb} from being able to use delimiting characters like |#| and |%| that work with \cmd{\verb}.
%
% \cmd{\FV@Command} and \cmd{\FV@@Command} are redefined so that this lookahead tokenizes under a typical verbatim catcode regime (with one exception that is explained below).  This enables \cmd{\verb}-style delimiters.  This does not account for any custom catcode changes introduced by \cmd{\fvset}, customized commands, or optional arguments.  However, delimiting characters should never need custom catcodes, and both the \fancyvrb\ definition of \cmd{\Verb} (when not used inside another macro) as well as the \fvextra\ reimplementation (in all cases) handle the possibility of delimiters with valid but non-typical catcodes.  Other, non-verbatim commands that use \cmd{\FV@Command}, such as \cmd{\UseVerb}, are not affected by the patch.
%
% The catcode regime for lookahead has one exception to a typical verbatim catcode regime:  The curly braces |{}| retain their normal codes.  This allows the \fvextra\ reimplementation of \cmd{\Verb} to use a pair of curly braces as delimiters, which can be convenient when \cmd{\Verb} is used within another command.  Since the original \fancyvrb\ implementation of \cmd{\Verb} with unpatched \cmd{\FV@Command} is incompatible with curly braces being used as delimiters in any form, this does not affect any pre-existing \fancyvrb\ functionality.
%
% \begin{macro}{\FV@Command}
%    \begin{macrocode}
\def\FV@Command#1#2{%
  \FVExtra@ifstarVArg
   {\def\FV@KeyValues{#1,showspaces,showtabs}\FV@@Command{#2}}%
   {\def\FV@KeyValues{#1}\FV@@Command{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@@Command}
%    \begin{macrocode}
\def\FV@@Command#1{%
  \FVExtra@ifnextcharVArg[%
    {\FV@GetKeyValues{\@nameuse{FVC@#1}}}%
    {\@nameuse{FVC@#1}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\cmd{\CustomVerbatimCommand} compatibility with \cmd{\FVExtraRobustCommand}}
%
% \begin{macro}{\@CustomVerbatimCommand}
% |#1| is \cmd{\newcommand} or \cmd{\renewcommand}, |#2| is the (re)new command, |#3| is the base \fancyvrb\ command, |#4| is options.
%    \begin{macrocode}
\def\@CustomVerbatimCommand#1#2#3#4{%
  \begingroup\fvset{#4}\endgroup
  \@ifundefined{FVC@#3}%
   {\FV@Error{Command `\string#3' is not a FancyVerb command.}\@eha}%
   {\ifcsname Robust#3\endcsname
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
    {\expandafter\let\expandafter\@tempa\csname #3\endcsname
     \def\@tempb##1##2##3{%
       \expandafter\def\expandafter\@tempc\expandafter{%
         \csname Robust\expandafter\@gobble\string#2\endcsname}%
       \def\@tempd####1{%
         #1{#2}{##1####1##3}}%
       \expandafter\@tempd\@tempc
       \expandafter\protected\expandafter\def\@tempc{\FV@Command{#4}{#3}}}%
     \expandafter\@tempb\@tempa}%
    {#1{#2}{\FV@Command{#4}{#3}}}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Visible spaces}
%
% \begin{macro}{\FancyVerbSpace}
% The default definition of visible spaces (|showspaces=true|) could allow font commands to escape under some circumstances, depending on how it is used:
%\begin{verbatim}
%{\catcode`\ =12 \gdef\FancyVerbSpace{\tt }}
%\end{verbatim}
% |\textvisiblespace| is not an alternative because it does not have the correct width.  The redefinition follows \url{https://tex.stackexchange.com/a/120231/10742}.
%    \begin{macrocode}
\def\FancyVerbSpace{%
 \makebox[0.5em]{%
   \kern.07em
   \vrule height.3ex
   \hrulefill
   \vrule height.3ex
   \kern.07em}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\texttt{obeytabs} with visible tabs and with tabs inside macro arguments}
% \label{sec:patch:obeytabs}
%
% |\FV@TrueTab| governs tab appearance when |obeytabs=true| and |showtabs=true|. It is redefined so that symbols with flexible width, such as |\rightarrowfill|, will work as expected.  In the original \fancyvrb\ definition, |\kern\@tempdima\hbox to\z@{...}|.  The |\kern| is removed and instead the |\hbox| is given the width |\@tempdima|.
%
% |\FV@TrueTab| and related macros are also modified so that they function for tabs inside macro arguments when |obeytabs=true| (inside curly braces |{}| with their normal meaning, when using |commandchars|, etc.).  The \fancyvrb\ implementation of tab expansion assumes that tabs are never inside a group; when a group that contains a tab is present, the entire line typically vanishes.  The new implementation keeps the \fancyvrb\ behavior exactly for tabs outside groups; they are perfectly expanded to tab stops.  Tabs inside groups cannot be perfectly expanded to tab stops, at least not using the \fancyvrb\ approach.  Instead, when \fvextra\ encounters a run of whitespace characters (tabs and possibly spaces), it makes the assumption that the nearest tab stop was at the beginning of the run.  This gives the correct behavior if the whitespace characters are leading indentation that happens to be within a macro.  Otherwise, it will typically not give correct tab expansion---but at least the entire line will not be discarded, and the run of whitespace will be represented, even if imperfectly.
%
% A general solution to tab expansion may be possible, but will almost certainly require multiple compiles, perhaps even one compile (or more) per tab.  The \pkg{zref} package provides a |\zsaveposx| macro that stores the current $x$ position on the page for subsequent compiles.  This macro, or a similar macro from another package, could be used to establish a reference point at the beginning of each line.  Then each run of whitespace that contains a tab could have a reference point established at its start, and tabs could be expanded based on the distance between the start of the run and the start of the line.  Such an approach would allow the first run of whitespace to measure its distance from the start of the line on the 2nd compile (once both reference points were established), so it would be able expand the first run of whitespace correctly on the 3rd compile.  That would allow a second run of whitespace to definitely establish its starting point on the 3rd compile, which would allow it to expand correctly on the 4th compile.  And so on.  Thus, while it should be possible to perform completely correct tab expansion with such an approach, it will in general require at least 4 compiles to do better than the current approach.  Furthermore, the sketch of the algorithm provided so far does not include any complications introduced by line breaking.  In the current approach, it is necessary to determine how each tab would be expanded in the absence of line breaking, save all tab widths, and then expand using saved widths during the actual typesetting with line breaking.
%
%
% \begin{macro}{FV@TrueTabGroupLevel}
% Counter for keeping track of the group level (|\currentgrouplevel|) at the very beginning of a line, inside |\FancyVerbFormatLine| but outside |\FancyVerbFormatText|, which is where the tab expansion macro is invoked.  This allows us to determine whether we are in a group, and expand tabs accordingly.
%    \begin{macrocode}
\newcounter{FV@TrueTabGroupLevel}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@@ObeyTabs}
% The \fancyvrb\ macro responsible for tab expansion is modified so that it can handle tabs inside groups, even if imperfectly.  We need to use a special version of the space, |\FV@Space@ObeyTabs|, that within a group will capture all following spaces or tabs and then insert them with tab expansion based on the beginning of the run of whitespace.  We need to record the current group level, but then increment it by $1$ because all comparisons will be performed within the |\hbox{...}|.  The |\FV@TmpCurrentGroupLevel| is needed for compatibility with the \pkg{calc} package, which redefines |\setcounter|.
%    \begin{macrocode}
\def\FV@@ObeyTabs#1{%
  \let\FV@Space@Orig\FV@Space
  \let\FV@Space\FV@Space@ObeyTabs
  \edef\FV@TmpCurrentGroupLevel{\the\currentgrouplevel}%
  \setcounter{FV@TrueTabGroupLevel}{\FV@TmpCurrentGroupLevel}%
  \addtocounter{FV@TrueTabGroupLevel}{1}%
  \setbox\FV@TabBox=\hbox{#1}\box\FV@TabBox
  \let\FV@Space\FV@Space@Orig}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@TrueTab}
% Version that follows \fancyvrb\ if not in a group and takes another approach otherwise.
%    \begin{macrocode}
\def\FV@TrueTab{%
  \ifnum\value{FV@TrueTabGroupLevel}=\the\currentgrouplevel\relax
    \expandafter\FV@TrueTab@NoGroup
  \else
    \expandafter\FV@TrueTab@Group
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@TrueTabSaveWidth}
% When linebreaking is in use, the \fancyvrb\ tab expansion algorithm cannot be used directly, since it involves |\hbox|, which doesn't allow for line breaks.  In those cases, tab widths will be calculated for the case without breaks and saved, and then saved widths will be used in the actual typesetting.  This macro is |\let| to width-saving code in those cases.
%    \begin{macrocode}
\let\FV@TrueTabSaveWidth\relax
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FV@TrueTabCounter}
% Counter for tracking saved tabs.
%    \begin{macrocode}
\newcounter{FV@TrueTabCounter}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@TrueTabSaveWidth@Save}
% Save the current tab width, then increment the tab counter.  |\@tempdima| will hold the current tab width.
%    \begin{macrocode}
\def\FV@TrueTabSaveWidth@Save{%
  \expandafter\xdef\csname FV@TrueTab:Width\arabic{FV@TrueTabCounter}\endcsname{%
    \number\@tempdima}%
  \stepcounter{FV@TrueTabCounter}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@TrueTab@NoGroup}
% This follows the \fancyvrb\ approach exactly, except for the |\hbox to\@tempdima| adjustment and the addition of |\FV@TrueTabSaveWidth|.
%    \begin{macrocode}
\def\FV@TrueTab@NoGroup{%
  \egroup
  \@tempdima=\FV@ObeyTabSize sp\relax
  \@tempcnta=\wd\FV@TabBox
  \advance\@tempcnta\FV@@ObeyTabSize\relax
  \divide\@tempcnta\@tempdima
  \multiply\@tempdima\@tempcnta
  \advance\@tempdima-\wd\FV@TabBox
  \FV@TrueTabSaveWidth
  \setbox\FV@TabBox=\hbox\bgroup
    \unhbox\FV@TabBox\hbox to\@tempdima{\hss\FV@TabChar}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FV@ObeyTabs@Whitespace@Tab}
% In a group where runs of whitespace characters are collected, we need to keep track of whether a tab has been found, so we can avoid expansion and the associated |\hbox| for spaces without tabs.
%    \begin{macrocode}
\newbool{FV@ObeyTabs@Whitespace@Tab}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@TrueTab@Group}
% If in a group, a tab should start collecting whitespace characters for later tab expansion, beginning with itself.  The collected whitespace will use |\FV@FVTabToken| and |\FV@FVSpaceToken| so that any |\ifx| comparisons performed later will behave as expected.  This shouldn't be strictly necessary, because |\FancyVerbBreakStart| operates with saved tab widths rather than using the tab expansion code directly.  But it is safer in case any other unanticipated scanning is going on.
%    \begin{macrocode}
\def\FV@TrueTab@Group{%
  \booltrue{FV@ObeyTabs@Whitespace@Tab}%
  \gdef\FV@TmpWhitespace{\FV@FVTabToken}%
  \FV@ObeyTabs@ScanWhitespace}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Space@ObeyTabs}
% Space treatment, like tab treatment, now depends on whether we are in a group, because in a group we want to collect all runs of whitespace and then expand any tabs.
%    \begin{macrocode}
\def\FV@Space@ObeyTabs{%
  \ifnum\value{FV@TrueTabGroupLevel}=\the\currentgrouplevel\relax
    \expandafter\FV@Space@ObeyTabs@NoGroup
  \else
    \expandafter\FV@Space@ObeyTabs@Group
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@Space@ObeyTabs@NoGroup}
% Fall back to normal space.
%    \begin{macrocode}
\def\FV@Space@ObeyTabs@NoGroup{\FV@Space@Orig}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@Space@ObeyTabs@Group}
% Make a note that no tabs have yet been encountered, store the current space, then scan for following whitespace.
%    \begin{macrocode}
\def\FV@Space@ObeyTabs@Group{%
  \boolfalse{FV@ObeyTabs@Whitespace@Tab}%
  \gdef\FV@TmpWhitespace{\FV@FVSpaceToken}%
  \FV@ObeyTabs@ScanWhitespace}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@ObeyTabs@ScanWhitespace}
% Collect whitespace until the end of the run, then process it.  Proper lookahead comparison requires |\FV@FVSpaceToken| and |\FV@FVTabToken|.
%    \begin{macrocode}
\def\FV@ObeyTabs@ScanWhitespace{%
  \@ifnextchar\FV@FVSpaceToken%
   {\FV@TrueTab@CaptureWhitespace@Space}%
   {\ifx\@let@token\FV@FVTabToken
      \expandafter\FV@TrueTab@CaptureWhitespace@Tab
    \else
      \expandafter\FV@ObeyTabs@ResolveWhitespace
    \fi}}
\def\FV@TrueTab@CaptureWhitespace@Space#1{%
  \g@addto@macro\FV@TmpWhitespace{\FV@FVSpaceToken}%
  \FV@ObeyTabs@ScanWhitespace}
\def\FV@TrueTab@CaptureWhitespace@Tab#1{%
  \booltrue{FV@ObeyTabs@Whitespace@Tab}%
  \g@addto@macro\FV@TmpWhitespace{\FV@FVTabToken}%
  \FV@ObeyTabs@ScanWhitespace}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@TrueTab@Group@Expand}
% Yet another tab definition, this one for use in the actual expansion of tabs in whitespace.  This uses the \fancyvrb\ algorithm, but only over a restricted region known to contain no groups.
%    \begin{macrocode}
\newbox\FV@TabBox@Group
\def\FV@TrueTab@Group@Expand{%
  \egroup
  \@tempdima=\FV@ObeyTabSize sp\relax
  \@tempcnta=\wd\FV@TabBox@Group
  \advance\@tempcnta\FV@@ObeyTabSize\relax
  \divide\@tempcnta\@tempdima
  \multiply\@tempdima\@tempcnta
  \advance\@tempdima-\wd\FV@TabBox@Group
  \FV@TrueTabSaveWidth
  \setbox\FV@TabBox@Group=\hbox\bgroup
    \unhbox\FV@TabBox@Group\hbox to\@tempdima{\hss\FV@TabChar}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@ObeyTabs@ResolveWhitespace}
% Need to make sure the right definitions of the space and tab are in play here.  Only do tab expansion, with the associated |\hbox|, if a tab is indeed present.
%    \begin{macrocode}
\def\FV@ObeyTabs@ResolveWhitespace{%
  \let\FV@Space\FV@Space@Orig
  \let\FV@Tab\FV@TrueTab@Group@Expand
  \expandafter\FV@ObeyTabs@ResolveWhitespace@i\expandafter{\FV@TmpWhitespace}%
  \let\FV@Space\FV@Space@ObeyTabs
  \let\FV@Tab\FV@TrueTab}
\def\FV@ObeyTabs@ResolveWhitespace@i#1{%
  \ifbool{FV@ObeyTabs@Whitespace@Tab}%
   {\setbox\FV@TabBox@Group=\hbox{#1}\box\FV@TabBox@Group}%
   {#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Fonts and symbols in math mode}
%
% The single quote (\texttt{\textquotesingle}) does not become |^\prime| when typeset math is included within verbatim content, due to the definition of the character in |\@noligs|.  This patch adds a new definition of the character in math mode, inspired by \url{http://tex.stackexchange.com/q/223876/10742}.  It also redefines other characters in |\@noligs| to behave normally within math mode and switches the default font within math mode, so that \pkg{amsmath}'s |\text| will work as expected.
%
% \begin{macro}{\FV@pr@m@s}
% Define a version of |\pr@m@s| from |latex.ltx| that works with active \texttt{\textquotesingle}.  In verbatim contexts, \texttt{\textquotesingle} is made active by |\@noligs|.
%    \begin{macrocode}
\begingroup
\catcode`\'=\active
\catcode`\^=7
\gdef\FV@pr@m@s{%
  \ifx'\@let@token
    \expandafter\pr@@@s
  \else
    \ifx^\@let@token
      \expandafter\expandafter\expandafter\pr@@@t
    \else
      \egroup
    \fi
  \fi}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@SetupMathFont}
% Set the font back to default from the verbatim font.
%    \begin{macrocode}
\def\FV@SetupMathFont{%
  \everymath\expandafter{\the\everymath\fontfamily{\familydefault}\selectfont}}
\g@addto@macro\FV@FormattingPrep@PreHook{\FV@SetupMathFont}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@SetupMathActive}
% Make all characters in |\FVExtraDoSpecials| behave more normally within math.  This is for |mathescape| or when |$| has its normal catcode via |codes|.  This does not retokenize, so it can only provide a better approximation of regular math.
%
% At minimum, the characters in |\@noligs| will typically be made |\active| within verbatim contexts to produce literal versions of themselves.  The relevant definition from |latex.ltx|:
%\begin{verbatim}
%\def\verbatim@nolig@list{\do\`\do\<\do\>\do\,\do\'\do\-}
%\end{verbatim}
% It is also possible that additional characters will be made |\active| to produce literal versions of themselves or for other purposes.  These |\active| characters can interfere with math.
%
% The strategy here has three components:
% \begin{itemize}
% \item For a character in |\FVExtraDoSpecials| that is active before the verbatim context begins, save its definition.  Then restore this within math via |\everymath|.
% \item For a character in |\FVExtraDoSpecials| that is not active, but does have a |\mathcode| of |"8000|, save the active definition.  Then via |\everymath| define the active version of this character to give the saved active definition within math mode and a detokenized character otherwise.
% \item For a character in |\FVExtraDoSpecials| that is not active and does not have |a \mathcode| of |"8000|, use |\everymath| to define the active version of the character to give a detokenized character.
% \end{itemize}
%
% Detecting a |\mathcode| of |"8000| must be done in an engine-dependent manner.  Partial reference:  \url{https://tex.stackexchange.com/a/520122/10742}.
%
% Also switch to |\FV@pr@m@s| so that math prime |'| behaves as expected.
%    \begin{macrocode}
\begingroup
\expandafter\ifx\csname directlua\endcsname\relax
  \expandafter\ifx\csname XeTeXrevision\endcsname\relax
    \global\let\FV@mathcodenum\mathcode
    \gdef\FV@mathcodenumactive{32768}%
  \else
    \global\let\FV@mathcodenum\Umathcodenum
    \gdef\FV@mathcodenumactive{2097151}%
  \fi
\else
  \global\let\FV@mathcodenum\Umathcodenum
  \gdef\FV@mathcodenumactive{16777216}%
\fi
\endgroup
\def\FV@SetupMathActive{%
  \def\do##1{%
    \ifnum\catcode`##1=\active
      \expandafter\expandafter\expandafter\let\expandafter\expandafter\expandafter\FV@Tmp
        \csname FV@Char@CatActive:\number`##1\endcsname    
      \expandafter\let
        \csname FV@Char@Math:\number`##1\endcsname\FV@Tmp
    \else
      \ifnum\FV@mathcodenum`##1=\FV@mathcodenumactive\relax
        \expandafter\expandafter\expandafter\let\expandafter\expandafter\expandafter\FV@Tmp
          \csname FV@Char@CatActive:\number`##1\endcsname    
        \expandafter\let
          \csname FV@Char@MathActive:\number`##1\endcsname\FV@Tmp
        \expandafter
        \def\csname FV@Char@Math:\number`##1\endcsname{%
          \expandafter\ifmmode\expandafter\expandafter
            \csname FV@Char@MathActive:\number`##1\endcsname
          \else
            \expandafter\expandafter
            \csname FV@Char@CatDetok:\number`##1\endcsname
          \fi}%
      \else
        \expandafter\let\expandafter\FV@Tmp
          \csname FV@Char@CatDetok:\number`##1\endcsname
        \expandafter\let
          \csname FV@Char@Math:\number`##1\endcsname\FV@Tmp
      \fi
    \fi}%
  \FVExtraDoSpecials
  \everymath\expandafter{%
    \the\everymath
    \FV@ApplyMathActive}}
\def\FV@ApplyMathActive{%
  \let\pr@m@s\FV@pr@m@s
  \def\do##1{%
    \expandafter\let\expandafter\FV@Tmp
      \csname FV@Char@CatActive:\number`##1\endcsname
    \expandafter\expandafter\expandafter\let\expandafter\FV@Tmp
      \csname FV@Char@Math:\number`##1\endcsname}%
  \FVExtraDoSpecials}
\FV@AddToHook\FV@UseKeyValues@Hook{\FV@SetupMathActive}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Ophaned label}
%
% \begin{macro}{\FV@BeginListFrame@Lines}
% When |frame=lines| is used with a label, the label can be orphaned.  This overwrites the default definition to add |\penalty\@M|.  The fix is attributed to \url{http://tex.stackexchange.com/a/168021/10742}.
%    \begin{macrocode}
\def\FV@BeginListFrame@Lines{%
  \begingroup
  \lineskip\z@skip
  \FV@SingleFrameLine{\z@}%
  \kern-0.5\baselineskip\relax
  \baselineskip\z@skip
  \kern\FV@FrameSep\relax
  \penalty\@M
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{\texttt{rulecolor} and \texttt{fillcolor}}
%
% The |rulecolor| and |fillcolor| options are redefined so that they accept color names directly, rather than requiring |\color{|\meta{color\_name}|}|.  The definitions still allow the old usage.
%
% \begin{macro}{rulecolor}
%    \begin{macrocode}
\define@key{FV}{rulecolor}{%
  \ifstrempty{#1}%
   {\let\FancyVerbRuleColor\relax}%
   {\ifstrequal{#1}{none}%
     {\let\FancyVerbRuleColor\relax}%
     {\def\@tempa{#1}%
      \FV@KVProcess@RuleColor#1\FV@Undefined}}}
\def\FV@KVProcess@RuleColor#1#2\FV@Undefined{%
  \ifx#1\color
  \else
    \expandafter\def\expandafter\@tempa\expandafter{%
      \expandafter\color\expandafter{\@tempa}}%
  \fi
  \let\FancyVerbRuleColor\@tempa}
\fvset{rulecolor=none}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{fillcolor}
%    \begin{macrocode}
\define@key{FV}{fillcolor}{%
  \ifstrempty{#1}%
   {\let\FancyVerbFillColor\relax}%
   {\ifstrequal{#1}{none}%
     {\let\FancyVerbFillColor\relax}%
     {\def\@tempa{#1}%
      \FV@KVProcess@FillColor#1\FV@Undefined}}}
\def\FV@KVProcess@FillColor#1#2\FV@Undefined{%
  \ifx#1\color
  \else
    \expandafter\def\expandafter\@tempa\expandafter{%
      \expandafter\color\expandafter{\@tempa}}%
  \fi
  \let\FancyVerbFillColor\@tempa}
\fvset{fillcolor=none}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Extensions}
%
%
% \subsubsection{New options requiring minimal implementation}
% \label{sec:impl:extensions:options}
%
% \begin{macro}{linenos}
% \pkg{fancyvrb} allows line numbers via the options |numbers=left| and |numbers=right|.  This creates a |linenos| key that is essentially an alias for |numbers=left|.
%    \begin{macrocode}
\define@booleankey{FV}{linenos}%
  {\@nameuse{FV@Numbers@left}}{\@nameuse{FV@Numbers@none}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{tab}
% Redefine |\FancyVerbTab|.
%    \begin{macrocode}
\define@key{FV}{tab}{\def\FancyVerbTab{#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{tabcolor}
% Set tab color, or allow it to adjust to surroundings (the default \fancyvrb\ behavior).  This involves re-creating the |showtabs| option to add |\FV@TabColor|.
%    \begin{macrocode}
\define@key{FV}{tabcolor}%
 {\ifstrempty{#1}%
   {\let\FV@TabColor\relax}%
   {\ifstrequal{#1}{none}%
     {\let\FV@TabColor\relax}%
     {\def\FV@TabColor{\textcolor{#1}}}}}
\define@booleankey{FV}{showtabs}%
 {\def\FV@TabChar{\FV@TabColor{\FancyVerbTab}}}%
 {\let\FV@TabChar\relax}
\fvset{tabcolor=none, showtabs=false}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{showspaces, FV@showspaces}
% Reimplement |showspaces| with a bool to work with new space options.
%    \begin{macrocode}
\newbool{FV@showspaces}
\define@booleankey{FV}{showspaces}%
 {\booltrue{FV@showspaces}}%
 {\boolfalse{FV@showspaces}}
\fvset{showspaces=false}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{space}
% Redefine |\FancyVerbSpace|, which is the visible space.
%    \begin{macrocode}
\define@key{FV}{space}{\def\FancyVerbSpace{#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{spacecolor}
% Set space color, or allow it to adjust to surroundings (the default \fancyvrb\ behavior).  This involves re-creating the |showspaces| option to add |\FV@SpaceColor|.
%    \begin{macrocode}
\define@key{FV}{spacecolor}%
 {\ifstrempty{#1}%
   {\let\FV@SpaceColor\relax}%
   {\ifstrequal{#1}{none}%
     {\let\FV@SpaceColor\relax}%
     {\def\FV@SpaceColor{\textcolor{#1}}}}}
\fvset{spacecolor=none}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{spacebreak, \FancyVerbSpaceBreak}
% Line break for spaces that is inserted when spaces are visible (|showspaces=true|) or when breaks around spaces are handled specially (|breakcollapsespaces=false|).  Not used for regular spaces under default conditions.
%    \begin{macrocode}
\define@key{FV}{spacebreak}{%
  \def\FancyVerbSpaceBreak{#1}}
\fvset{spacebreak=\discretionary{}{}{}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{breakcollapsespaces, FV@breakcollapsespaces}
% When a line break occurs within a sequence of regular space characters (|showspaces=false|), collapse the spaces into a single space and then replace it with the break.  When this is |true|, a sequence of spaces will cause at most a single line break, and the first character on the wrapped line after the break will be a non-space character.  When this is |false|, a sequence of spaces may result in multiple line breaks.  Each wrapped line besides the last will contain only spaces.  The final wrapped line may contain leading spaces before any non-space character(s).
%    \begin{macrocode}
\newbool{FV@breakcollapsespaces}
\define@booleankey{FV}{breakcollapsespaces}%
 {\booltrue{FV@breakcollapsespaces}}%
 {\boolfalse{FV@breakcollapsespaces}}%
\fvset{breakcollapsespaces=true}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@DefFVSpace}
% Redefine |\FV@Space| based on \pkg{fvextra} options that affect spaces.
%
% This must be added to |\FV@FormattingPrep@PreHook|, but only after |breakbefore| and |breakafter| macros are defined.  Hence the |\AtEndOfPackage|.
%    \begin{macrocode}
\def\FV@DefFVSpace{%
  \ifbool{FV@showspaces}%
   {\ifbool{FV@breaklines}%
     {\ifcsname FV@BreakBefore@Token\FV@SpaceCatTen\endcsname
        \def\FV@Space{\FV@SpaceColor{\FancyVerbSpace}}%
      \else\ifcsname FV@BreakAfter@Token\FV@SpaceCatTen\endcsname
        \def\FV@Space{\FV@SpaceColor{\FancyVerbSpace}}%
      \else
        \def\FV@Space{\FV@SpaceColor{\FancyVerbSpace}\FancyVerbSpaceBreak}%
      \fi\fi}%
     {\def\FV@Space{\FV@SpaceColor{\FancyVerbSpace}}}}%
   {\ifbool{FV@breaklines}%
     {\ifcsname FV@BreakBefore@Token\FV@SpaceCatTen\endcsname
        \def\FV@Space{\mbox{\FV@SpaceCatTen}}%
      \else\ifcsname FV@BreakAfter@Token\FV@SpaceCatTen\endcsname
        \def\FV@Space{\mbox{\FV@SpaceCatTen}}%
      \else
        \ifbool{FV@breakcollapsespaces}%
         {\def\FV@Space{\FV@SpaceCatTen}}%
         {\def\FV@Space{\mbox{\FV@SpaceCatTen}\FancyVerbSpaceBreak}}%
      \fi\fi}%
     {\def\FV@Space{\FV@SpaceCatTen}}}}%
\AtEndOfPackage{%
  \g@addto@macro\FV@FormattingPrep@PreHook{\FV@DefFVSpace}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{mathescape}
% Give |$|, |&|, |^|, and |_| their normal catcodes to allow normal typeset math.
%    \begin{macrocode}
\define@booleankey{FV}{mathescape}%
 {\let\FancyVerbMathEscape\FV@MathEscape}%
 {\let\FancyVerbMathEscape\relax}
\def\FV@MathEscape{\catcode`\$=3\catcode`\&=4\catcode`\^=7\catcode`\_=8\relax}
\FV@AddToHook\FV@CatCodesHook\FancyVerbMathEscape
\fvset{mathescape=false}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{beameroverlays}
% Give |<| and |>| their normal catcodes (not |\active|), so that \pkg{beamer} overlays will work.  This modifies |\@noligs| because that is the only way to prevent the settings from being overwritten later.  This could have used |\FV@CatCodesHook|, but then it would have had to compare |\@noligs| to |\relax| to avoid issues when |\let\@noligs\relax| in |VerbatimOut|.
%    \begin{macrocode}
\define@booleankey{FV}{beameroverlays}%
 {\let\FancyVerbBeamerOverlays\FV@BeamerOverlays}%
 {\let\FancyVerbBeamerOverlays\relax}
\def\FV@BeamerOverlays{%
  \expandafter\def\expandafter\@noligs\expandafter{\@noligs
    \catcode`\<=12\catcode`\>=12\relax}}
\FV@AddToHook\FV@FormattingPrep@PreHook\FancyVerbBeamerOverlays
\fvset{beameroverlays=false}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{curlyquotes}
% Let \texttt{\textasciigrave} and \texttt{\textquotesingle} produce curly quotation marks \texttt{`} and \texttt{'} rather than the backtick and typewriter single quotation mark produced by default via \pkg{upquote}.
%    \begin{macrocode}
\newbool{FV@CurlyQuotes}
\define@booleankey{FV}{curlyquotes}%
 {\booltrue{FV@CurlyQuotes}}%
 {\boolfalse{FV@CurlyQuotes}}
\def\FancyVerbCurlyQuotes{%
  \ifbool{FV@CurlyQuotes}%
   {\expandafter\def\expandafter\@noligs\expandafter{\@noligs
      \begingroup\lccode`\~=`\`\lowercase{\endgroup\def~}{`}%
      \begingroup\lccode`\~=`\'\lowercase{\endgroup\def~}{'}}}%
   {}}
\g@addto@macro\FV@FormattingPrep@PreHook{\FancyVerbCurlyQuotes}
\fvset{curlyquotes=false}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{fontencoding}
% Add option for font encoding.
%    \begin{macrocode}
\define@key{FV}{fontencoding}%
 {\ifstrempty{#1}%
   {\let\FV@FontEncoding\relax}%
   {\ifstrequal{#1}{none}%
     {\let\FV@FontEncoding\relax}%
     {\def\FV@FontEncoding{\fontencoding{#1}}}}}
\expandafter\def\expandafter\FV@SetupFont\expandafter{%
  \expandafter\FV@FontEncoding\FV@SetupFont}
\fvset{fontencoding=none}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Formatting with \texttt{\textbackslash FancyVerbFormatLine}, \texttt{\textbackslash FancyVerbFormatText}, and \texttt{\textbackslash FancyVerbHighlightLine}}
%
% \fancyvrb\ defines |\FancyVerbFormatLine|, which defines the formatting for each line. The introduction of line breaks introduces an issue for |\FancyVerbFormatLine|.  Does it format the entire line, including any whitespace in the margins or behind line break symbols (that is, is it outside the |\parbox| in which the entire line is wrapped when breaking is active)?  Or does it only format the text part of the line, only affecting the actual characters (inside the |\parbox|)?  Since both might be desirable, |\FancyVerbFormatLine| is assigned to the entire line, and a new macro |\FancyVerbFormatText| is assigned to the text, within the |\parbox|.
%
% An additional complication is that the \fancyvrb\ documentation says that the default value is |\def\FancyVerbFormatLine#1{#1}|.  But the actual default is |\def\FancyVerbFormatLine#1{\FV@ObeyTabs{#1}}|.  That is, |\FV@ObeyTabs| needs to operate directly on the line to handle tabs.  As a result, \emph{all} \fancyvrb\ commands that involve |\FancyVerbFormatLine| are patched, so that |\def\FancyVerbFormatLine#1{#1}|.
%
% An additional macro |\FancyVerbHighlightLine| is added between |\FancyVerbFormatLine| and |\FancyVerbFormatText|.  This is used to highlight selected lines (\cref{sec:impl:extensions:highlighting}).  It is inside |\FancyVerbHighlightLine| so that if |\FancyVerbHighlightLine| is used to provide a background color, |\FancyVerbHighlightLine| can override it.
%
% \begin{macro}{\FancyVerbFormatLine}
% Format the entire line, following the definition given in the \fancyvrb\ documentation.  Because this is formatting the entire line, using boxes works with line breaking.
%    \begin{macrocode}
\def\FancyVerbFormatLine#1{#1}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FancyVerbFormatText}
% Format only the text part of the line.  Because this is inside all of the line breaking commands, using boxes here can conflict with line breaking.
%    \begin{macrocode}
\def\FancyVerbFormatText#1{#1}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@ListProcessLine@NoBreak}
% Redefined |\FV@ListProcessLine| in which |bgcolor| support is added, |\FancyVerbFormatText| is added, and tab handling is explicit.  The |@NoBreak| suffix is added because |\FV@ListProcessLine| will be |\let| to either this macro or to |\FV@ListProcessLine@Break| depending on whether line breaking is enabled.
%    \begin{macrocode}
\def\FV@ListProcessLine@NoBreak#1{%
  \hbox to \hsize{%
    \kern\leftmargin
    \hbox to \linewidth{%
      \FV@LeftListNumber
      \FV@LeftListFrame
      \FV@BGColor@List{%
        \FancyVerbFormatLine{%
          \FancyVerbHighlightLine{%
            \FV@ObeyTabs{\FancyVerbFormatText{#1}}}}}\hss
      \FV@RightListFrame
      \FV@RightListNumber}%
    \hss}\FV@bgcoloroverlap}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BProcessLine}
% Redefined |\FV@BProcessLine| in which |\FancyVerbFormatText| is added and tab handling is explicit.
%    \begin{macrocode}
\def\FV@BProcessLine#1{%
  \hbox{\FancyVerbFormatLine{%
    \ifx\FancyVerbBackgroundColor\relax
    \else
      \expandafter\FancyVerbBackgroundColorVPhantom
    \fi
    \FancyVerbHighlightLine{%
      \FV@ObeyTabs{\FancyVerbFormatText{#1}}}}}}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Line numbering}
%
% Add several new line numbering options.  |numberfirstline| always numbers the first line, regardless of |stepnumber|.  |stepnumberfromfirst| numbers the first line, and then every line that differs from its number by a multiple of |stepnumber|.  |stepnumberoffsetvalues| determines whether line number are always an exact multiple of |stepnumber| (the new default behavior) or whether there is an offset when |firstnumber| $\ne 1$ (the old default behavior).  A new option |numbers=both| is created to allow line numbers on both left and right simultaneously.
%
% \begin{macro}{FV@NumberFirstLine}
%    \begin{macrocode}
\newbool{FV@NumberFirstLine}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{numberfirstline}
%    \begin{macrocode}
\define@booleankey{FV}{numberfirstline}%
 {\booltrue{FV@NumberFirstLine}}%
 {\boolfalse{FV@NumberFirstLine}}
\fvset{numberfirstline=false}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FV@StepNumberFromFirst}
%    \begin{macrocode}
\newbool{FV@StepNumberFromFirst}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{stepnumberfromfirst}
%    \begin{macrocode}
\define@booleankey{FV}{stepnumberfromfirst}%
 {\booltrue{FV@StepNumberFromFirst}}%
 {\boolfalse{FV@StepNumberFromFirst}}
\fvset{stepnumberfromfirst=false}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FV@StepNumberOffsetValues}
%    \begin{macrocode}
\newbool{FV@StepNumberOffsetValues}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{stepnumberoffsetvalues}
%    \begin{macrocode}
\define@booleankey{FV}{stepnumberoffsetvalues}%
 {\booltrue{FV@StepNumberOffsetValues}}%
 {\boolfalse{FV@StepNumberOffsetValues}}
\fvset{stepnumberoffsetvalues=false}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Numbers@left}
% Redefine \fancyvrb\ macro to account for |numberfirstline|, |stepnumberfromfirst|, and |stepnumberoffsetvalues|.  The |\let\FancyVerbStartNum\@ne| is needed to account for the case where |firstline| is never set, and defaults to zero (|\z@|).
%    \begin{macrocode}
\def\FV@Numbers@left{%
  \let\FV@RightListNumber\relax
  \def\FV@LeftListNumber{%
    \ifx\FancyVerbStartNum\z@
      \let\FancyVerbStartNum\@ne
    \fi
    \ifbool{FV@StepNumberFromFirst}%
     {\@tempcnta=\FV@CodeLineNo
      \@tempcntb=\FancyVerbStartNum
      \advance\@tempcntb\FV@StepNumber
      \divide\@tempcntb\FV@StepNumber
      \multiply\@tempcntb\FV@StepNumber
      \advance\@tempcnta\@tempcntb
      \advance\@tempcnta-\FancyVerbStartNum
      \@tempcntb=\@tempcnta}%
     {\ifbool{FV@StepNumberOffsetValues}%
       {\@tempcnta=\FV@CodeLineNo
        \@tempcntb=\FV@CodeLineNo}%
       {\@tempcnta=\c@FancyVerbLine
        \@tempcntb=\c@FancyVerbLine}}%
    \divide\@tempcntb\FV@StepNumber
    \multiply\@tempcntb\FV@StepNumber
    \ifnum\@tempcnta=\@tempcntb
      \if@FV@NumberBlankLines
        \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
      \else
        \ifx\FV@Line\empty
        \else
          \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
        \fi
      \fi
    \else
      \ifbool{FV@NumberFirstLine}{%
        \ifnum\FV@CodeLineNo=\FancyVerbStartNum
          \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
        \fi}{}%
    \fi}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Numbers@right}
% Redefine \fancyvrb\ macro to account for |numberfirstline|, |stepnumberfromfirst|, and |stepnumberoffsetvalues|.
%    \begin{macrocode}
\def\FV@Numbers@right{%
  \let\FV@LeftListNumber\relax
  \def\FV@RightListNumber{%
    \ifx\FancyVerbStartNum\z@
      \let\FancyVerbStartNum\@ne
    \fi
    \ifbool{FV@StepNumberFromFirst}%
     {\@tempcnta=\FV@CodeLineNo
      \@tempcntb=\FancyVerbStartNum
      \advance\@tempcntb\FV@StepNumber
      \divide\@tempcntb\FV@StepNumber
      \multiply\@tempcntb\FV@StepNumber
      \advance\@tempcnta\@tempcntb
      \advance\@tempcnta-\FancyVerbStartNum
      \@tempcntb=\@tempcnta}%
     {\ifbool{FV@StepNumberOffsetValues}%
       {\@tempcnta=\FV@CodeLineNo
        \@tempcntb=\FV@CodeLineNo}%
       {\@tempcnta=\c@FancyVerbLine
        \@tempcntb=\c@FancyVerbLine}}%
    \divide\@tempcntb\FV@StepNumber
    \multiply\@tempcntb\FV@StepNumber
    \ifnum\@tempcnta=\@tempcntb
      \if@FV@NumberBlankLines
        \hbox to\z@{\kern\FV@NumberSep\theFancyVerbLine\hss}%
      \else
        \ifx\FV@Line\empty
        \else
          \hbox to\z@{\kern\FV@NumberSep\theFancyVerbLine\hss}%
        \fi
      \fi
    \else
      \ifbool{FV@NumberFirstLine}{%
        \ifnum\FV@CodeLineNo=\FancyVerbStartNum
          \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
        \fi}{}%
    \fi}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Numbers@both}
% Define a new macro to allow |numbers=both|.  This copies the definitions of |\FV@LeftListNumber| and |\FV@RightListNumber| from |\FV@Numbers@left| and |\FV@Numbers@right|, without the |\relax|'s.
%    \begin{macrocode}
\def\FV@Numbers@both{%
  \def\FV@LeftListNumber{%
    \ifx\FancyVerbStartNum\z@
      \let\FancyVerbStartNum\@ne
    \fi
    \ifbool{FV@StepNumberFromFirst}%
     {\@tempcnta=\FV@CodeLineNo
      \@tempcntb=\FancyVerbStartNum
      \advance\@tempcntb\FV@StepNumber
      \divide\@tempcntb\FV@StepNumber
      \multiply\@tempcntb\FV@StepNumber
      \advance\@tempcnta\@tempcntb
      \advance\@tempcnta-\FancyVerbStartNum
      \@tempcntb=\@tempcnta}%
     {\ifbool{FV@StepNumberOffsetValues}%
       {\@tempcnta=\FV@CodeLineNo
        \@tempcntb=\FV@CodeLineNo}%
       {\@tempcnta=\c@FancyVerbLine
        \@tempcntb=\c@FancyVerbLine}}%
    \divide\@tempcntb\FV@StepNumber
    \multiply\@tempcntb\FV@StepNumber
    \ifnum\@tempcnta=\@tempcntb
      \if@FV@NumberBlankLines
        \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
      \else
        \ifx\FV@Line\empty
        \else
          \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
        \fi
      \fi
    \else
      \ifbool{FV@NumberFirstLine}{%
        \ifnum\FV@CodeLineNo=\FancyVerbStartNum
          \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
        \fi}{}%
    \fi}%
  \def\FV@RightListNumber{%
    \ifx\FancyVerbStartNum\z@
      \let\FancyVerbStartNum\@ne
    \fi
    \ifbool{FV@StepNumberFromFirst}%
     {\@tempcnta=\FV@CodeLineNo
      \@tempcntb=\FancyVerbStartNum
      \advance\@tempcntb\FV@StepNumber
      \divide\@tempcntb\FV@StepNumber
      \multiply\@tempcntb\FV@StepNumber
      \advance\@tempcnta\@tempcntb
      \advance\@tempcnta-\FancyVerbStartNum
      \@tempcntb=\@tempcnta}%
     {\ifbool{FV@StepNumberOffsetValues}%
       {\@tempcnta=\FV@CodeLineNo
        \@tempcntb=\FV@CodeLineNo}%
       {\@tempcnta=\c@FancyVerbLine
        \@tempcntb=\c@FancyVerbLine}}%
    \divide\@tempcntb\FV@StepNumber
    \multiply\@tempcntb\FV@StepNumber
    \ifnum\@tempcnta=\@tempcntb
      \if@FV@NumberBlankLines
        \hbox to\z@{\kern\FV@NumberSep\theFancyVerbLine\hss}%
      \else
        \ifx\FV@Line\empty
        \else
          \hbox to\z@{\kern\FV@NumberSep\theFancyVerbLine\hss}%
        \fi
      \fi
    \else
      \ifbool{FV@NumberFirstLine}{%
        \ifnum\FV@CodeLineNo=\FancyVerbStartNum
          \hbox to\z@{\hss\theFancyVerbLine\kern\FV@NumberSep}%
        \fi}{}%
    \fi}%
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Background color}
% \label{sec:impl:extensions:bgcolor}
%
% Define an option |backgroundcolor| that provides a basic implementation of a background color behind commands and environments.  \pkg{tcolorbox} or a similar package should be used for more sophisticated background colors.
%
% The patch to |\FV@List| prevents narrow horizontal gaps in the background color between lines of text under some circumstances.  The |\ExplSyntax*| is for compatibility with patches from the \LaTeX\ Tagged PDF project.
% \begin{macro}{backgroundcolor,bgcolor,\FancyVerbBackgroundColor}
%    \begin{macrocode}
\define@key{FV}{backgroundcolor}{%
  \def\FancyVerbBackgroundColor{#1}%
  \ifx\FancyVerbBackgroundColor\FV@None
    \let\FancyVerbBackgroundColor\relax
  \else\ifx\FancyVerbBackgroundColor\@empty
    \let\FancyVerbBackgroundColor\relax
  \fi\fi}%
\fvset{backgroundcolor=none}
\define@key{FV}{bgcolor}{%
  \fvset{backgroundcolor=#1}}
\ExplSyntaxOn
\patchcmd{\FV@List}%
 {\FV@ObeyTabsInit}%
 {\FV@ObeyTabsInit
  \ifx\FancyVerbBackgroundColor\relax
  \else
    \lineskip\z@
  \fi}%
 {}%
 {\PackageError{fvextra}%
   {Failed~to~patch~\detokenize{\FV@List}for~backgroundcolor}%
   {Failed~to~patch~\detokenize{\FV@List}for~backgroundcolor}}
\ExplSyntaxOff
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{backgroundcolorboxoverlap, bgcolorboxoverlap, \FV@backgroundcolorboxoverlap, \FV@bgcolorstrut, \FV@bgcoloroverlap}
%    \begin{macrocode}
\define@key{FV}{backgroundcolorboxoverlap}{%
  \ifdim#1=0pt\relax
    \let\FV@backgroundcolorboxoverlap\relax
  \else
    \def\FV@backgroundcolorboxoverlap{#1}%
  \fi}
\fvset{backgroundcolorboxoverlap=0.25pt}
\define@key{FV}{bgcolorboxoverlap}{%
  \fvset{backgroundcolorboxoverlap=#1}}
\newsavebox{\FV@bgcolorstructbox}
\def\FV@bgcolorstrut{%
  \ifx\FancyVerbBackgroundColor\relax
    \FancyVerbBackgroundColorVPhantom\strut
  \else\ifx\FV@backgroundcolorboxoverlap\relax
    \FancyVerbBackgroundColorVPhantom\strut
  \else
    \savebox{\FV@bgcolorstructbox}{\hbox{\FancyVerbBackgroundColorVPhantom\strut}}%
    \vrule height \ht\FV@bgcolorstructbox
           depth \dimexpr\dp\FV@bgcolorstructbox+\FV@backgroundcolorboxoverlap\relax
           width 0pt\relax
  \fi\fi}
\def\FV@bgcoloroverlap{%
  \ifx\FV@backgroundcolorboxoverlap\relax
  \else
    \vspace{-\FV@backgroundcolorboxoverlap}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{backgroundcolorvphantom,bgcolorvphantom,\FancyVerbBackgroundColorVPhantom}
%    \begin{macrocode}
\define@key{FV}{backgroundcolorvphantom}{%
  \def\FancyVerbBackgroundColorVPhantom{#1}%
  \ifx\FancyVerbBackgroundColorVPhantom\FV@None
    \let\FancyVerbBackgroundColorVPhantom\relax
  \else\ifx\FancyVerbBackgroundColorVPhantom\@empty
    \let\FancyVerbBackgroundColorVPhantom\relax
  \fi\fi}
\fvset{backgroundcolorvphantom=\vphantom{\"Apgjy}}
\define@key{FV}{bgcolorvphantom}{%
  \fvset{backgroundcolorvphantom=#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{backgroundcolorpadding, bgcolorpadding, \FancyVerbBackgroundColorPadding}
%    \begin{macrocode}
\let\FancyVerbBackgroundColorPadding\relax
\def\FV@backgroundcolorpadding@none@framenotsingle{%
  \fvset{frame=none,framerule,rulecolor=none}}
\def\FV@backgroundcolorpadding@dim@framenotsingle{%
  \fvset{frame=single,framerule=0pt,rulecolor=\FancyVerbBackgroundColor}}
\define@key{FV}{backgroundcolorpadding}{%
  \def\FancyVerbBackgroundColorPadding{#1}%
  \ifx\FancyVerbBackgroundColorPadding\FV@None
    \let\FancyVerbBackgroundColorPadding\relax
  \else\ifx\FancyVerbBackgroundColorPadding\@empty
    \let\FancyVerbBackgroundColorPadding\relax
  \fi\fi
  \let\FV@Next\relax
  \ifx\FancyVerbBackgroundColorPadding\relax
    \ifx\FV@BeginListFrame\FV@BeginListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@none@framenotsingle
    \fi
    \ifx\FV@LeftListFrame\FV@LeftListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@none@framenotsingle
    \fi
    \ifx\FV@RightListFrame\FV@RightListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@none@framenotsingle
    \fi
    \ifx\FV@EndListFrame\FV@EndListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@none@framenotsingle
    \fi
    \FV@Next
    \fvset{framesep,fillcolor=none}%
  \else
    \ifx\FV@BeginListFrame\FV@BeginListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@dim@framenotsingle
    \fi
    \ifx\FV@LeftListFrame\FV@LeftListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@dim@framenotsingle
    \fi
    \ifx\FV@RightListFrame\FV@RightListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@dim@framenotsingle
    \fi
    \ifx\FV@EndListFrame\FV@EndListFrame@Single
    \else
      \let\FV@Next\FV@backgroundcolorpadding@dim@framenotsingle
    \fi
    \FV@Next
    \fvset{framesep=#1,fillcolor=\FancyVerbBackgroundColor}%
  \fi}
\define@key{FV}{bgcolorpadding}{\fvset{backgroundcolorpadding=#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BGColor@List}
% Background color for environments based on |Verbatim|.  Puts each line in a colorbox.
%    \begin{macrocode}
\def\FV@BGColor@List#1{%
  \ifx\FancyVerbBackgroundColor\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
   {#1}%
   {\setlength{\FV@TmpLength}{\fboxsep}%
    \setlength{\fboxsep}{0pt}%
    \colorbox{\FancyVerbBackgroundColor}{%
      \setlength{\fboxsep}{\FV@TmpLength}%
      \rlap{\FV@bgcolorstrut#1}%
      \hspace{\linewidth}%
      \ifx\FV@RightListFrame\relax\else
        \hspace{-\FV@FrameSep}%
        \hspace{-\FV@FrameRule}%
      \fi
      \ifx\FV@LeftListFrame\relax\else
        \hspace{-\FV@FrameSep}%
        \hspace{-\FV@FrameRule}%
      \fi}%
    \hss}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BVerbatimBegin,\FV@BVerbatimEnd}
% Reimplementation of |BVerbatim| macros to support |bgcolor|.  Much of this follows the implementation of |SaveVerbatim| and |\BUseVerbatim|.
%
% Key values, formatting, and tabs must be configured immediately in the |bgcolor| case, so that the background color and other settings are available.  |\FV@UseKeyValues| can be invoked multiple times, but that doesn't cause any issues since |\FV@UseKeyValues| applies keys and then redefines |\FV@KeyValues| to empty.
%
% The definition of |\FV@BProcessLine| already accounts for |\FancyVerbBackgroundColorVPhantom|.
%    \begin{macrocode}
\let\FV@BVerbatimBegin@NoBGColor\FV@BVerbatimBegin
\let\FV@BVerbatimEnd@NoBGColor\FV@BVerbatimEnd
\def\FV@BVerbatimBegin{%
  \begingroup
  \FV@UseKeyValues
  \FV@FormattingPrep
  \let\FV@FormattingPrep\relax
  \FV@ObeyTabsInit
  \let\FV@ObeyTabsInit\relax
  \ifx\FancyVerbBackgroundColor\relax
    \expandafter\FV@BVerbatimBegin@NoBGColor
  \else
    \expandafter\FV@BVerbatimBegin@BGColor
  \fi}
\def\FV@BVerbatimEnd{%
  \ifx\FancyVerbBackgroundColor\relax
    \expandafter\FV@BVerbatimEnd@NoBGColor
  \else
    \expandafter\FV@BVerbatimEnd@BGColor
  \fi
  \endgroup}
\def\FV@BVerbatimBegin@BGColor{%
  \gdef\FV@TheVerbatim{}%
  \ifx\FV@boxwidth\relax
    \gdef\FV@boxwidth@tmp{0pt}%
    \def\FV@ProcessLine##1{%
      \sbox{\FV@LineBox}{\FV@BProcessLine{##1}}%
      \ifdim\wd\FV@LineBox>\FV@boxwidth@tmp\relax
        \xdef\FV@boxwidth@tmp{\the\wd\FV@LineBox}%
      \fi
      \expandafter\gdef\expandafter\FV@TheVerbatim\expandafter{%
        \FV@TheVerbatim\FV@ProcessLine{##1}}}%
  \else
    \def\FV@ProcessLine##1{%
      \expandafter\gdef\expandafter\FV@TheVerbatim\expandafter{%
        \FV@TheVerbatim\FV@ProcessLine{##1}}}%
  \fi}
\def\FV@BVerbatimEnd@BGColor{%
  \ifx\FV@boxwidth\relax
    \let\FV@boxwidth\FV@boxwidth@tmp
    \global\let\FV@boxwidth@tmp\FV@Undefined
  \fi
  \setlength{\FV@TmpLength}{\fboxsep}%
  \ifx\FancyVerbBackgroundColorPadding\relax
    \setlength{\fboxsep}{0pt}%
  \else
    \setlength{\fboxsep}{\FancyVerbBackgroundColorPadding}%
  \fi
  \colorbox{\FancyVerbBackgroundColor}{%
    \setlength{\fboxsep}{\FV@TmpLength}%
    \FV@BVerbatimBegin@NoBGColor\FV@TheVerbatim\FV@BVerbatimEnd@NoBGColor}%
  \gdef\FV@TheVerbatim{}}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Line highlighting or emphasis}
% \label{sec:impl:extensions:highlighting}
%
% This adds an option |highlightlines| that allows specific lines, or lines within a range, to be highlighted or otherwise emphasized.
%
% \begin{macro}{highlightlines}\begin{macro}{\FV@HighlightLinesList}
%    \begin{macrocode}
\define@key{FV}{highlightlines}{\def\FV@HighlightLinesList{#1}}%
\fvset{highlightlines=}
%    \end{macrocode}
% \end{macro}\end{macro}
%
% \begin{macro}{highlightcolor}\begin{macro}{\FV@HighlightColor}
% Define color for highlighting.  The default is LightCyan.  A good alternative for a brighter color would be LemonChiffon.
%    \begin{macrocode}
\define@key{FV}{highlightcolor}{\def\FancyVerbHighlightColor{#1}}%
\let\FancyVerbHighlightColor\@empty
\ifcsname definecolor\endcsname
\ifx\definecolor\relax
\else
  \definecolor{FancyVerbHighlightColor}{rgb}{0.878, 1, 1}
  \fvset{highlightcolor=FancyVerbHighlightColor}
\fi\fi
\AtBeginDocument{%
  \ifx\FancyVerbHighlightColor\@empty
    \ifcsname definecolor\endcsname
    \ifx\definecolor\relax
    \else
    \definecolor{FancyVerbHighlightColor}{rgb}{0.878, 1, 1}
    \fvset{highlightcolor=FancyVerbHighlightColor}
    \fi\fi
  \fi}
%    \end{macrocode}
% \end{macro}\end{macro}
%
%
% \begin{macro}{\FancyVerbHighlightLine}
% This is the entry macro into line highlighting.  By default it should do nothing.  It is always invoked between |\FancyVerbFormatLine| and |\FancyVerbFormatText|, so that it can provide a background color (won't interfere with line breaking) and can override any formatting provided by |\FancyVerbFormatLine|.  It is |\let| to |\FV@HighlightLine| when highlighting is active.
%    \begin{macrocode}
\def\FancyVerbHighlightLine#1{#1}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@HighlightLine}
% This determines whether highlighting should be performed, and if so, which macro should be invoked.
%    \begin{macrocode}
\def\FV@HighlightLine#1{%
  \@tempcnta=\c@FancyVerbLine
  \@tempcntb=\c@FancyVerbLine
  \ifcsname FV@HighlightLine:\number\@tempcnta\endcsname
    \advance\@tempcntb\m@ne
    \ifcsname FV@HighlightLine:\number\@tempcntb\endcsname
      \advance\@tempcntb\tw@
      \ifcsname FV@HighlightLine:\number\@tempcntb\endcsname
        \let\FV@HighlightLine@Next\FancyVerbHighlightLineMiddle
      \else
        \let\FV@HighlightLine@Next\FancyVerbHighlightLineLast
      \fi
    \else
      \advance\@tempcntb\tw@
      \ifcsname FV@HighlightLine:\number\@tempcntb\endcsname
        \let\FV@HighlightLine@Next\FancyVerbHighlightLineFirst
      \else
        \let\FV@HighlightLine@Next\FancyVerbHighlightLineSingle
      \fi
    \fi
  \else
    \let\FV@HighlightLine@Next\FancyVerbHighlightLineNormal
  \fi
  \FV@HighlightLine@Next{#1}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbHighlightLineNormal}
% A normal line that is not highlighted or otherwise emphasized.  This could be redefined to de-emphasize the line.
%    \begin{macrocode}
\def\FancyVerbHighlightLineNormal#1{#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@TmpLength}
%    \begin{macrocode}
\newlength{\FV@TmpLength}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbHighlightLineFirst}
% The first line in a multi-line range.
%
% |\fboxsep| is set to zero so as to avoid indenting the line or changing inter-line spacing.  It is restored to its original value inside to prevent any undesired effects.  The |\strut| is needed to get the highlighting to be the appropriate height.  The |\rlap| and |\hspace| make the |\colorbox| expand to the full |\linewidth|.  Note that if |\fboxsep| $\ne0$, then we would want to use |\dimexpr\linewidth-2\fboxsep| or add |\hspace{-2\fboxsep}| at the end.
%
% If this macro is customized so that the text cannot take up the full |\linewidth|, then adjustments may need to be made here or in the line breaking code to make sure that line breaking takes place at the appropriate location.
%    \begin{macrocode}
\def\FancyVerbHighlightLineFirst#1{%
  \setlength{\FV@TmpLength}{\fboxsep}%
  \setlength{\fboxsep}{0pt}%
  \colorbox{\FancyVerbHighlightColor}{%
    \setlength{\fboxsep}{\FV@TmpLength}%
    \rlap{\strut#1}%
    \hspace{\linewidth}%
    \ifx\FV@RightListFrame\relax\else
      \hspace{-\FV@FrameSep}%
      \hspace{-\FV@FrameRule}%
    \fi
    \ifx\FV@LeftListFrame\relax\else
      \hspace{-\FV@FrameSep}%
      \hspace{-\FV@FrameRule}%
    \fi
  }%
  \hss
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbHighlightLineMiddle}
% A middle line in a multi-line range.
%    \begin{macrocode}
\let\FancyVerbHighlightLineMiddle\FancyVerbHighlightLineFirst
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbHighlightLineLast}
% The last line in a multi-line range.
%    \begin{macrocode}
\let\FancyVerbHighlightLineLast\FancyVerbHighlightLineFirst
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbHighlightLineSingle}
% A single line not in a multi-line range.
%    \begin{macrocode}
\let\FancyVerbHighlightLineSingle\FancyVerbHighlightLineFirst
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@HighlightLinesPrep}
% Process the list of lines to highlight (if any).  A macro is created for each line to be highlighted.  During highlighting, a line is highlighted if the corresponding macro exists.  All of the macro creating is ultimately within the current environment group so it stays local.  |\FancyVerbHighlightLine| is |\let| to a version that will invoke the necessary logic.
%    \begin{macrocode}
\def\FV@HighlightLinesPrep{%
  \ifx\FV@HighlightLinesList\@empty
  \else
    \let\FancyVerbHighlightLine\FV@HighlightLine
    \expandafter\FV@HighlightLinesPrep@i
  \fi}
\def\FV@HighlightLinesPrep@i{%
  \renewcommand{\do}[1]{%
    \ifstrempty{##1}{}{\FV@HighlightLinesParse##1-\FV@Undefined}}%
  \expandafter\docsvlist\expandafter{\FV@HighlightLinesList}}
\def\FV@HighlightLinesParse#1-#2\FV@Undefined{%
  \ifstrempty{#2}%
   {\FV@HighlightLinesParse@Single{#1}}%
   {\FV@HighlightLinesParse@Range{#1}#2\relax}}
\def\FV@HighlightLinesParse@Single#1{%
  \expandafter\let\csname FV@HighlightLine:\detokenize{#1}\endcsname\relax}
\newcounter{FV@HighlightLinesStart}
\newcounter{FV@HighlightLinesStop}
\def\FV@HighlightLinesParse@Range#1#2-{%
  \setcounter{FV@HighlightLinesStart}{#1}%
  \setcounter{FV@HighlightLinesStop}{#2}%
  \stepcounter{FV@HighlightLinesStop}%
  \FV@HighlightLinesParse@Range@Loop}
\def\FV@HighlightLinesParse@Range@Loop{%
  \ifnum\value{FV@HighlightLinesStart}<\value{FV@HighlightLinesStop}\relax
    \expandafter\let\csname FV@HighlightLine:\arabic{FV@HighlightLinesStart}\endcsname\relax
    \stepcounter{FV@HighlightLinesStart}%
    \expandafter\FV@HighlightLinesParse@Range@Loop
  \fi}
\g@addto@macro\FV@FormattingPrep@PreHook{\FV@HighlightLinesPrep}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@StepLineNo@Patch@HighlightLine}
% Patch |\FV@StepLineNo| so that when |numberblanklines=false|, blank lines won't be highlighted.  If the previous line is at the end of a highlighted range, then |\let| |\FV@HighlightLine:<n>| to |\FV@Undefined| to prevent further highlighting.  Otherwise, leave everything as-is since the blank line(s) are within a highlighted range.
%    \begin{macrocode}
\def\FV@StepLineNo@Patch@HighlightLine{%
  \ifcsname FV@HighlightLine:\number\c@FancyVerbLine\endcsname
    \@tempcnta=\c@FancyVerbLine
    \advance\@tempcnta\@ne
    \ifcsname FV@HighlightLine:\number\@tempcnta\endcsname
    \else
      \expandafter\let
        \csname FV@HighlightLine:\number\c@FancyVerbLine\endcsname\FV@Undefined
    \fi
  \fi}
\patchcmd{\FV@StepLineNo}%
 {\ifx\FV@Line\empty}%
 {\ifx\FV@Line\empty\FV@StepLineNo@Patch@HighlightLine}%
 {}%
 {\PackageError{fvextra}%
   {Failed to patch \string\FV@StepLineNo\ to make highlightlines
    compatible with numberblanklines}%
   {Failed to patch \string\FV@StepLineNo\ to make highlightlines
    compatible with numberblanklines}}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Line breaking}
%
% The following code adds automatic line breaking functionality to \pkg{fancyvrb}'s |Verbatim| environment.  Automatic breaks may be inserted after spaces, or before or after specified characters.  Breaking before or after specified characters involves scanning each line token by token to insert |\discretionary| at all potential break locations.
%
%
% \subsubsection{Options and associated macros}
% Begin by defining keys, with associated macros, bools, and dimens.
%
% \begin{macro}{\FV@SetToWidthNChars}
% Set a dimen to the width of a given number of characters.  This is used in setting several indentation-related dimensions.
%    \begin{macrocode}
\newcount\FV@LoopCount
\newbox\FV@NCharsBox
\def\FV@SetToWidthNChars#1#2{%
  \FV@LoopCount=#2\relax
  \ifnum\FV@LoopCount>0
    \def\FV@NChars{}%
    \loop
    \ifnum\FV@LoopCount>0
      \expandafter\def\expandafter\FV@NChars\expandafter{\FV@NChars x}%
    \fi
    \advance\FV@LoopCount by -1
    \ifnum\FV@LoopCount>0
    \repeat
    \setbox\FV@NCharsBox\hbox{\FV@NChars}%
    #1=\wd\FV@NCharsBox
  \else
    #1=0pt\relax
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FV@breaklines}
% Turn line breaking on or off.  The |\FV@ListProcessLine| from \fancyvrb\ is |\let| to a (patched) version of the original or a version that supports line breaks.
%    \begin{macrocode}
\newbool{FV@breaklines}
\define@booleankey{FV}{breaklines}%
 {\booltrue{FV@breaklines}%
  \let\FV@ListProcessLine\FV@ListProcessLine@Break}%
 {\boolfalse{FV@breaklines}%
  \let\FV@ListProcessLine\FV@ListProcessLine@NoBreak}
\AtEndOfPackage{\fvset{breaklines=false}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@BreakLinesLuaTeXHook}
% Fix hyphen handling under LuaTeX.  |\automatichyphenmode=2| would work for environments, but doesn't seem to work inline.  Instead, the active hyphen is redefined to |\mbox{-}|.
%
% This is needed before |\@noligs| is ever used, so it is placed in |\FV@FormattingPrep@PreHook|.
%    \begin{macrocode}
\def\FV@BreakLinesLuaTeXHook{%
   \expandafter\def\expandafter\@noligs\expandafter{\@noligs
     \begingroup\lccode`\~=`\-\lowercase{\endgroup\def~}{\leavevmode\kern\z@\mbox{-}}}}
\ifcsname directlua\endcsname
  \ifx\directlua\relax
  \else
    \FV@AddToHook\FV@FormattingPrep@PreHook\FV@BreakLinesLuaTeXHook
  \fi
\fi
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakLinesIndentationHook}
% A hook for performing on-the-fly indentation calculations when |breaklines=true|.  This is used for all |*NChars| related indentation.  It is important to use |\FV@FormattingPrep@PostHook| because it is always invoked \emph{after} any font-related settings.
%    \begin{macrocode}
\def\FV@BreakLinesIndentationHook{}
\g@addto@macro\FV@FormattingPrep@PostHook{%
  \ifFV@breaklines
    \FV@BreakLinesIndentationHook
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakIndent}
% \begin{macro}{\FV@BreakIndentNChars}
% Indentation of continuation lines.
%    \begin{macrocode}
\newdimen\FV@BreakIndent
\newcount\FV@BreakIndentNChars
\define@key{FV}{breakindent}{%
  \FV@BreakIndent=#1\relax
  \FV@BreakIndentNChars=0\relax}
\define@key{FV}{breakindentnchars}{\FV@BreakIndentNChars=#1\relax}
\g@addto@macro\FV@BreakLinesIndentationHook{%
  \ifnum\FV@BreakIndentNChars>0
    \FV@SetToWidthNChars{\FV@BreakIndent}{\FV@BreakIndentNChars}%
  \fi}
\fvset{breakindentnchars=0}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{FV@breakautoindent}
% Auto indentation of continuation lines to indentation of original line.  Adds to |\FV@BreakIndent|.
%    \begin{macrocode}
\newbool{FV@breakautoindent}
\define@booleankey{FV}{breakautoindent}%
  {\booltrue{FV@breakautoindent}}{\boolfalse{FV@breakautoindent}}
\fvset{breakautoindent=true}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakSymbolLeft}
% The left-hand symbol indicating a break.  Since breaking is done in such a way that a left-hand symbol will often be desired while a right-hand symbol may not be, a shorthand option |breaksymbol| is supplied.  This shorthand convention is continued with other options applying to the left-hand symbol.
%    \begin{macrocode}
\define@key{FV}{breaksymbolleft}{\def\FancyVerbBreakSymbolLeft{#1}}
\define@key{FV}{breaksymbol}{\fvset{breaksymbolleft=#1}}
\fvset{breaksymbolleft=\tiny\ensuremath{\hookrightarrow}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakSymbolRight}
% The right-hand symbol indicating a break.
%    \begin{macrocode}
\define@key{FV}{breaksymbolright}{\def\FancyVerbBreakSymbolRight{#1}}
\fvset{breaksymbolright={}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakSymbolSepLeft}
% \begin{macro}{\FV@BreakSymbolSepLeftNChars}
% Separation of left break symbol from the text.
%    \begin{macrocode}
\newdimen\FV@BreakSymbolSepLeft
\newcount\FV@BreakSymbolSepLeftNChars
\define@key{FV}{breaksymbolsepleft}{%
  \FV@BreakSymbolSepLeft=#1\relax
  \FV@BreakSymbolSepLeftNChars=0\relax}
\define@key{FV}{breaksymbolsep}{\fvset{breaksymbolsepleft=#1}}
\define@key{FV}{breaksymbolsepleftnchars}{\FV@BreakSymbolSepLeftNChars=#1\relax}
\define@key{FV}{breaksymbolsepnchars}{\fvset{breaksymbolsepleftnchars=#1}}
\g@addto@macro\FV@BreakLinesIndentationHook{%
  \ifnum\FV@BreakSymbolSepLeftNChars>0
    \FV@SetToWidthNChars{\FV@BreakSymbolSepLeft}{\FV@BreakSymbolSepLeftNChars}%
  \fi}
\fvset{breaksymbolsepleftnchars=2}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakSymbolSepRight}
% \begin{macro}{\FV@BreakSymbolSepRightNChars}
% Separation of right break symbol from the text.
%    \begin{macrocode}
\newdimen\FV@BreakSymbolSepRight
\newcount\FV@BreakSymbolSepRightNChars
\define@key{FV}{breaksymbolsepright}{%
  \FV@BreakSymbolSepRight=#1\relax
  \FV@BreakSymbolSepRightNChars=0\relax}
\define@key{FV}{breaksymbolseprightnchars}{\FV@BreakSymbolSepRightNChars=#1\relax}
\g@addto@macro\FV@BreakLinesIndentationHook{%
  \ifnum\FV@BreakSymbolSepRightNChars>0
    \FV@SetToWidthNChars{\FV@BreakSymbolSepRight}{\FV@BreakSymbolSepRightNChars}%
  \fi}
\fvset{breaksymbolseprightnchars=2}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakSymbolIndentLeft}
% \begin{macro}{\FV@BreakSymbolIndentLeftNChars}
% Additional left indentation to make room for the left break symbol.
%    \begin{macrocode}
\newdimen\FV@BreakSymbolIndentLeft
\newcount\FV@BreakSymbolIndentLeftNChars
\define@key{FV}{breaksymbolindentleft}{%
  \FV@BreakSymbolIndentLeft=#1\relax
  \FV@BreakSymbolIndentLeftNChars=0\relax}
\define@key{FV}{breaksymbolindent}{\fvset{breaksymbolindentleft=#1}}
\define@key{FV}{breaksymbolindentleftnchars}{\FV@BreakSymbolIndentLeftNChars=#1\relax}
\define@key{FV}{breaksymbolindentnchars}{\fvset{breaksymbolindentleftnchars=#1}}
\g@addto@macro\FV@BreakLinesIndentationHook{%
  \ifnum\FV@BreakSymbolIndentLeftNChars>0
    \FV@SetToWidthNChars{\FV@BreakSymbolIndentLeft}{\FV@BreakSymbolIndentLeftNChars}%
  \fi}
\fvset{breaksymbolindentleftnchars=4}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakSymbolIndentRight}
% \begin{macro}{\FV@BreakSymbolIndentRightNChars}
% Additional right indentation to make room for the right break symbol.
%    \begin{macrocode}
\newdimen\FV@BreakSymbolIndentRight
\newcount\FV@BreakSymbolIndentRightNChars
\define@key{FV}{breaksymbolindentright}{%
  \FV@BreakSymbolIndentRight=#1\relax
  \FV@BreakSymbolIndentRightNChars=0\relax}
\define@key{FV}{breaksymbolindentrightnchars}{\FV@BreakSymbolIndentRightNChars=#1\relax}
\g@addto@macro\FV@BreakLinesIndentationHook{%
  \ifnum\FV@BreakSymbolIndentRightNChars>0
    \FV@SetToWidthNChars{\FV@BreakSymbolIndentRight}{\FV@BreakSymbolIndentRightNChars}%
  \fi}
\fvset{breaksymbolindentrightnchars=4}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% We need macros that contain the logic for typesetting the break symbols.  By default, the symbol macros contain everything regarding the symbol and its typesetting, while these macros contain pure logic.  The symbols should be wrapped in braces so that formatting commands (for example, |\tiny|) don't escape.
%
% \begin{macro}{\FancyVerbBreakSymbolLeftLogic}
% The left break symbol should only appear with continuation lines.  Note that |linenumber| here refers to local line numbering for the broken line, \emph{not} line numbering for all lines in the environment being typeset.
%    \begin{macrocode}
\newcommand{\FancyVerbBreakSymbolLeftLogic}[1]{%
  \ifnum\value{linenumber}=1\relax\else{#1}\fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FancyVerbLineBreakLast}
% We need a counter for keeping track of the local line number for the last segment of a broken line, so that we can avoid putting a right continuation symbol there.  A line that is broken will ultimately be processed twice when there is a right continuation symbol, once to determine the local line numbering, and then again for actual insertion into the document.
%    \begin{macrocode}
\newcounter{FancyVerbLineBreakLast}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@SetLineBreakLast}
% Store the local line number for the last continuation line.
%    \begin{macrocode}
\newcommand{\FV@SetLineBreakLast}{%
  \setcounter{FancyVerbLineBreakLast}{\value{linenumber}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakSymbolRightLogic}
% Only insert a right break symbol if not on the last continuation line.
%    \begin{macrocode}
\newcommand{\FancyVerbBreakSymbolRightLogic}[1]{%
  \ifnum\value{linenumber}=\value{FancyVerbLineBreakLast}\relax\else{#1}\fi}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FancyVerbBreakStart}
% Macro that starts fine-tuned breaking (|breakanywhere|, |breakbefore|, |breakafter|) by examining a line token-by-token.  Initially |\let| to |\relax|; later |\let| to |\FV@Break| as appropriate.
%    \begin{macrocode}
\let\FancyVerbBreakStart\relax
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakStop}
% Macro that stops the fine-tuned breaking region started by |\FancyVerbBreakStart|.  Initially |\let| to |\relax|; later |\let| to |\FV@EndBreak| as appropriate.
%    \begin{macrocode}
\let\FancyVerbBreakStop\relax
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@Break@DefaultToken}
% Macro that controls default token handling between |\FancyVerbBreakStart| and |\FancyVerbBreakStop|.  Initially |\let| to |\FV@Break@NBToken|, which does not insert breaks.  Later |\let| to |\FV@Break@AnyToken| or |\FV@Break@BeforeAfterToken| if |breakanywhere| or |breakbefore|/|breakafter| are in use.
%    \begin{macrocode}
\let\FV@Break@DefaultToken\FV@Break@NBToken
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{FV@breakanywhere}
% Allow line breaking (almost) anywhere.  Set |\FV@Break| and |\FV@EndBreak| to be used, and |\let| |\FV@Break@DefaultToken| to the appropriate macro.
%    \begin{macrocode}
\newbool{FV@breakanywhere}
\define@booleankey{FV}{breakanywhere}%
  {\booltrue{FV@breakanywhere}%
    \let\FancyVerbBreakStart\FV@Break
    \let\FancyVerbBreakStop\FV@EndBreak
    \let\FV@Break@DefaultToken\FV@Break@AnyToken}%
  {\boolfalse{FV@breakanywhere}%
    \let\FancyVerbBreakStart\relax
    \let\FancyVerbBreakStop\relax
    \let\FV@Break@DefaultToken\FV@Break@NBToken}
\fvset{breakanywhere=false}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{breakanywhereinlinestretch,\FV@breakanywhereinlinestretch,\FV@ApplyBreakAnywhereInlineStretch}
% Stretch glue to insert at potential |breakanywhere| break locations in inline contexts, to give better line widths and avoid overfull |\hbox|.
%
% |\FV@UseInlineKeyValues| invokes |\FV@ApplyBreakAnywhereInlineStretch| to redefine |\FancyVerbBreakAnywhereBreak| locally.
%    \begin{macrocode}
\define@key{FV}{breakanywhereinlinestretch}{%
  \def\FV@breakanywhereinlinestretch{#1}%
  \ifx\FV@breakanywhereinlinestretch\FV@None
    \let\FV@breakanywhereinlinestretch\relax
  \else\ifx\FV@breakanywhereinlinestretch\@empty
    \let\FV@breakanywhereinlinestretch\relax
  \fi\fi}
\fvset{breakanywhereinlinestretch=none}
\def\FV@ApplyBreakAnywhereInlineStretch{%
  \ifx\FV@breakanywhereinlinestretch\relax
  \else
    \let\FancyVerbBreakAnywhereBreak@Orig\FancyVerbBreakAnywhereBreak
    \def\FancyVerbBreakAnywhereBreak{%
      \nobreak\hspace{0pt plus \FV@breakanywhereinlinestretch}%
      \FancyVerbBreakAnywhereBreak@Orig}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakBefore}
% Allow line breaking (almost) anywhere, but only before specified characters.
%    \begin{macrocode}
\define@key{FV}{breakbefore}{%
  \ifstrempty{#1}%
   {\let\FV@BreakBefore\@empty
    \let\FancyVerbBreakStart\relax
    \let\FancyVerbBreakStop\relax
    \let\FV@Break@DefaultToken\FV@Break@NBToken}%
   {\def\FV@BreakBefore{#1}%
    \let\FancyVerbBreakStart\FV@Break
    \let\FancyVerbBreakStop\FV@EndBreak
    \let\FV@Break@DefaultToken\FV@Break@BeforeAfterToken}%
}
\fvset{breakbefore={}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FV@breakbeforeinrun}
% Determine whether breaking before specified characters is always allowed before each individual character, or is only allowed before the first in a run of identical characters.
%    \begin{macrocode}
\newbool{FV@breakbeforeinrun}
\define@booleankey{FV}{breakbeforeinrun}%
 {\booltrue{FV@breakbeforeinrun}}%
 {\boolfalse{FV@breakbeforeinrun}}%
\fvset{breakbeforeinrun=false}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@BreakBeforePrep}
% We need a way to break before characters if and only if they have been specified as breaking characters.  It would be possible to do that via a nested conditional, but that would be messy.  It is much simpler to create an empty macro whose name contains the character, and test for the existence of this macro.  This needs to be done inside a |\begingroup...\endgroup| so that the macros do not have to be cleaned up manually.  A good place to do this is in |\FV@FormattingPrep|, which is inside a group and before processing starts.  The macro is added to |\FV@FormattingPrep@PreHook|, which contains \fvextra\ extensions to |\FV@FormattingPrep|, after |\FV@BreakAfterPrep| is defined below.
%
% The procedure here is a bit roundabout.  We need to use |\FV@EscChars| to handle character escapes, but the character redefinitions need to be kept local, requiring that we work within a |\begingroup...\endgroup|.  So we loop through the breaking tokens and assemble a macro that will itself define character macros.  Only this defining macro is declared global, and it contains \emph{expanded} characters so that there is no longer any dependence on |\FV@EscChars|.
%
% |\FV@BreakBeforePrep@PygmentsHook| allows additional break preparation for Pygments-based packages such as \pkg{minted} and \pkg{pythontex}.  When Pygments highlights code, it converts some characters into macros; they do not appear literally.  As a result, for breaking to occur correctly, breaking macros need to be created for these character macros and not only for the literal characters themselves.
%
% A pdfTeX-compatible version for working with UTF-8 is defined later, and |\FV@BreakBeforePrep| is |\let| to it under pdfTeX as necessary.
%    \begin{macrocode}
\def\FV@BreakBeforePrep{%
  \ifx\FV@BreakBefore\@empty\relax
  \else
    \gdef\FV@BreakBefore@Def{}%
    \begingroup
    \def\FV@BreakBefore@Process##1##2\FV@Undefined{%
      \expandafter\FV@BreakBefore@Process@i\expandafter{##1}%
      \expandafter\ifx\expandafter\relax\detokenize{##2}\relax
      \else
        \FV@BreakBefore@Process##2\FV@Undefined
      \fi
    }%
    \def\FV@BreakBefore@Process@i##1{%
      \g@addto@macro\FV@BreakBefore@Def{%
        \@namedef{FV@BreakBefore@Token\detokenize{##1}}{}}%
    }%
    \FV@EscChars
    \expandafter\FV@BreakBefore@Process\FV@BreakBefore\FV@Undefined
    \endgroup
    \FV@BreakBefore@Def
    \FV@BreakBeforePrep@PygmentsHook
  \fi
}
\def\FV@BreakBeforePrep@PygmentsHook{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@BreakAfter}
% Allow line breaking (almost) anywhere, but only after specified characters.
%    \begin{macrocode}
\define@key{FV}{breakafter}{%
  \ifstrempty{#1}%
   {\let\FV@BreakAfter\@empty
    \let\FancyVerbBreakStart\relax
    \let\FancyVerbBreakStop\relax
    \let\FV@Break@DefaultToken\FV@Break@NBToken}%
   {\def\FV@BreakAfter{#1}%
    \let\FancyVerbBreakStart\FV@Break
    \let\FancyVerbBreakStop\FV@EndBreak
    \let\FV@Break@DefaultToken\FV@Break@BeforeAfterToken}%
}
\fvset{breakafter={}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{FV@breakafterinrun}
% Determine whether breaking after specified characters is always allowed after each individual character, or is only allowed after the last in a run of identical characters.
%    \begin{macrocode}
\newbool{FV@breakafterinrun}
\define@booleankey{FV}{breakafterinrun}%
 {\booltrue{FV@breakafterinrun}}%
 {\boolfalse{FV@breakafterinrun}}%
\fvset{breakafterinrun=false}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@BreakAfterPrep}
% This is the |breakafter| equivalent of |\FV@BreakBeforePrep|.  It is also used within |\FV@FormattingPrep|.  The order of |\FV@BreakBeforePrep| and |\FV@BreakAfterPrep| is important; |\FV@BreakAfterPrep| must always be second, because it checks for conflicts with |breakbefore|.
%
% A pdfTeX-compatible version for working with UTF-8 is defined later, and |\FV@BreakAfterPrep| is |\let| to it under pdfTeX as necessary.
%    \begin{macrocode}
\def\FV@BreakAfterPrep{%
  \ifx\FV@BreakAfter\@empty\relax
  \else
    \gdef\FV@BreakAfter@Def{}%
    \begingroup
    \def\FV@BreakAfter@Process##1##2\FV@Undefined{%
      \expandafter\FV@BreakAfter@Process@i\expandafter{##1}%
      \expandafter\ifx\expandafter\relax\detokenize{##2}\relax
      \else
        \FV@BreakAfter@Process##2\FV@Undefined
      \fi
    }%
    \def\FV@BreakAfter@Process@i##1{%
      \ifcsname FV@BreakBefore@Token\detokenize{##1}\endcsname
        \ifbool{FV@breakbeforeinrun}%
         {\ifbool{FV@breakafterinrun}%
           {}%
           {\PackageError{fvextra}%
            {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}%
            {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}}}%
         {\ifbool{FV@breakafterinrun}%
           {\PackageError{fvextra}%
             {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}%
             {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}}%
           {}}%
      \fi
      \g@addto@macro\FV@BreakAfter@Def{%
        \@namedef{FV@BreakAfter@Token\detokenize{##1}}{}}%
    }%
    \FV@EscChars
    \expandafter\FV@BreakAfter@Process\FV@BreakAfter\FV@Undefined
    \endgroup
    \FV@BreakAfter@Def
    \FV@BreakAfterPrep@PygmentsHook
  \fi
}
\def\FV@BreakAfterPrep@PygmentsHook{}
%    \end{macrocode}
% \end{macro}
%
% Now that |\FV@BreakBeforePrep| and |\FV@BreakAfterPrep| are defined, add them to |\FV@FormattingPrep@PreHook|, which is the \fvextra\ extension to |\FV@FormattingPrep|.  The ordering here is important, since |\FV@BreakAfterPrep| contains compatibility checks with |\FV@BreakBeforePrep|, and thus must be used after it.  Also, we have to check for the pdfTeX engine with \pkg{inputenc} using UTF-8, and use the |UTF| macros instead when that is the case.
%    \begin{macrocode}
\g@addto@macro\FV@FormattingPrep@PreHook{%
  \ifFV@pdfTeXinputenc
    \ifdefstring{\inputencodingname}{utf8}%
     {\let\FV@BreakBeforePrep\FV@BreakBeforePrep@UTF
      \let\FV@BreakAfterPrep\FV@BreakAfterPrep@UTF}%
     {}%
  \fi
  \FV@BreakBeforePrep\FV@BreakAfterPrep}
%    \end{macrocode}
%
%
% \begin{macro}{\FancyVerbBreakAnywhereSymbolPre}
% The pre-break symbol for breaks introduced by |breakanywhere|.  That is, the symbol before breaks that occur between characters, rather than at spaces.
%    \begin{macrocode}
\define@key{FV}{breakanywheresymbolpre}{%
  \ifstrempty{#1}%
    {\def\FancyVerbBreakAnywhereSymbolPre{}}%
    {\def\FancyVerbBreakAnywhereSymbolPre{\hbox{#1}}}}
\fvset{breakanywheresymbolpre={\,\footnotesize\ensuremath{_\rfloor}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakAnywhereSymbolPost}
% The post-break symbol for breaks introduced by |breakanywhere|.
%    \begin{macrocode}
\define@key{FV}{breakanywheresymbolpost}{%
  \ifstrempty{#1}%
    {\def\FancyVerbBreakAnywhereSymbolPost{}}%
    {\def\FancyVerbBreakAnywhereSymbolPost{\hbox{#1}}}}
\fvset{breakanywheresymbolpost={}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakBeforeSymbolPre}
% The pre-break symbol for breaks introduced by |breakbefore|.
%    \begin{macrocode}
\define@key{FV}{breakbeforesymbolpre}{%
  \ifstrempty{#1}%
    {\def\FancyVerbBreakBeforeSymbolPre{}}%
    {\def\FancyVerbBreakBeforeSymbolPre{\hbox{#1}}}}
\fvset{breakbeforesymbolpre={\,\footnotesize\ensuremath{_\rfloor}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakBeforeSymbolPost}
% The post-break symbol for breaks introduced by |breakbefore|.
%    \begin{macrocode}
\define@key{FV}{breakbeforesymbolpost}{%
  \ifstrempty{#1}%
    {\def\FancyVerbBreakBeforeSymbolPost{}}%
    {\def\FancyVerbBreakBeforeSymbolPost{\hbox{#1}}}}
\fvset{breakbeforesymbolpost={}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakAfterSymbolPre}
% The pre-break symbol for breaks introduced by |breakafter|.
%    \begin{macrocode}
\define@key{FV}{breakaftersymbolpre}{%
  \ifstrempty{#1}%
    {\def\FancyVerbBreakAfterSymbolPre{}}%
    {\def\FancyVerbBreakAfterSymbolPre{\hbox{#1}}}}
\fvset{breakaftersymbolpre={\,\footnotesize\ensuremath{_\rfloor}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakAfterSymbolPost}
% The post-break symbol for breaks introduced by |breakafter|.
%    \begin{macrocode}
\define@key{FV}{breakaftersymbolpost}{%
  \ifstrempty{#1}%
    {\def\FancyVerbBreakAfterSymbolPost{}}%
    {\def\FancyVerbBreakAfterSymbolPost{\hbox{#1}}}}
\fvset{breakaftersymbolpost={}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakAnywhereBreak}
% The macro governing breaking for |breakanywhere=true|.
%    \begin{macrocode}
\newcommand{\FancyVerbBreakAnywhereBreak}{%
  \discretionary{\FancyVerbBreakAnywhereSymbolPre}%
   {\FancyVerbBreakAnywhereSymbolPost}{}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FancyVerbBreakBeforeBreak}
% The macro governing breaking for |breakbefore=true|.
%    \begin{macrocode}
\newcommand{\FancyVerbBreakBeforeBreak}{%
  \discretionary{\FancyVerbBreakBeforeSymbolPre}%
   {\FancyVerbBreakBeforeSymbolPost}{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakAfterBreak}
% The macro governing breaking for |breakafter=true|.
%    \begin{macrocode}
\newcommand{\FancyVerbBreakAfterBreak}{%
  \discretionary{\FancyVerbBreakAfterSymbolPre}%
   {\FancyVerbBreakAfterSymbolPost}{}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{breaknonspaceingroup}
% \begin{macro}{FV@breaknonspaceingroup}
% When inserting breaks, insert breaks within groups (typically |{...}| but depends on |commandchars|) instead of skipping over them.  This isn't the default because it is incompabile with many macros since it inserts breaks into all arguments.  For those cases, redefining macros to use |\FancyVerbBreakStart...\FancyVerbBreakStop| to insert breaks is better.
%    \begin{macrocode}
\newbool{FV@breaknonspaceingroup}
\define@booleankey{FV}{breaknonspaceingroup}%
 {\booltrue{FV@breaknonspaceingroup}}%
 {\boolfalse{FV@breaknonspaceingroup}}
\fvset{breaknonspaceingroup=false}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{breakpreferspaces,\FV@BreakHyphenation}
% Adjust hyphenation settings for |breaklines|.
%
% When |breakbefore|, |breakafter|, or |breakanywhere| are in use, |\finalhyphendemerits=0| prevents the final ``word'' on a line from being put into a line segment by itself after line breaking.  Otherwise, \TeX\ tries to avoid a line break (hyphenation) within a ``word'' on the penultimate line segment, and may accomplish this by introducing an unnecessary line break at the space before the last ``word.''
%
% |breakpreferspaces| (|\linepenalty|) determines whether line breaks are preferentially inserted at normal spaces (|breakcollapsespaces=true|, |showspaces=false|) rather than at other locations allowed by |breakbefore|, |breakafter|, or |breakanywhere|.
%    \begin{macrocode}
\newbool{FV@breakpreferspaces}
\booltrue{FV@breakpreferspaces}
\define@booleankey{FV}{breakpreferspaces}%
 {\booltrue{FV@breakpreferspaces}}%
 {\boolfalse{FV@breakpreferspaces}}
\def\FV@BreakHyphenation{%
  \finalhyphendemerits=0\relax
  \ifbool{FV@breakpreferspaces}{}{\linepenalty=\@M\relax}}
\g@addto@macro\FV@FormattingPrep@PreHook{\FV@BreakHyphenation}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Line breaking implementation}
%
% \paragraph{Helper macros}\hfill\\
%
% \begin{macro}{\FV@LineBox}
% A box for saving a line of text, so that its dimensions may be determined and thus we may figure out if it needs line breaking.
%    \begin{macrocode}
\newsavebox{\FV@LineBox}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@LineIndentBox}
% A box for saving the indentation of code, so that its dimensions may be determined for use in auto-indentation of continuation lines.
%    \begin{macrocode}
\newsavebox{\FV@LineIndentBox}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@LineIndentChars}
% A macro for storing the indentation characters, if any, of a given line.  For use in auto-indentation of continuation lines
%    \begin{macrocode}
\let\FV@LineIndentChars\@empty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@GetLineIndent}
% A macro that takes a line and determines the indentation, storing the indentation chars in |\FV@LineIndentChars|.
%    \begin{macrocode}
\def\FV@GetLineIndent{%
  \@ifnextchar\FV@Sentinel
   {\FV@GetLineIndent@End}%
   {\ifx\@let@token\FV@FVSpaceToken
      \let\FV@Next\FV@GetLineIndent@Whitespace
    \else\ifx\@let@token\FV@FVTabToken
      \let\FV@Next\FV@GetLineIndent@Whitespace
    \else\ifcsname FV@PYG@Redefed\endcsname
      \ifx\@let@token\FV@PYG@Redefed
        \let\FV@Next\FV@GetLineIndent@Pygments
      \else
        \let\FV@Next\FV@GetLineIndent@End
      \fi
    \else
      \let\FV@Next\FV@GetLineIndent@End
    \fi\fi\fi
    \FV@Next}}
\def\FV@GetLineIndent@End#1\FV@Sentinel{}
\def\FV@GetLineIndent@Whitespace#1{%
  \expandafter\def\expandafter\FV@LineIndentChars\expandafter{\FV@LineIndentChars#1}%
  \FV@GetLineIndent}
\def\FV@GetLineIndent@Pygments#1#2#3{%
  \FV@GetLineIndent#3}
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Tab expansion}\hfill\\
%
% \noindent The \fancyvrb\ option |obeytabs| uses a clever algorithm involving boxing and unboxing to expand tabs based on tab stops rather than a fixed number of equivalent space characters.  (See the definitions of |\FV@@ObeyTabs| and |\FV@TrueTab| in \cref{sec:patch:obeytabs}.)  Unfortunately, since this involves |\hbox|, it interferes with the line breaking algorithm, and an alternative is required.
%
% There are probably many ways tab expansion could be performed while still allowing line breaks.  The current approach has been chosen because it is relatively straightforward and yields identical results to the case without line breaks.  Line breaking involves saving a line in a box, and determining whether the box is too wide.  During this process, if |obeytabs=true|, |\FV@TrueTabSaveWidth|, which is inside |\FV@TrueTab|, is |\let| to a version that saves the width of every tab in a macro.  When a line is broken, all tabs within it will then use a variant of |\FV@TrueTab| that sequentially retrieves the saved widths.  This maintains the exact behavior of the case without line breaks.
%
% Note that the special version of |\FV@TrueTab| is based on the \fvextra\ patched version of |\FV@TrueTab|, not on the original |\FV@TrueTab| defined in \fancyvrb.
%
%
% \begin{macro}{\FV@TrueTab@UseWidth}
% Version of |\FV@TrueTab| that uses pre-computed tab widths.
%    \begin{macrocode}
\def\FV@TrueTab@UseWidth{%
  \@tempdima=\csname FV@TrueTab:Width\arabic{FV@TrueTabCounter}\endcsname sp\relax
  \stepcounter{FV@TrueTabCounter}%
  \hbox to\@tempdima{\hss\FV@TabChar}}
%    \end{macrocode}
% \end{macro}
%
%
%
% \paragraph{Line scanning and break insertion macros}\hfill\\
%
% \noindent The strategy here is to scan through text token by token, inserting potential breaks at appropriate points.  The final text with breaks inserted is stored in |\FV@BreakBuffer|, which is ultimately passed on to a wrapper macro like |\FancyVerbFormatText| or |\FancyVerbFormatInline|.
%
% If user macros insert breaks via |\FancyVerbBreakStart...\FancyVerbBreakStop|, this invokes an additional scanning/insertion pass within each macro after expansion.  The scanning/insertion only applies to the part of the expanded macros wrapped in |\FancyVerbBreakStart...\FancyVerbBreakStop|.  At the time this occurs, during macro processing, text will already be wrapped in a wrapper macro like |\FancyVerbFormatText| or |\FancyVerbFormatInline|.  That is, the built-in break insertion occurs before any typesetting, but user macro break insertion occurs during typesetting.
%
% Token comparison is currently based on |\ifx|.  This is sufficient for verbatim text but a comparison based on |\detokenize| might be better for cases when |commandchars| is in use.  For example, with |commandchars| characters other than the curly braces |{}| might be the group tokens.
%
% It would be possible to insert each token/group into the document immediately after it is scanned, instead of accumulating them in a ``buffer.''  But that would interfere with macros.  Even in the current approach, macros that take optional arguments are problematic, since with some settings breaks will interference with optional arguments.\footnote{Through a suitable definition that tracks the current state and looks for square brackets, this might be circumvented.  Then again, in verbatim contexts, macro use should be minimal, so the restriction to macros without optional arguments should generally not be an issue.}
%
% The last token is tracked with |\FV@LastToken|, to allow lookbehind when breaking by groups of identical characters.  |\FV@LastToken| is |\let| to |\FV@Undefined| any time the last token was something that shouldn't be compared against (for example, a non-empty group), and it is not reset whenever the last token may be ignored (for example, |{}|).  When setting |\FV@LastToken|, it is vital always to use |\let\FV@LastToken=...| so that |\let\FV@LastToken==| will work (so that the equals sign |=| won't break things).
%
% \begin{macro}{FV@BreakBufferDepth}
% Track buffer depth while inserting breaks.  Some macros and command sequences require recursive processing.  For example, groups |{...}| (with |commandchars| and |breaknonspaceingroup|), math, and nested |\FancyVerbBreakStart...\FancyVerbBreakStop|.  Depth starts at zero.  The current buffer at depth $n$ is always |\FV@BreakBuffer|, with other buffers |\FV@BreakBuffer<n>| etc.\ named via |\csname| to allow for the integer.
%    \begin{macrocode}
\newcounter{FV@BreakBufferDepth}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakBuffer@Append}
% Append to |\FV@BreakBuffer|.
%    \begin{macrocode}
\def\FV@BreakBuffer@Append#1{%
  \expandafter\def\expandafter\FV@BreakBuffer\expandafter{\FV@BreakBuffer#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakBufferStart}
% Create a new buffer, either at the beginning of scanning or during recursion.  The single mandatory argument is the macro for handling tokens, which is |\let| to |\FV@Break@Token|.  An intermediate |\FV@BreakBufferStart@i| is used to optimize |\ifx| comparisons for |\FV@BreakBufferStart| during scanning.
%
% For recursion, |\FV@BreakBuffer<n>| and |\FV@Break@Token<n>| store the state (buffer and token handling macro) immediately prior to recursion with depth |<n>|.
%    \begin{macrocode}
\def\FV@BreakBufferStart{%
  \FV@BreakBufferStart@i}
\def\FV@BreakBufferStart@i#1{%
  \ifnum\value{FV@BreakBufferDepth}>0\relax
    \expandafter\let\csname FV@BreakBuffer\arabic{FV@BreakBufferDepth}\endcsname
      \FV@BreakBuffer
    \expandafter\let\csname FV@Break@Token\arabic{FV@BreakBufferDepth}\endcsname
      \FV@Break@Token
  \fi
  \def\FV@BreakBuffer{}%
  \let\FV@Break@Token=#1%
  \stepcounter{FV@BreakBufferDepth}%
  \let\FV@LastToken=\FV@Undefined
  \FV@Break@Scan}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{FV@UserMacroBreaks}
% Whether a user macro is inserting breaks, as opposed to \pkg{fvextra}'s standard scanning routine.  When breaks come from \pkg{fvextra}, |\FV@BreakBufferStop| does nothing with |\FV@BreakBuffer| at buffer depth 0, since |\FV@InsertBreaks| handles buffer insertion.  When breaks come from user macros, |\FV@BreakBufferStop| needs to insert |\FV@BreakBuffer| at buffer depth 0.
%    \begin{macrocode}
\newbool{FV@UserMacroBreaks}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakBufferStop}
% Complete the current buffer.  The single mandatory argument is a wrapper macro for |\FV@BreakBuffer|'s contents (for example, insert recursively scanned group into braces |{...}|).  If the mandatory argument is empty, no wrapper is used.
%
% For \pkg{fvextra}'s standard scanning:  If this is the main buffer (depth 0), stop scanning---which ultimately allows |\FV@BreakBuffer| to be handled by |\FV@InsertBreaks|.  For user macros:  Insert |\FV@BreakBuffer| at buffer depth 0.  Otherwise for both cases:  Append the current buffer to the previous buffer, and continue scanning.
%
% An intermediate |\FV@BreakBufferStop@i| is used to optimize |\ifx| comparisons for |\FV@BreakBufferStop| during scanning.
%    \begin{macrocode}
\def\FV@BreakBufferStop{%
  \FV@BreakBufferStop@i}
\def\FV@BreakBufferStop@i#1{%
  \addtocounter{FV@BreakBufferDepth}{-1}%
  \let\FV@LastToken=\FV@Undefined
  \ifnum\value{FV@BreakBufferDepth}<0\relax
    \PackageError{fvextra}%
     {Line break insertion error (extra \string\FancyVerbBreakStop?)}%
     {Line break insertion error (extra \string\FancyVerbBreakStop?)}%
    \def\FV@BreakBuffer{}%
  \fi
  \ifnum\value{FV@BreakBufferDepth}>0\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
   {\expandafter\FV@BreakBufferStop@ii\expandafter{\FV@BreakBuffer}{#1}}%
   {\ifbool{FV@UserMacroBreaks}%
     {\expandafter\let\expandafter\FV@BreakBuffer\expandafter\FV@Undefined\FV@BreakBuffer}%
     {}}}
\def\FV@BreakBufferStop@ii#1#2{%
  \ifstrempty{#2}%
   {\FV@BreakBufferStop@iii{#1}}%
   {\expandafter\FV@BreakBufferStop@iii\expandafter{#2{#1}}}}
\def\FV@BreakBufferStop@iii#1{%
  \expandafter\let\expandafter\FV@BreakBufferUpLevel
    \csname FV@BreakBuffer\arabic{FV@BreakBufferDepth}\endcsname
  \expandafter\def\expandafter\FV@BreakBuffer\expandafter{\FV@BreakBufferUpLevel#1}%
  \expandafter\let\expandafter\FV@Break@Token
    \csname FV@Break@Token\arabic{FV@BreakBufferDepth}\endcsname
  \FV@Break@Scan}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@InsertBreaks}
% This inserts breaks within text (|#2|) and stores the result in |\FV@BreakBuffer|.  Then it invokes a macro (|#1|) on the result.  That allows |\FancyVerbFormatInline| and |\FancyVerbFormatText| to operate on the final text (with breaks) directly, rather than being given text without breaks or text wrapped with macros that will (potentially recursively) insert breaks.  (Breaks inserted by user macros are not yet present, though, since they are only inserted---potentially recursively---during macro processing.)
%
% The initial |\ifx| skips break insertion when break insertion is turned off (|\FancyVerbBreakStart| is |\relax|).
%
% The current definition of |\FV@Break@Token| is swapped for a UTF-8 compatible one under pdfTeX when necessary.  In what follows, the default macros are defined after |\FV@Break|, since they make the algorithms simpler to understand.  The more complex |UTF| variants are defined afterward.
%    \begin{macrocode}
\def\FV@InsertBreaks#1#2{%
  \ifx\FancyVerbBreakStart\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
   {#1{#2}}%
   {\ifFV@pdfTeXinputenc
      \ifdefstring{\inputencodingname}{utf8}%
       {\ifx\FV@Break@DefaultToken\FV@Break@AnyToken
          \let\FV@Break@DefaultToken\FV@Break@AnyToken@UTF
        \else
           \ifx\FV@Break@DefaultToken\FV@Break@BeforeAfterToken
             \let\FV@Break@DefaultToken\FV@Break@BeforeAfterToken@UTF
           \fi
        \fi}%
       {}%
    \fi
    \setcounter{FV@BreakBufferDepth}{0}%
    \boolfalse{FV@UserMacroBreaks}%
    \FancyVerbBreakStart#2\FancyVerbBreakStop
    \setcounter{FV@BreakBufferDepth}{0}%
    \booltrue{FV@UserMacroBreaks}%
    \expandafter\FV@InsertBreaks@i\expandafter{\FV@BreakBuffer}{#1}}}
\def\FV@InsertBreaks@i#1#2{%
  \let\FV@BreakBuffer\FV@Undefined
  #2{#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Break}
% The entry macro for break insertion.  Whatever is delimited (after expansion) by |\FV@Break...\FV@EndBreak| will be scanned token by token/group by group, and accumulated (with any added breaks) in |\FV@BreakBuffer|.  After scanning is complete, |\FV@BreakBuffer| will be inserted.
%    \begin{macrocode}
\def\FV@Break{%
  \FV@BreakBufferStart{\FV@Break@DefaultToken}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@EndBreak}
%    \begin{macrocode}
\def\FV@EndBreak{%
  \FV@BreakBufferStop{}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Break@Scan}
% Look ahead via |\@ifnextchar|.  Don't do anything if we're at the end of the region to be scanned.  Otherwise, invoke a macro to deal with what's next based on whether it is math, or a group, or something else.
%
% This and some following macros are defined inside of groups to ensure proper catcodes.
%
% The check against |\FV@BreakBufferStart| should typically not be necessary; it is included for completeness and to allow for future extensions and customization.  |\FV@BreakBufferStart| is only inserted raw (rather than wrapped in |\FancyVerbBreakStart|) in token processing macros, where it initiates (or restarts) scanning and is not itself scanned.
%
%    \begin{macrocode}
\begingroup
\catcode`\$=3
\gdef\FV@Break@Scan{%
  \@ifnextchar\FancyVerbBreakStart%
   {}%
   {\ifx\@let@token\FancyVerbBreakStop
      \let\FV@Break@Next\relax
    \else\ifx\@let@token\FV@BreakBufferStart
      \let\FV@Break@Next\relax
    \else\ifx\@let@token\FV@BreakBufferStop
      \let\FV@Break@Next\relax
    \else\ifx\@let@token$
      \let\FV@Break@Next\FV@Break@Math
    \else\ifx\@let@token\bgroup
      \let\FV@Break@Next\FV@Break@Group
    \else
      \let\FV@Break@Next\FV@Break@Token
    \fi\fi\fi\fi\fi
    \FV@Break@Next}}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Break@Math}
% Grab an entire math span, and insert it into |\FV@BreakBuffer|.  Due to grouping, this works even when math contains things like |\text{$x$}|.  After dealing with the math span, continue scanning.
%    \begin{macrocode}
\begingroup
\catcode`\$=3%
\gdef\FV@Break@Math$#1${%
  \FV@BreakBufferStart{\FV@Break@NBToken}#1\FV@BreakBufferStop{\FV@Break@MathTemplate}}
\gdef\FV@Break@MathTemplate#1{$#1$}
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@Break@Group}
% Grab the group, and insert it into |\FV@BreakBuffer| (as a group) before continuing scanning.
%    \begin{macrocode}
\def\FV@Break@Group#1{%
  \ifstrempty{#1}%
   {\FV@BreakBuffer@Append{{}}%
    \FV@Break@Scan}%
   {\ifbool{FV@breaknonspaceingroup}%
     {\FV@BreakBufferStart{\FV@Break@DefaultToken}%
        #1\FV@BreakBufferStop{\FV@Break@GroupTemplate}}%
     {\FV@BreakBufferStart{\FV@Break@NBToken}%
        #1\FV@BreakBufferStop{\FV@Break@GroupTemplate}}}}
\def\FV@Break@GroupTemplate#1{{#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Break@NBToken}
% Append token to buffer while adding no breaks (|NB|) and reset last token.
%    \begin{macrocode}
\def\FV@Break@NBToken#1{%
  \FV@BreakBuffer@Append{#1}%
  \let\FV@LastToken=\FV@Undefined
  \FV@Break@Scan}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@Break@AnyToken}
% Deal with breaking around any token.  This doesn't break macros with \emph{mandatory} arguments, because |\FancyVerbBreakAnywhereBreak| is inserted \emph{before} the token.  Groups themselves are added without any special handling.  So a macro would end up right next to its original arguments, without anything being inserted.  Optional arguments will cause this approach to fail; there is currently no attempt to identify them, since that is a much harder problem.
%
% If it is ever necessary, it would be possible to create a more sophisticated version involving catcode checks via |\ifcat|.  Something like this:
%
%~
%\hrule
%\begin{verbatim}
%\begingroup
%\catcode`\a=11%
%\catcode`\+=12%
%\gdef\FV@Break...
%  \ifcat\noexpand#1a%
%    \FV@BreakBuffer@Append...
%  \else
%...
%\endgroup
%\end{verbatim}
%\hrule\par~
%
%    \begin{macrocode}
\def\FV@Break@AnyToken#1{%
  \ifx\FV@FVSpaceToken#1\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
   {\let\FV@LastToken=#1\FV@BreakBuffer@Append{#1}\FV@Break@Scan}%
   {\ifx\FV@LastToken\FV@FVSpaceToken
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
     {\let\FV@LastToken=#1%
      \FV@BreakBuffer@Append{#1}\FV@Break@Scan}%
     {\let\FV@LastToken=#1%
      \FV@BreakBuffer@Append{\FancyVerbBreakAnywhereBreak#1}\FV@Break@Scan}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@Break@BeforeAfterToken}
% Deal with breaking around only specified tokens.  This is a bit trickier.  We only break if a macro corresponding to the token exists.  We also need to check whether the specified token should be grouped, that is, whether breaks are allowed between identical characters.  All of this has to be written carefully so that nothing is accidentally inserted into the stream for future scanning.
%
% Dealing with tokens followed by empty groups (for example, |\x{}|) is particularly challenging when we want to avoid breaks between identical characters.  When a token is followed by a group, we need to save the current token for later reference (|\x| in the example), then capture and save the following group, and then---only if the group was empty---see if the following token is identical to the old saved token.
%
% The |\csname @let@token\endcsname| prevents issues if |\@let@token| is ever |\else| or |\fi|.
%    \begin{macrocode}
\def\FV@Break@BeforeAfterToken#1{%
  \ifcsname FV@BreakBefore@Token\detokenize{#1}\endcsname
    \let\FV@Break@Next\FV@Break@BeforeTokenBreak
  \else
    \ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
      \let\FV@Break@Next\FV@Break@AfterTokenBreak
    \else
      \let\FV@Break@Next\FV@Break@BeforeAfterTokenNoBreak
    \fi
  \fi
  \FV@Break@Next{#1}%
}
\def\FV@Break@BeforeAfterTokenNoBreak#1{%
  \FV@BreakBuffer@Append{#1}%
  \let\FV@LastToken=#1%
  \FV@Break@Scan}
\def\FV@Break@BeforeTokenBreak#1{%
  \ifbool{FV@breakbeforeinrun}%
   {\ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
      \ifx#1\FV@FVSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak}%
      \fi
      \let\FV@Break@Next\FV@Break@BeforeTokenBreak@AfterRescan
      \def\FV@RescanToken{#1}%
    \else
      \ifx#1\FV@FVSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak#1}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak#1}%
      \fi
      \let\FV@Break@Next\FV@Break@Scan
      \let\FV@LastToken=#1%
    \fi}%
   {\ifx#1\FV@LastToken\relax
      \ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
        \let\FV@Break@Next\FV@Break@BeforeTokenBreak@AfterRescan
        \def\FV@RescanToken{#1}%
      \else
        \FV@BreakBuffer@Append{#1}%
        \let\FV@Break@Next\FV@Break@Scan
        \let\FV@LastToken=#1%
      \fi
    \else
      \ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
        \ifx#1\FV@FVSpaceToken
          \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
        \else
          \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak}%
        \fi
        \let\FV@Break@Next\FV@Break@BeforeTokenBreak@AfterRescan
        \def\FV@RescanToken{#1}%
      \else
        \ifx#1\FV@FVSpaceToken
          \FV@BreakBuffer@Append{\FancyVerbSpaceBreak#1}%
        \else
          \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak#1}%
        \fi
        \let\FV@Break@Next\FV@Break@Scan
        \let\FV@LastToken=#1%
      \fi
    \fi}%
  \FV@Break@Next}
\def\FV@Break@BeforeTokenBreak@AfterRescan{%
  \expandafter\FV@Break@AfterTokenBreak\FV@RescanToken}
\def\FV@Break@AfterTokenBreak#1{%
  \let\FV@LastToken=#1%
  \@ifnextchar\FV@FVSpaceToken%
   {\ifx#1\FV@FVSpaceToken
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
     {\FV@Break@AfterTokenBreak@i{#1}}%
     {\FV@BreakBuffer@Append{#1}%
      \FV@Break@Scan}}%
   {\FV@Break@AfterTokenBreak@i{#1}}}
\def\FV@Break@AfterTokenBreak@i#1{%
  \ifbool{FV@breakafterinrun}%
   {\ifx#1\FV@FVSpaceToken
      \FV@BreakBuffer@Append{#1\FancyVerbSpaceBreak}%
    \else
      \FV@BreakBuffer@Append{#1\FancyVerbBreakAfterBreak}%
    \fi
    \let\FV@Break@Next\FV@Break@Scan}%
   {\ifx\@let@token#1\relax
      \FV@BreakBuffer@Append{#1}%
      \let\FV@Break@Next\FV@Break@Scan
    \else
      \expandafter\ifx\csname @let@token\endcsname\bgroup\relax
        \FV@BreakBuffer@Append{#1}%
        \let\FV@Break@Next\FV@Break@AfterTokenBreak@Group
      \else
        \ifx#1\FV@FVSpaceToken
          \FV@BreakBuffer@Append{#1\FancyVerbSpaceBreak}%
        \else
          \FV@BreakBuffer@Append{#1\FancyVerbBreakAfterBreak}%
        \fi
        \let\FV@Break@Next\FV@Break@Scan
      \fi
    \fi}%
  \FV@Break@Next
}
\def\FV@Break@AfterTokenBreak@Group#1{%
  \ifstrempty{#1}%
   {\FV@BreakBuffer@Append{{}}%
    \@ifnextchar\FV@LastToken%
     {\FV@Break@Scan}%
     {\ifx\FV@LastToken\FV@FVSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakAfterBreak}%
      \fi
      \FV@Break@Scan}}%
   {\ifx\FV@LastToken\FV@FVSpaceToken
      \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
    \else
      \FV@BreakBuffer@Append{\FancyVerbBreakAfterBreak}%
    \fi
    \FV@Break@Group{#1}}}
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Line scanning and break insertion macros for pdfTeX with UTF-8}\hfill\\
% The macros above work with the XeTeX and LuaTeX engines and are also fine for pdfTeX with 8-bit character encodings.  Unfortunately, pdfTeX works with multi-byte UTF-8 code points at the byte level, making things significantly trickier.  The code below re-implements the macros in a manner compatible with the \pkg{inputenc} package with option |utf8|.  Note that there is no attempt for compatibility with |utf8x|; |utf8| has been significantly improved in recent years and should be sufficient in the vast majority of cases.  And implementing variants for |utf8| was already sufficiently painful.
%
% Create macros conditionally:
%    \begin{macrocode}
\ifFV@pdfTeXinputenc
%    \end{macrocode}
%
% \begin{macro}{\FV@BreakBeforePrep@UTF}
% We need |UTF| variants of the |breakbefore| and |breakafter| prep macros.  These are only ever used with \pkg{inputenc} with UTF-8.  There is no need for encoding checks here; checks are performed in |\FV@FormattingPrep@PreHook| (checks are inserted into it after the non-|UTF| macro definitions).
%    \begin{macrocode}
\def\FV@BreakBeforePrep@UTF{%
  \ifx\FV@BreakBefore\@empty\relax
  \else
    \gdef\FV@BreakBefore@Def{}%
    \begingroup
    \def\FV@BreakBefore@Process##1{%
      \ifcsname FV@U8:\detokenize{##1}\endcsname
        \expandafter\let\expandafter\FV@Break@Next\csname FV@U8:\detokenize{##1}\endcsname
        \let\FV@UTF@octets@after\FV@BreakBefore@Process@ii
      \else
        \ifx##1\FV@Undefined
          \let\FV@Break@Next\@gobble
        \else
          \let\FV@Break@Next\FV@BreakBefore@Process@i
        \fi
      \fi
      \FV@Break@Next##1%
    }%
    \def\FV@BreakBefore@Process@i##1{%
      \expandafter\FV@BreakBefore@Process@ii\expandafter{##1}}%
    \def\FV@BreakBefore@Process@ii##1{%
      \g@addto@macro\FV@BreakBefore@Def{%
        \@namedef{FV@BreakBefore@Token\detokenize{##1}}{}}%
      \FV@BreakBefore@Process
    }%
    \FV@EscChars
    \expandafter\FV@BreakBefore@Process\FV@BreakBefore\FV@Undefined
    \endgroup
    \FV@BreakBefore@Def
    \FV@BreakBeforePrep@PygmentsHook
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@BreakAfterPrep@UTF}
%    \begin{macrocode}
\def\FV@BreakAfterPrep@UTF{%
  \ifx\FV@BreakAfter\@empty\relax
  \else
    \gdef\FV@BreakAfter@Def{}%
    \begingroup
    \def\FV@BreakAfter@Process##1{%
      \ifcsname FV@U8:\detokenize{##1}\endcsname
        \expandafter\let\expandafter\FV@Break@Next\csname FV@U8:\detokenize{##1}\endcsname
        \let\FV@UTF@octets@after\FV@BreakAfter@Process@ii
      \else
        \ifx##1\FV@Undefined
          \let\FV@Break@Next\@gobble
        \else
          \let\FV@Break@Next\FV@BreakAfter@Process@i
        \fi
      \fi
      \FV@Break@Next##1%
    }%
    \def\FV@BreakAfter@Process@i##1{%
      \expandafter\FV@BreakAfter@Process@ii\expandafter{##1}}%
    \def\FV@BreakAfter@Process@ii##1{%
      \ifcsname FV@BreakBefore@Token\detokenize{##1}\endcsname
        \ifbool{FV@breakbeforeinrun}%
         {\ifbool{FV@breakafterinrun}%
           {}%
           {\PackageError{fvextra}%
            {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}%
            {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}}}%
         {\ifbool{FV@breakafterinrun}%
           {\PackageError{fvextra}%
             {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}%
             {Conflicting breakbeforeinrun and breakafterinrun for "\detokenize{##1}"}}%
           {}}%
      \fi
      \g@addto@macro\FV@BreakAfter@Def{%
        \@namedef{FV@BreakAfter@Token\detokenize{##1}}{}}%
      \FV@BreakAfter@Process
    }%
    \FV@EscChars
    \expandafter\FV@BreakAfter@Process\FV@BreakAfter\FV@Undefined
    \endgroup
    \FV@BreakAfter@Def
    \FV@BreakAfterPrep@PygmentsHook
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\FV@Break@AnyToken@UTF}
% Instead of just adding each token to |\FV@BreakBuffer| with a preceding break, also check for multi-byte code points and capture the remaining bytes when they are encountered.
%    \begin{macrocode}
\def\FV@Break@AnyToken@UTF#1{%
  \ifcsname FV@U8:\detokenize{#1}\endcsname
    \expandafter\let\expandafter\FV@Break@Next\csname FV@U8:\detokenize{#1}\endcsname
    \let\FV@UTF@octets@after\FV@Break@AnyToken@UTF@i
  \else
    \let\FV@Break@Next\FV@Break@AnyToken@UTF@i
  \fi
  \FV@Break@Next{#1}%
}
\def\FV@Break@AnyToken@UTF@i#1{%
  \def\FV@CurrentToken{#1}%
  \ifx\FV@CurrentToken\FV@ActiveSpaceToken\relax
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
   {\let\FV@LastToken\FV@CurrentToken
    \FV@BreakBuffer@Append{#1}\FV@Break@Scan}%
   {\ifx\FV@LastToken\FV@ActiveSpaceToken
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
     {\let\FV@LastToken\FV@CurrentToken
      \FV@BreakBuffer@Append{#1}\FV@Break@Scan}%
     {\let\FV@LastToken\FV@CurrentToken
      \FV@BreakBuffer@Append{\FancyVerbBreakAnywhereBreak#1}\FV@Break@Scan}}}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\FV@Break@BeforeAfterToken@UTF}
% Due to the way that the flow works, |#1| will sometimes be a single byte and sometimes be a multi-byte UTF-8 code point.  As a result, it is vital use use |\detokenize| in the UTF-8 leading byte checks; |\string| would only deal with the first byte.  It is also important to keep track of the distinction between |\FV@Break@Next#1| and |\FV@Break@Next{#1}|.  In some cases, a multi-byte sequence is being passed on as a single argument, so it must be enclosed in curly braces; in other cases, it is being re-inserted into the scanning stream and curly braces must be avoided lest they be interpreted as part of the original text.
%    \begin{macrocode}
\def\FV@Break@BeforeAfterToken@UTF#1{%
  \ifcsname FV@U8:\detokenize{#1}\endcsname
    \expandafter\let\expandafter\FV@Break@Next\csname FV@U8:\detokenize{#1}\endcsname
    \let\FV@UTF@octets@after\FV@Break@BeforeAfterToken@UTF@i
  \else
    \let\FV@Break@Next\FV@Break@BeforeAfterToken@UTF@i
  \fi
  \FV@Break@Next{#1}%
}
\def\FV@Break@BeforeAfterToken@UTF@i#1{%
  \ifcsname FV@BreakBefore@Token\detokenize{#1}\endcsname
    \let\FV@Break@Next\FV@Break@BeforeTokenBreak@UTF
  \else
    \ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
      \let\FV@Break@Next\FV@Break@AfterTokenBreak@UTF
    \else
      \let\FV@Break@Next\FV@Break@BeforeAfterTokenNoBreak@UTF
    \fi
  \fi
  \FV@Break@Next{#1}%
}
\def\FV@Break@BeforeAfterTokenNoBreak@UTF#1{%
  \FV@BreakBuffer@Append{#1}%
  \def\FV@LastToken{#1}%
  \FV@Break@Scan}
\def\FV@Break@BeforeTokenBreak@UTF#1{%
  \def\FV@CurrentToken{#1}%
  \ifbool{FV@breakbeforeinrun}%
   {\ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
      \ifx\FV@CurrentToken\FV@ActiveSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak}%
      \fi
      \let\FV@Break@Next\FV@Break@BeforeTokenBreak@AfterRescan@UTF
      \def\FV@RescanToken{#1}%
    \else
      \ifx\FV@CurrentToken\FV@ActiveSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak#1}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak#1}%
      \fi
      \let\FV@Break@Next\FV@Break@Scan
      \def\FV@LastToken{#1}%
    \fi}%
   {\ifx\FV@CurrentToken\FV@LastToken\relax
      \ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
        \let\FV@Break@Next\FV@Break@BeforeTokenBreak@AfterRescan@UTF
        \def\FV@RescanToken{#1}%
      \else
        \FV@BreakBuffer@Append{#1}%
        \let\FV@Break@Next\FV@Break@Scan
        \def\FV@LastToken{#1}%
      \fi
    \else
      \ifcsname FV@BreakAfter@Token\detokenize{#1}\endcsname
        \ifx\FV@CurrentToken\FV@ActiveSpaceToken
          \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
        \else
          \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak}%
        \fi
        \let\FV@Break@Next\FV@Break@BeforeTokenBreak@AfterRescan@UTF
        \def\FV@RescanToken{#1}%
      \else
        \ifx\FV@CurrentToken\FV@ActiveSpaceToken
          \FV@BreakBuffer@Append{\FancyVerbSpaceBreak#1}%
        \else
          \FV@BreakBuffer@Append{\FancyVerbBreakBeforeBreak#1}%
        \fi
        \let\FV@Break@Next\FV@Break@Scan
        \def\FV@LastToken{#1}%
      \fi
    \fi}%
  \FV@Break@Next}
\def\FV@Break@BeforeTokenBreak@AfterRescan@UTF{%
  \expandafter\FV@Break@AfterTokenBreak@UTF\expandafter{\FV@RescanToken}}
\def\FV@Break@AfterTokenBreak@UTF#1{%
  \def\FV@LastToken{#1}%
  \@ifnextchar\FV@FVSpaceToken%
   {\ifx\FV@LastToken\FV@ActiveSpaceToken
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
     {\FV@Break@AfterTokenBreak@UTF@i{#1}}%
     {\FV@BreakBuffer@Append{#1}%
      \FV@Break@Scan}}%
   {\FV@Break@AfterTokenBreak@UTF@i{#1}}}
\def\FV@Break@AfterTokenBreak@UTF@i#1{%
  \ifbool{FV@breakafterinrun}%
   {\ifx\FV@LastToken\FV@ActiveSpaceToken
      \FV@BreakBuffer@Append{#1\FancyVerbSpaceBreak}%
    \else
      \FV@BreakBuffer@Append{#1\FancyVerbBreakAfterBreak}%
    \fi
    \let\FV@Break@Next\FV@Break@Scan}%
   {\FV@BreakBuffer@Append{#1}%
    \expandafter\ifx\csname @let@token\endcsname\bgroup\relax
      \let\FV@Break@Next\FV@Break@AfterTokenBreak@Group@UTF
    \else
      \let\FV@Break@Next\FV@Break@AfterTokenBreak@UTF@ii
    \fi}%
  \FV@Break@Next}
\def\FV@Break@AfterTokenBreak@UTF@ii#1{%
  \ifcsname FV@U8:\detokenize{#1}\endcsname
    \expandafter\let\expandafter\FV@Break@Next\csname FV@U8:\detokenize{#1}\endcsname
    \let\FV@UTF@octets@after\FV@Break@AfterTokenBreak@UTF@ii
  \else
    \def\FV@NextToken{#1}%
    \ifx\FV@LastToken\FV@NextToken
    \else
      \ifx\FV@LastToken\FV@ActiveSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakAfterBreak}%
      \fi
    \fi
    \let\FV@Break@Next\FV@Break@Scan
  \fi
  \FV@Break@Next#1}
\def\FV@Break@AfterTokenBreak@Group@UTF#1{%
  \ifstrempty{#1}%
   {\FV@BreakBuffer@Append{{}}%
    \@ifnextchar\bgroup
     {\ifx\FV@LastToken\FV@ActiveSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakAfterBreak}%
      \fi
      \FV@Break@Group}%
     {\FV@Break@AfterTokenBreak@Group@UTF@i}}%
   {\ifx\FV@LastToken\FV@ActiveSpaceToken
      \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
    \else
      \FV@BreakBuffer@Append{\FancyVerbBreakAfterBreak}%
    \fi
    \FV@Break@Group{#1}}}
\def\FV@Break@AfterTokenBreak@Group@UTF@i#1{%
  \ifcsname FV@U8:\detokenize{#1}\endcsname
    \expandafter\let\expandafter\FV@Break@Next\csname FV@U8:\detokenize{#1}\endcsname
    \let\FV@UTF@octets@after\FV@Break@AfterTokenBreak@Group@UTF@i
  \else
    \def\FV@NextToken{#1}%
    \ifx\FV@LastToken\FV@NextToken
    \else
      \ifx\FV@LastToken\FV@ActiveSpaceToken
        \FV@BreakBuffer@Append{\FancyVerbSpaceBreak}%
      \else
        \FV@BreakBuffer@Append{\FancyVerbBreakAfterBreak}%
      \fi
    \fi
    \let\FV@Break@Next\FV@Break@Scan
  \fi
  \FV@Break@Next#1}
%    \end{macrocode}
% \end{macro}
%
%
% End the conditional creation of the pdfTeX |UTF| macros:
%    \begin{macrocode}
\fi
%    \end{macrocode}
%
%
%
% \paragraph{Line processing before scanning}\hfill\\
%
% \begin{macro}{\FV@makeLineNumber}
% The \pkg{lineno} package is used for formatting wrapped lines and inserting break symbols.  We need a version of \pkg{lineno}'s |\makeLineNumber| that is adapted for our purposes.  This is adapted directly from the example |\makeLineNumber| that is given in the \pkg{lineno} documentation under the discussion of internal line numbers.  The |\FV@SetLineBreakLast| is needed to determine the internal line number of the last segment of the broken line, so that we can disable the right-hand break symbol on this segment.  When a right-hand break symbol is in use, a line of code will be processed twice:  once to determine the last internal line number, and once to use this information only to insert right-hand break symbols on the appropriate lines.  During the second run, |\FV@SetLineBreakLast| is disabled by |\let|ting it to |\relax|.
%    \begin{macrocode}
\def\FV@makeLineNumber{%
  \hss
  \FancyVerbBreakSymbolLeftLogic{\FancyVerbBreakSymbolLeft}%
  \hbox to \FV@BreakSymbolSepLeft{\hfill}%
  \rlap{\hskip\linewidth
    \hbox to \FV@BreakSymbolSepRight{\hfill}%
    \FancyVerbBreakSymbolRightLogic{\FancyVerbBreakSymbolRight}%
    \FV@SetLineBreakLast
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@RaggedRight}
% We need a copy of the default |\raggedright| to ensure that everything works with classes or packages that use a special definition.
%    \begin{macrocode}
\def\FV@RaggedRight{%
  \let\\\@centercr
  \@rightskip\@flushglue\rightskip\@rightskip\leftskip\z@skip\parindent\z@}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@LineWidth}
% This is the effective line width within a broken line.
%    \begin{macrocode}
\newdimen\FV@LineWidth
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@SaveLineBox}
% This is the macro that does most of the work.  It was inspired by Marco Daniel's code at \url{http://tex.stackexchange.com/a/112573/10742}.
%
% This macro is invoked when a line is too long.  We modify |\FV@LineWidth| to take into account |breakindent| and |breakautoindent|, and insert |\hbox|es to fill the empty space.  We also account for |breaksymbolindentleft| and |breaksymbolindentright|, but \emph{only} when there are actually break symbols.  The code is placed in a |\parbox|.  Break symbols are inserted via \pkg{lineno}'s |internallinenumbers*|, which does internal line numbers without continuity between environments (the |linenumber| counter is automatically reset).  The beginning of the line has negative |\hspace| inserted to pull it out to the correct starting position.  |\strut|s are used to maintain correct line heights.  The |\parbox| is followed by an empty |\hbox| that takes up the space needed for a right-hand break symbol (if any).  |\FV@BreakByTokenAnywhereHook| is a hook for using  |breakbytokenanywhere| when working with Pygments.  Since it is within |internallinenumbers*|, its effects do not escape.
%    \begin{macrocode}
\def\FV@SaveLineBox#1{%
  \savebox{\FV@LineBox}{%
    \advance\FV@LineWidth by -\FV@BreakIndent
    \hbox to \FV@BreakIndent{\hfill}%
    \ifbool{FV@breakautoindent}%
     {\let\FV@LineIndentChars\@empty
      \FV@GetLineIndent#1\FV@Sentinel
      \savebox{\FV@LineIndentBox}{\FV@LineIndentChars}%
      \hbox to \wd\FV@LineIndentBox{\hfill}%
      \advance\FV@LineWidth by -\wd\FV@LineIndentBox
      \setcounter{FV@TrueTabCounter}{0}}%
     {}%
    \ifdefempty{\FancyVerbBreakSymbolLeft}{}%
     {\hbox to \FV@BreakSymbolIndentLeft{\hfill}%
      \advance\FV@LineWidth by -\FV@BreakSymbolIndentLeft}%
    \ifdefempty{\FancyVerbBreakSymbolRight}{}%
     {\advance\FV@LineWidth by -\FV@BreakSymbolIndentRight}%
    \parbox[t]{\FV@LineWidth}{%
      \FV@RaggedRight
      \leftlinenumbers*
      \begin{internallinenumbers*}%
      \let\makeLineNumber\FV@makeLineNumber
      \noindent\hspace*{-\FV@BreakIndent}%
      \ifdefempty{\FancyVerbBreakSymbolLeft}{}{%
        \hspace*{-\FV@BreakSymbolIndentLeft}}%
      \ifbool{FV@breakautoindent}%
       {\hspace*{-\wd\FV@LineIndentBox}}%
       {}%
      \FV@BreakByTokenAnywhereHook
      \strut\FV@InsertBreaks{\FancyVerbFormatText}{#1}\nobreak\strut
      \end{internallinenumbers*}
    }%
    \ifdefempty{\FancyVerbBreakSymbolRight}{}%
     {\hbox to \FV@BreakSymbolIndentRight{\hfill}}%
  }%
}
\def\FV@BreakByTokenAnywhereHook{}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@ListProcessLine@Break}
% This macro is based on the original |\FV@ListProcessLine| and follows it as closely as possible.  |\FV@LineWidth| is reduced by |\FV@FrameSep| and |\FV@FrameRule| so that text will not overrun frames.  This is done conditionally based on which frames are in use.  We save the current line in a box, and only do special things if the box is too wide.  For uniformity, all text is placed in a |\parbox|, even if it doesn't need to be wrapped.
%
% If a line is too wide, then it is passed to |\FV@SaveLineBox|.  If there is no right-hand break symbol, then the saved result in |\FV@LineBox| may be used immediately.  If there is a right-hand break symbol, then the line must be processed a second time, so that the right-hand break symbol may be removed from the final segment of the broken line (since it does not continue).  During the first use of |\FV@SaveLineBox|, the counter |FancyVerbLineBreakLast| is set to the internal line number of the last segment of the broken line.  During the second use of |\FV@SaveLineBox|, we disable this (|\let\FV@SetLineBreakLast\relax|) so that the value of |FancyVerbLineBreakLast| remains fixed and thus may be used to determine when a right-hand break symbol should be inserted.
%    \begin{macrocode}
\expandafter\let\expandafter\FV@iffp\csname fp_compare:nNnTF\endcsname
\def\FV@ListProcessLine@Break#1{%
  \hbox to \hsize{%
  \kern\leftmargin
  \hbox to \linewidth{%
  \FV@LineWidth\linewidth
  \ifx\FV@RightListFrame\relax\else
    \advance\FV@LineWidth by -\FV@FrameSep
    \advance\FV@LineWidth by -\FV@FrameRule
  \fi
  \ifx\FV@LeftListFrame\relax\else
    \advance\FV@LineWidth by -\FV@FrameSep
    \advance\FV@LineWidth by -\FV@FrameRule
  \fi
  \ifx\FV@Tab\FV@TrueTab
    \let\FV@TrueTabSaveWidth\FV@TrueTabSaveWidth@Save
    \setcounter{FV@TrueTabCounter}{0}%
  \fi
  \sbox{\FV@LineBox}{%
    \let\FancyVerbBreakStart\relax
    \let\FancyVerbBreakStop\relax
    \FancyVerbFormatLine{%
      %\FancyVerbHighlightLine  %<-- Default definition using \rlap breaks breaking
       {\FV@ObeyTabs{\FancyVerbFormatText{#1}}}}}%
  \ifx\FV@Tab\FV@TrueTab
    \let\FV@TrueTabSaveWidth\relax
  \fi
  \ifnum
    \FV@iffp{\the\wd\FV@LineBox}>{\FV@LineWidth}%
     {1}% width greater than line
     {\FV@iffp{\the\wd\FV@LineBox}<{0}{1}{0}}% width overflows
    >0
  \relax
    \setcounter{FancyVerbLineBreakLast}{0}%
    \ifx\FV@Tab\FV@TrueTab
      \let\FV@Tab\FV@TrueTab@UseWidth
      \setcounter{FV@TrueTabCounter}{0}%
    \fi
    \FV@SaveLineBox{#1}%
    \ifdefempty{\FancyVerbBreakSymbolRight}{}{%
      \let\FV@SetLineBreakLast\relax
      \setcounter{FV@TrueTabCounter}{0}%
      \FV@SaveLineBox{#1}}%
    \FV@LeftListNumber
    \FV@LeftListFrame
    \FV@BGColor@List{%
      \FancyVerbFormatLine{%
        \FancyVerbHighlightLine{\usebox{\FV@LineBox}}}}%
    \FV@RightListFrame
    \FV@RightListNumber
    \ifx\FV@Tab\FV@TrueTab@UseWidth
      \let\FV@Tab\FV@TrueTab
    \fi
  \else
    \let\FancyVerbBreakStart\relax
    \let\FancyVerbBreakStop\relax
    \FV@LeftListNumber
    \FV@LeftListFrame
    \FV@BGColor@List{%
      \FancyVerbFormatLine{%
        \FancyVerbHighlightLine{%
          \parbox[t]{\FV@LineWidth}{%
            \noindent\strut\FV@ObeyTabs{\FancyVerbFormatText{#1}}\strut}}}}%
    \FV@RightListFrame
    \FV@RightListNumber
  \fi}%
  \hss}\FV@bgcoloroverlap\baselineskip\z@\lineskip\z@}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Pygments compatibility}
% \label{sec:impl:pygments}
%
% This section makes line breaking compatible with \href{http://pygments.org/}{Pygments}, which is used by several packages including \pkg{minted} and \pkg{pythontex} for syntax highlighting.  A few additional line breaking options are also defined for working with Pygments.
%
% \begin{macro}{\FV@BreakBeforePrep@Pygments}
% Pygments converts some characters into macros to ensure that they appear literally.  As a result, |breakbefore| and |breakafter| would fail for these characters.  This macro checks for the existence of breaking macros for these characters, and creates breaking macros for the corresponding Pygments character macros as necessary.
%
% The argument that the macro receives is the detokenized name of the main Pygments macro, with the trailing space that detokenization produces stripped.  All macro names must end with a space, because the breaking algorithm uses detokenization on each token when checking for breaking macros, and this will produce a trailing space.
%    \begin{macrocode}
\def\FV@BreakBeforePrep@Pygments#1{%
  \ifcsname FV@BreakBefore@Token\@backslashchar\endcsname
    \@namedef{FV@BreakBefore@Token#1Zbs }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\FV@underscorechar\endcsname
    \@namedef{FV@BreakBefore@Token#1Zus }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\@charlb\endcsname
    \@namedef{FV@BreakBefore@Token#1Zob }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\@charrb\endcsname
    \@namedef{FV@BreakBefore@Token#1Zcb }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{^}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zca }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\FV@ampchar\endcsname
    \@namedef{FV@BreakBefore@Token#1Zam }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{<}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zlt }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{>}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zgt }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\FV@hashchar\endcsname
    \@namedef{FV@BreakBefore@Token#1Zsh }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\@percentchar\endcsname
    \@namedef{FV@BreakBefore@Token#1Zpc }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\FV@dollarchar\endcsname
    \@namedef{FV@BreakBefore@Token#1Zdl }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{-}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zhy }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{'}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zsq }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{"}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zdq }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\FV@tildechar\endcsname
    \@namedef{FV@BreakBefore@Token#1Zti }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{@}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zat }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{[}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zlb }{}%
  \fi
  \ifcsname FV@BreakBefore@Token\detokenize{]}\endcsname
    \@namedef{FV@BreakBefore@Token#1Zrb }{}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FV@BreakAfterPrep@Pygments}
%    \begin{macrocode}
\def\FV@BreakAfterPrep@Pygments#1{%
  \ifcsname FV@BreakAfter@Token\@backslashchar\endcsname
    \@namedef{FV@BreakAfter@Token#1Zbs }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\FV@underscorechar\endcsname
    \@namedef{FV@BreakAfter@Token#1Zus }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\@charlb\endcsname
    \@namedef{FV@BreakAfter@Token#1Zob }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\@charrb\endcsname
    \@namedef{FV@BreakAfter@Token#1Zcb }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{^}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zca }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\FV@ampchar\endcsname
    \@namedef{FV@BreakAfter@Token#1Zam }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{<}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zlt }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{>}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zgt }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\FV@hashchar\endcsname
    \@namedef{FV@BreakAfter@Token#1Zsh }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\@percentchar\endcsname
    \@namedef{FV@BreakAfter@Token#1Zpc }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\FV@dollarchar\endcsname
    \@namedef{FV@BreakAfter@Token#1Zdl }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{-}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zhy }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{'}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zsq }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{"}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zdq }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\FV@tildechar\endcsname
    \@namedef{FV@BreakAfter@Token#1Zti }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{@}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zat }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{[}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zlb }{}%
  \fi
  \ifcsname FV@BreakAfter@Token\detokenize{]}\endcsname
    \@namedef{FV@BreakAfter@Token#1Zrb }{}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{breakbytoken}
% When Pygments is used, do not allow breaks within \href{http://pygments.org/docs/tokens/}{Pygments tokens}.  So, for example, breaks would not be allowed within a string, but could occur before or after it.  This has no affect when Pygments is not in use, and is only intended for \pkg{minted}, \pkg{pythontex}, and similar packages.
%    \begin{macrocode}
\newbool{FV@breakbytoken}
\define@booleankey{FV}{breakbytoken}%
 {\booltrue{FV@breakbytoken}}%
 {\boolfalse{FV@breakbytoken}\boolfalse{FV@breakbytokenanywhere}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{breakbytokenanywhere}
% |breakbytoken| prevents breaks \emph{within} tokens.  Breaks outside of tokens may still occur at spaces.  This option also enables breaks between immediately adjacent tokens that are not separated by spaces.  Its definition is tied in with |breakbytoken| so that |breakbytoken| may be used as a check for whether either option is in use; essentially, |breakbytokenanywhere| is treated as a special case of |breakbytoken|.
%    \begin{macrocode}
\newbool{FV@breakbytokenanywhere}
\define@booleankey{FV}{breakbytokenanywhere}%
 {\booltrue{FV@breakbytokenanywhere}\booltrue{FV@breakbytoken}}%
 {\boolfalse{FV@breakbytokenanywhere}\boolfalse{FV@breakbytoken}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FancyVerbBreakByTokenAnywhereBreak}
% This is the break introduced when |breakbytokenanywhere=true|.  Alternatives would be |\discretionary{}{}{}| or |\linebreak[0]|.
%    \begin{macrocode}
\def\FancyVerbBreakByTokenAnywhereBreak{\allowbreak{}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{texcomments}
% |texcomments| retokenizes the contents of Pygments comment tokens using the catcodes in place before the verbatim context.
%    \begin{macrocode}
\newbool{FV@texcomments}
\define@booleankey{FV}{texcomments}%
 {\booltrue{FV@texcomments}}%
 {\boolfalse{FV@texcomments}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\VerbatimPygments}
% This is the command that activates Pygments features.  It must be invoked before \verb|\begin{Verbatim}|, etc., but inside a |\begingroup...\endgroup| so that its effects do not escape into the rest of the document (for example, within the beginning of an environment).  It takes two arguments:  The Pygments macro that literally appears (|\PYG| for \pkg{minted} and \pkg{pythontex}), and the Pygments macro that should actually be used (|\PYG| for \pkg{minted}, |\PYG|\meta{style\_name} for \pkg{pythontex}).  The two are distinguished because it can be convenient to highlight everything using the same literal macro name, and then |\let| it to appropriate values to change styles, rather than redoing all highlighting to change styles.  It modifies |\FV@PygmentsHook|, which is at the beginning of |\FV@FormattingPrep@PreHook|, to make the actual changes at the appropriate time.
%    \begin{macrocode}
\def\VerbatimPygments#1#2{%
  \FV@AddToHook{\FV@PygmentsHook}{\FV@VerbatimPygments{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\FV@VerbatimPygments}
% This does all the actual work.  Again, |#1| is the Pygments macro that literally appears, and |#2| is the macro that is actually to be used.
%
% The |breakbefore| and |breakafter| hooks are redefined.  This requires some trickery to get the detokenized name of the main Pygments macro without the trailing space that detokenization of a macro name produces.
%
% In the non-|breakbytoken| case, |#1| is redefined to use |#2| internally, bringing in |\FancyVerbBreakStart| and |\FancyVerbBreakStop| to allow line breaks.
%
% In the |breakbytoken| cases, an |\hbox| is used to prevent breaks within the macro (breaks could occur at spaces even without |\FancyVerbBreakStart|).  The |breakbytokenanywhere| case is similar but a little tricky.  |\FV@BreakByTokenAnywhereHook|, which is inside |\FV@SaveLineBox| where line breaking occurs, is used to define |\FV@BreakByTokenAnywhereBreak| so that it will ``do nothing'' the first time it is used and on subsequent invocations become |\FancyVerbBreakByTokenAnywhereBreak|.  Because the hook is within the |internallinenumbers*| environment, the redefinition doesn't escape, and the default global definition of |\FV@BreakByTokenAnywhereBreak| as |\relax| is not affected.  We don't want the actual break to appear before the first Pygments macro in case it might cause a spurious break after leading whitespace.  But we must have breaks \emph{before} Pygments macros because otherwise lookahead would be necessary.
%
% An intermediate variable |\FV@PYG| is defined to avoid problems in case |#1|$=$|#2|.  There is also a check for a non-existent |#2| (|\PYG|\meta{style\_name} may not be created until a later compile in the \pkg{pythontex} case); if |#2| does not exist, fall back to |#1|.  For the existence check, |\ifx...\relax| must be used instead of |\ifcsname|, because |#2| will be a macro, and will typically be created with |\csname...\endcsname| which will |\let| the macro to |\relax| if it doesn't already exist.
%
% |\FV@PYG@Redefed| is |\let| to the Pygments macro that appears literally (after redefinition), so that it can be detected elsewhere to allow for special processing, such as in |breakautoindent|.
%
% Escape (|esc|) tokens are always retokenized.  Comment (|c|) tokens are retokenized if the |texcomments| option is true.  Reference for token abbreviations:  \url{https://github.com/pygments/pygments/blob/master/pygments/token.py}.
%    \begin{macrocode}
\def\FV@VerbatimPygments#1#2{%
  \ifx#2\relax
    \let\FV@PYG@orig=#1\relax
  \else
    \let\FV@PYG@orig=#2\relax
  \fi
  \let#1\FV@PYG
  \ifbool{FV@breaklines}%
   {\edef\FV@PYG@name{\expandafter\FV@DetokMacro@StripSpace\detokenize{#1}}%
    \def\FV@BreakBeforePrep@PygmentsHook{%
      \expandafter\FV@BreakBeforePrep@Pygments\expandafter{\FV@PYG@name}}%
    \def\FV@BreakAfterPrep@PygmentsHook{%
      \expandafter\FV@BreakAfterPrep@Pygments\expandafter{\FV@PYG@name}}%
    \ifbool{FV@breakbytoken}%
     {\ifbool{FV@breakbytokenanywhere}%
       {\def\FV@BreakByTokenAnywhereHook{%
          \def\FV@BreakByTokenAnywhereBreak{%
            \let\FV@BreakByTokenAnywhereBreak\FancyVerbBreakByTokenAnywhereBreak}}%
        \def\FV@PYG@retoked##1##2{%
          \FV@BreakByTokenAnywhereBreak
          \leavevmode\hbox{\FV@PYG@orig{##1}{##2}}}}%
       {\def\FV@PYG@retoked##1##2{%
          \leavevmode\hbox{\FV@PYG@orig{##1}{##2}}}}}%
     {\def\FV@PYG@retoked##1##2{%
       \ifbool{FV@PYG@doretok}%
        {\FV@PYG@orig{##1}{##2}}%
        {\FV@PYG@orig{##1}{\FancyVerbBreakStart##2\FancyVerbBreakStop}}}}}%
   {\let\FV@PYG@retoked\FV@PYG@orig}%
  \let\FV@PYG@Redefed\FV@PYG}
\let\FV@BreakByTokenAnywhereBreak\relax
\def\FV@DetokMacro@StripSpace#1 {#1}
\newbool{FV@PYG@doretok}
\begingroup
\catcode`\+=12
\gdef\FV@PYG@setretok#1+{%
  \ifx\relax#1\@empty
  \else
    \ifstrequal{#1}{c}%
     {\ifbool{FV@texcomments}{\booltrue{FV@PYG@doretok}}{}}%
     {\ifstrequal{#1}{esc}{\booltrue{FV@PYG@doretok}}{}}%
    \expandafter\FV@PYG@setretok
  \fi}
\endgroup
\def\FV@PYG#1#2{%
  \expandafter\FV@PYG@i\expandafter{\detokenize{#1}}{#2}}
\def\FV@PYG@i#1#2{%
  \begingroup
  \boolfalse{FV@PYG@doretok}%
  \FV@PYG@setretok#1+\relax+%
  \ifbool{FV@PYG@doretok}%
   {\FVExtraDetokenizeVArg{%
     \FVExtraRetokenizeVArg{\FV@PYG@retoked{#1}}{\FancyVerbRestoreCodes}}{#2}}%
   {\FV@PYG@retoked{#1}{#2}}%
  \endgroup}%
%    \end{macrocode}
% \end{macro}
%
%
% \iffalse
%</package>
% \fi
%% \Finale
\endinput
